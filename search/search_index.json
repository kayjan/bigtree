{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83c\udf33 Documentation","text":"<p>Tree Implementation and Methods for Python, integrated with list, dictionary, pandas and polars DataFrame.</p> <p>It is pythonic, making it easy to learn and extendable to many types of workflows.</p> <ul> <li> Set up in 2 minutes <p>Install <code>bigtree</code> and get up and running in minutes</p> <p> Installation</p> </li> </ul> <ul> <li> Getting started <p>View demonstration on how to use <code>bigtree</code></p> <p> Reference</p> </li> </ul> <ul> <li> Playground <p>Get some hands-on with <code>bigtree</code>!</p> <p> Play</p> </li> </ul> <ul> <li> Support bigtree <p>Do support if you like this project!</p> <p> Support</p> </li> </ul> <p>Related Links:</p> <ul> <li>Community: Issues / Discussions</li> <li>Package: PyPI / Conda</li> </ul>"},{"location":"home/","title":"\ud83c\udf33 Documentation","text":"<p>Tree Implementation and Methods for Python, integrated with list, dictionary, pandas and polars DataFrame.</p> <p>It is pythonic, making it easy to learn and extendable to many types of workflows.</p> <ul> <li> Set up in 2 minutes <p>Install <code>bigtree</code> and get up and running in minutes</p> <p> Installation</p> </li> </ul> <ul> <li> Getting started <p>View demonstration on how to use <code>bigtree</code></p> <p> Reference</p> </li> </ul> <ul> <li> Playground <p>Get some hands-on with <code>bigtree</code>!</p> <p> Play</p> </li> </ul> <ul> <li> Support bigtree <p>Do support if you like this project!</p> <p> Support</p> </li> </ul> <p>Related Links:</p> <ul> <li>Community: Issues / Discussions</li> <li>Package: PyPI / Conda</li> </ul>"},{"location":"_static/playground/","title":"Playground","text":"In\u00a0[\u00a0]: Copied! <pre>%matplotlib inline\n</pre> %matplotlib inline <p>Execute Python code in code blocks (Adapted from ColorAide).</p> <p>This can be executed in either a Pyodide environment of a normal Python environment. Transform Python code by executing it, transforming to a Python console output, and finding and outputting color previews.</p> In\u00a0[\u00a0]: Copied! <pre>import ast\nimport re\nimport sys\nfrom collections.abc import Mapping, Sequence\nfrom functools import partial\nfrom io import StringIO\n\nfrom pygments import highlight\nfrom pygments.formatters import find_formatter_class\nfrom pygments.lexers import get_lexer_by_name\n\nPY310 = (3, 10) &lt;= sys.version_info\nPY311 = (3, 11) &lt;= sys.version_info\n\nWEBSPACE = \"srgb\"\n\nAST_BLOCKS = (\n    ast.If,\n    ast.For,\n    ast.While,\n    ast.Try,\n    ast.With,\n    ast.FunctionDef,\n    ast.ClassDef,\n    ast.AsyncFor,\n    ast.AsyncWith,\n    ast.AsyncFunctionDef,\n)\n\nif PY310:\n    AST_BLOCKS = AST_BLOCKS + (ast.Match,)\n\n\nif PY311:\n    AST_BLOCKS = AST_BLOCKS + (ast.TryStar,)\n\n\nRE_INIT = re.compile(\n    r\"^\\s*#\\s*pragma:\\s*init\\n(.*?)#\\s*pragma:\\s*init\\n\", re.DOTALL | re.I\n)\n\ntemplate = \"\"\"&lt;div class=\"playground\" id=\"__playground_{el_id}\"&gt;\n&lt;div class=\"playground-results\" id=\"__playground-results_{el_id}\"&gt;\n{results}\n&lt;/div&gt;\n&lt;div class=\"playground-code hidden\" id=\"__playground-code_{el_id}\" data-search-exclude&gt;\n&lt;form autocomplete=\"off\"&gt;\n&lt;textarea class=\"playground-inputs\" id=\"__playground-inputs_{el_id}\" spellcheck=\"false\"&gt;{raw_source}&lt;/textarea&gt;\n&lt;/form&gt;\n&lt;/div&gt;\n&lt;div class=\"playground-footer\" data-search-exclude&gt;\n&lt;hr&gt;\n&lt;button id=\"__playground-edit_{el_id}\" class=\"playground-edit\" title=\"Edit the code snippet\"&gt;Edit&lt;/button&gt;\n&lt;button id=\"__playground-share_{el_id}\" style=\"display:none\" class=\"playground-share\" title=\"Copy code snippet\"&gt;Share&lt;/button&gt;\n&lt;button id=\"__playground-run_{el_id}\" class=\"playground-run hidden\" title=\"Run code\"&gt;Run&lt;/button&gt;\n&lt;button id=\"__playground-cancel_{el_id}\" class=\"playground-cancel hidden\" title=\"Cancel edit\"&gt;Cancel&lt;/button&gt;\n&lt;span class='gamut'&gt;Powered by Pyodide. Gamut: {gamut}.&lt;/span&gt;\n&lt;/div&gt;\n&lt;/div&gt;\"\"\"\n\ncode_id = 0\n\n\nclass Ramp(list):\n    \"\"\"Create a gradient from a list of colors.\"\"\"\n\n\nclass Steps(list):\n    \"\"\"Create a special display of steps from a list of colors.\"\"\"\n\n\nclass Row(list):\n    \"\"\"Restrict only the provided colors to a row.\"\"\"\n\n\nclass AtomicString(str):\n    \"\"\"Atomic string.\"\"\"\n\n\nclass BreakException(Exception):\n    \"\"\"Break exception.\"\"\"\n\n\nclass ContinueException(Exception):\n    \"\"\"Continue exception.\"\"\"\n\n\n# Legacy names\nHtmlGradient = Ramp\nHtmlSteps = Steps\nHtmlRow = Row\n\n\ndef _escape(txt):\n    \"\"\"Basic HTML escaping.\"\"\"\n\n    txt = txt.replace(\"&amp;\", \"&amp;amp;\")\n    txt = txt.replace(\"&lt;\", \"&amp;lt;\")\n    txt = txt.replace(\"&gt;\", \"&amp;gt;\")\n    return txt\n\n\nclass StreamOut:\n    \"\"\"Override the standard out.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize.\"\"\"\n        self.old = sys.stdout\n        self.stdout = StringIO()\n        sys.stdout = self.stdout\n\n    def read(self):\n        \"\"\"Read the stringIO buffer.\"\"\"\n\n        value = \"\"\n        if self.stdout is not None:\n            self.stdout.flush()\n            value = self.stdout.getvalue()\n            self.stdout = StringIO()\n            sys.stdout = self.stdout\n        return value\n\n    def __enter__(self):\n        \"\"\"Enter.\"\"\"\n        return self\n\n    def __exit__(self, type, value, traceback):  # noqa: A002\n        \"\"\"Exit.\"\"\"\n\n        sys.stdout = self.old\n        self.old = None\n        self.stdout = None\n\n\ndef evaluate_with(node, g, loop, index=0):\n    \"\"\"Evaluate with.\"\"\"\n\n    l = len(node.items) - 1  # noqa\n    withitem = node.items[index]\n    if withitem.context_expr:\n        with eval(\n            compile(ast.Expression(withitem.context_expr), \"&lt;string&gt;\", \"eval\"), g\n        ) as w:\n            g[withitem.optional_vars.id] = w\n            if index &lt; l:\n                evaluate_with(node, g, loop, index + 1)\n            else:\n                for n in node.body:\n                    yield from evaluate(n, g, loop)\n    else:\n        with eval(\n            compile(ast.Expression(withitem.context_expr), \"&lt;string&gt;\", \"eval\"), g\n        ):\n            if index &lt; l:\n                evaluate_with(node, g, loop, index + 1)\n            else:\n                for n in node.body:\n                    yield from evaluate(n, g, loop)\n\n\ndef compare_match(s, g, node):\n    \"\"\"Compare a match.\"\"\"\n\n    if isinstance(node, ast.MatchOr):\n        for pattern in node.patterns:\n            if compare_match(s, g, pattern):\n                return True\n    else:\n        if isinstance(node, ast.MatchValue):\n            p = eval(compile(ast.Expression(node.value), \"&lt;string&gt;\", \"eval\"), g)\n            return s == p\n        elif isinstance(node, ast.MatchSingleton):\n            return s is node.value\n        elif isinstance(node, ast.MatchSequence):\n            if isinstance(s, Sequence):\n                star = isinstance(node.patterns[-1], ast.MatchStar)\n                l1, l2 = len(s), len(node.patterns)\n                if (star and l1 &gt;= l2 - 1) or (l1 == l2):\n                    for e, p in enumerate(\n                        node.patterns[:-1] if star else node.patterns\n                    ):\n                        if not compare_match(s[e], g, p):\n                            return False\n                    if star and node.patterns[-1].name:\n                        g[node.patterns[-1].name] = s[l2 - 1 :]  # noqa\n                    return True\n            return False\n        elif isinstance(node, ast.MatchMapping):\n            if isinstance(s, Mapping):\n                star = node.rest\n                l1, l2 = len(s), len(node.patterns)\n                if (star and l1 &gt;= l2) or (l1 == l2):\n                    keys = set()\n                    for kp, vp in zip(node.keys, node.patterns):\n                        key = eval(compile(ast.Expression(kp), \"&lt;string&gt;\", \"eval\"), g)\n                        keys.add(key)\n                        if key not in s:\n                            return False\n                        if not compare_match(s[key], g, vp):\n                            return False\n                    if star:\n                        g[star] = {k: v for k, v in s.items() if k not in keys}\n                    return True\n            return False\n        elif isinstance(node, ast.MatchClass):\n            name = g.get(node.cls.id, None)\n            if name is None:\n                raise NameError(\"name '{}' is not defined\".format(node.cls.id))\n            if not isinstance(s, name):\n                return False\n            ma = getattr(s, \"__match_args__\", ())\n            l1 = len(ma)\n            l2 = len(node.patterns)\n            if l1 &lt; l2:\n                raise TypeError(\n                    \"{}() accepts {} positional sub-patterns ({} given)\".format(\n                        name, l1, l2\n                    )\n                )\n            for e, p in enumerate(node.patterns):\n                if not hasattr(s, ma[e]):\n                    return False\n                if not compare_match(getattr(s, ma[e]), g, p):\n                    return False\n            for a, p in zip(node.kwd_attrs, node.kwd_patterns):\n                if not hasattr(s, a):\n                    return False\n                if not compare_match(getattr(s, a), g, p):\n                    return False\n            return True\n        elif isinstance(node, ast.MatchAs):\n            if node.name is not None:\n                g[node.name] = s\n            if node.pattern:\n                return compare_match(s, g, node.pattern)\n            return True\n\n    raise RuntimeError(\"Unknown Match pattern {}\".format(str(node)))\n\n\ndef evaluate_except(node, e, g, loop=False):\n    \"\"\"Evaluate normal except block.\"\"\"\n\n    for n in node.handlers:\n        if n.name:\n            g[n.name] = e\n        if n.type is None:\n            for ne in n.body:\n                yield from evaluate(ne, g, loop)\n            break\n        else:\n            if isinstance(\n                e, eval(compile(ast.Expression(n.type), \"&lt;string&gt;\", \"eval\"), g)\n            ):\n                for ne in n.body:\n                    yield from evaluate(ne, g, loop)\n                break\n    else:\n        raise\n\n\ndef evaluate(node, g, loop=False):\n    \"\"\"Evaluate.\"\"\"\n\n    if loop and isinstance(node, ast.Break):\n        raise BreakException\n\n    if loop and isinstance(node, ast.Continue):\n        raise ContinueException\n\n    if isinstance(node, ast.Expr):\n        _eval = ast.Expression(node.value)\n        yield eval(compile(_eval, \"&lt;string&gt;\", \"eval\"), g)\n    elif isinstance(node, ast.If):\n        if eval(compile(ast.Expression(node.test), \"&lt;string&gt;\", \"eval\"), g):\n            for n in node.body:\n                yield from evaluate(n, g, loop)\n        elif node.orelse:\n            for n in node.orelse:\n                yield from evaluate(n, g, loop)\n    elif isinstance(node, ast.While):\n        while eval(compile(ast.Expression(node.test), \"&lt;string&gt;\", \"eval\"), g):\n            try:\n                for n in node.body:\n                    yield from evaluate(n, g, True)\n            except BreakException:  # noqa\n                break\n            except ContinueException:\n                continue\n        else:\n            for n in node.orelse:\n                yield from evaluate(n, g, loop)\n    elif isinstance(node, ast.For):\n        for x in eval(compile(ast.Expression(node.iter), \"&lt;string&gt;\", \"eval\"), g):\n            if isinstance(node.target, ast.Tuple):\n                for e, t in enumerate(node.target.dims):\n                    g[t.id] = x[e]\n            else:\n                g[node.target.id] = x\n            try:\n                for n in node.body:\n                    yield from evaluate(n, g, True)\n            except BreakException:  # noqa\n                break\n            except ContinueException:\n                continue\n        else:\n            for n in node.orelse:\n                yield from evaluate(n, g, loop)\n    elif isinstance(node, ast.Try):\n        try:\n            for n in node.body:\n                yield from evaluate(n, g, loop)\n        except Exception as e:\n            yield from evaluate_except(node, e, g, loop)\n        else:\n            for n in node.orelse:\n                yield from evaluate(n, g, loop)\n        finally:\n            for n in node.finalbody:\n                yield from evaluate(n, g, loop)\n    elif PY311 and isinstance(node, ast.TryStar):\n        try:\n            for n in node.body:\n                yield from evaluate(n, g, loop)\n        except ExceptionGroup as e:  # noqa\n            for n in node.handlers:\n                if n.name:\n                    g[n.name] = e\n                m, e = e.split(\n                    eval(compile(ast.Expression(n.type), \"&lt;string&gt;\", \"eval\"), g)\n                )\n                if m is not None:\n                    for ne in n.body:\n                        yield from evaluate(ne, g, loop)\n                if e is None:\n                    break\n            if e is not None:\n                raise e\n        except Exception as e:\n            yield from evaluate_except(node, e, g, loop)\n        else:\n            for n in node.orelse:\n                yield from evaluate(n, g, loop)\n        finally:\n            for n in node.finalbody:\n                yield from evaluate(n, g, loop)\n    elif PY310 and isinstance(node, ast.Match):\n        s = eval(compile(ast.Expression(node.subject), \"&lt;string&gt;\", \"eval\"), g)\n        for c in node.cases:\n            if compare_match(s, g, c.pattern):\n                if not c.guard or eval(\n                    compile(ast.Expression(c.guard), \"&lt;string&gt;\", \"eval\"), g\n                ):\n                    for n in c.body:\n                        yield from evaluate(n, g, loop)\n                    break\n    elif isinstance(node, ast.With):\n        yield from evaluate_with(node, g, loop)\n    else:\n        _exec = ast.Module([node], [])\n        exec(compile(_exec, \"&lt;string&gt;\", \"exec\"), g)\n        yield None\n\n\ndef execute(cmd, no_except=True, inline=False, init=\"\", g=None):\n    \"\"\"Execute color commands.\"\"\"\n\n    console = \"\"\n\n    # Setup global initialisation\n    if g is None:\n        g = {\n            \"Ramp\": Ramp,\n            \"Steps\": Steps,\n            \"Row\": Row,\n            \"HtmlRow\": HtmlRow,\n            \"HtmlSteps\": HtmlSteps,\n            \"HtmlGradient\": HtmlGradient,\n        }\n    if init:\n        execute(init.strip(), g=g)\n\n    # Build AST tree\n    m = RE_INIT.match(cmd)\n    if m:\n        block_init = m.group(1)\n        src = cmd[m.end() :]  # noqa\n        execute(block_init, g=g)\n    else:\n        src = cmd\n    lines = src.split(\"\\n\")\n    try:\n        tree = ast.parse(src)\n    except Exception as e:\n        if no_except:\n            if not inline:\n                from pymdownx.superfences import SuperFencesException\n\n                raise SuperFencesException from e\n            else:\n                from pymdownx.inlinehilite import InlineHiliteException\n\n                raise InlineHiliteException from e\n        import traceback\n\n        return \"{}\".format(traceback.format_exc())\n\n    for node in tree.body:\n        result = []\n\n        # Format source as Python console statements\n        start = node.lineno\n        end = node.end_lineno\n        stmt = lines[start - 1 : end]  # noqa\n        command = \"\"\n        stmt = [\n            f\"&gt;&gt;&gt; {_stmt}\" if not idx else f\"... {_stmt}\"\n            for idx, _stmt in enumerate(stmt)\n        ]\n        command += \"\\n\".join(stmt)\n        if isinstance(node, AST_BLOCKS):\n            command += \"\\n... \"\n\n        try:\n            # Capture anything sent to standard out\n            with StreamOut() as s:\n                # Execute code\n                for x in evaluate(node, g):\n                    result.append(x)\n\n                    # Output captured standard out after statements\n                    text = s.read()\n                    if text:\n                        result.append(AtomicString(text))\n\n                # Execution went well, so append command\n                console += command\n\n        except Exception as e:  # noqa:  PERF203\n            if no_except:\n                if not inline:\n                    from pymdownx.superfences import SuperFencesException\n\n                    raise SuperFencesException from e\n                else:\n                    from pymdownx.inlinehilite import InlineHiliteException\n\n                    raise InlineHiliteException from e\n            import traceback\n\n            console += \"{}\\n{}\".format(command, traceback.format_exc())\n            # Failed for some reason, so quit\n            break\n\n        # If we got a result, output it as well\n        result_text = \"\\n\"\n        for r in result:\n            if r is None:\n                continue\n            result_text += \"{}{}\".format(\n                (\n                    repr(r)\n                    if isinstance(r, str) and not isinstance(r, AtomicString)\n                    else str(r)\n                ),\n                \"\\n\" if not isinstance(r, AtomicString) else \"\",\n            )\n        console += result_text\n\n    return console\n\n\ndef colorize(src, lang, **options):\n    \"\"\"Colorize.\"\"\"\n\n    HtmlFormatter = find_formatter_class(\"html\")\n    lexer = get_lexer_by_name(lang, **options)\n    formatter = HtmlFormatter(cssclass=\"highlight\", wrapcode=True)\n    return highlight(src, lexer, formatter).strip()\n\n\ndef color_command_validator(language, inputs, options, attrs, md):\n    \"\"\"Color validator.\"\"\"\n\n    valid_inputs = {\"exceptions\", \"play\", \"wheel\"}\n\n    for k, v in inputs.items():\n        if k in valid_inputs:\n            options[k] = True\n            continue\n        attrs[k] = v\n    return True\n\n\ndef _color_command_formatter(\n    src=\"\", language=\"\", class_name=None, options=None, md=\"\", init=\"\", **kwargs\n):\n    \"\"\"Formatter wrapper.\"\"\"\n\n    global code_id\n\n    # Support the new way\n    gamut = kwargs.get(\"gamut\", WEBSPACE)\n    play = options.get(\"play\", False) if options is not None else False\n    # Support the old way\n    if not play and language == \"playground\":\n        play = True\n\n    if not play:\n        return md.preprocessors[\"fenced_code_block\"].extension.superfences[0][\n            \"formatter\"\n        ](\n            src=src,\n            class_name=class_name,\n            language=\"py\",\n            md=md,\n            options=options,\n            **kwargs,\n        )\n\n    if len(md.preprocessors[\"fenced_code_block\"].extension.stash) == 0:\n        code_id = 0\n\n    # Check if we should allow exceptions\n    exceptions = options.get(\"exceptions\", False) if options is not None else False\n\n    console = execute(src.strip(), not exceptions, init=init)\n\n    el = md.preprocessors[\"fenced_code_block\"].extension.superfences[0][\"formatter\"](\n        src=console,\n        class_name=\"highlight\",\n        language=\"pycon\",\n        md=md,\n        options=options,\n        **kwargs,\n    )\n    el = '&lt;div class=\"color-command\"&gt;{}&lt;/div&gt;'.format(el)\n    el = template.format(\n        el_id=code_id, raw_source=_escape(src), results=el, gamut=gamut\n    )\n    code_id += 1\n    return el\n\n\ndef color_command_formatter(init=\"\", gamut=WEBSPACE):\n    \"\"\"Return a Python command formatter with the provided imports.\"\"\"\n\n    return partial(_color_command_formatter, init=init, gamut=gamut)\n</pre> import ast import re import sys from collections.abc import Mapping, Sequence from functools import partial from io import StringIO  from pygments import highlight from pygments.formatters import find_formatter_class from pygments.lexers import get_lexer_by_name  PY310 = (3, 10) &lt;= sys.version_info PY311 = (3, 11) &lt;= sys.version_info  WEBSPACE = \"srgb\"  AST_BLOCKS = (     ast.If,     ast.For,     ast.While,     ast.Try,     ast.With,     ast.FunctionDef,     ast.ClassDef,     ast.AsyncFor,     ast.AsyncWith,     ast.AsyncFunctionDef, )  if PY310:     AST_BLOCKS = AST_BLOCKS + (ast.Match,)   if PY311:     AST_BLOCKS = AST_BLOCKS + (ast.TryStar,)   RE_INIT = re.compile(     r\"^\\s*#\\s*pragma:\\s*init\\n(.*?)#\\s*pragma:\\s*init\\n\", re.DOTALL | re.I )  template = \"\"\"  {results}  \"\"\"  code_id = 0   class Ramp(list):     \"\"\"Create a gradient from a list of colors.\"\"\"   class Steps(list):     \"\"\"Create a special display of steps from a list of colors.\"\"\"   class Row(list):     \"\"\"Restrict only the provided colors to a row.\"\"\"   class AtomicString(str):     \"\"\"Atomic string.\"\"\"   class BreakException(Exception):     \"\"\"Break exception.\"\"\"   class ContinueException(Exception):     \"\"\"Continue exception.\"\"\"   # Legacy names HtmlGradient = Ramp HtmlSteps = Steps HtmlRow = Row   def _escape(txt):     \"\"\"Basic HTML escaping.\"\"\"      txt = txt.replace(\"&amp;\", \"&amp;\")     txt = txt.replace(\"&lt;\", \"&lt;\")     txt = txt.replace(\"&gt;\", \"&gt;\")     return txt   class StreamOut:     \"\"\"Override the standard out.\"\"\"      def __init__(self):         \"\"\"Initialize.\"\"\"         self.old = sys.stdout         self.stdout = StringIO()         sys.stdout = self.stdout      def read(self):         \"\"\"Read the stringIO buffer.\"\"\"          value = \"\"         if self.stdout is not None:             self.stdout.flush()             value = self.stdout.getvalue()             self.stdout = StringIO()             sys.stdout = self.stdout         return value      def __enter__(self):         \"\"\"Enter.\"\"\"         return self      def __exit__(self, type, value, traceback):  # noqa: A002         \"\"\"Exit.\"\"\"          sys.stdout = self.old         self.old = None         self.stdout = None   def evaluate_with(node, g, loop, index=0):     \"\"\"Evaluate with.\"\"\"      l = len(node.items) - 1  # noqa     withitem = node.items[index]     if withitem.context_expr:         with eval(             compile(ast.Expression(withitem.context_expr), \"\", \"eval\"), g         ) as w:             g[withitem.optional_vars.id] = w             if index &lt; l:                 evaluate_with(node, g, loop, index + 1)             else:                 for n in node.body:                     yield from evaluate(n, g, loop)     else:         with eval(             compile(ast.Expression(withitem.context_expr), \"\", \"eval\"), g         ):             if index &lt; l:                 evaluate_with(node, g, loop, index + 1)             else:                 for n in node.body:                     yield from evaluate(n, g, loop)   def compare_match(s, g, node):     \"\"\"Compare a match.\"\"\"      if isinstance(node, ast.MatchOr):         for pattern in node.patterns:             if compare_match(s, g, pattern):                 return True     else:         if isinstance(node, ast.MatchValue):             p = eval(compile(ast.Expression(node.value), \"\", \"eval\"), g)             return s == p         elif isinstance(node, ast.MatchSingleton):             return s is node.value         elif isinstance(node, ast.MatchSequence):             if isinstance(s, Sequence):                 star = isinstance(node.patterns[-1], ast.MatchStar)                 l1, l2 = len(s), len(node.patterns)                 if (star and l1 &gt;= l2 - 1) or (l1 == l2):                     for e, p in enumerate(                         node.patterns[:-1] if star else node.patterns                     ):                         if not compare_match(s[e], g, p):                             return False                     if star and node.patterns[-1].name:                         g[node.patterns[-1].name] = s[l2 - 1 :]  # noqa                     return True             return False         elif isinstance(node, ast.MatchMapping):             if isinstance(s, Mapping):                 star = node.rest                 l1, l2 = len(s), len(node.patterns)                 if (star and l1 &gt;= l2) or (l1 == l2):                     keys = set()                     for kp, vp in zip(node.keys, node.patterns):                         key = eval(compile(ast.Expression(kp), \"\", \"eval\"), g)                         keys.add(key)                         if key not in s:                             return False                         if not compare_match(s[key], g, vp):                             return False                     if star:                         g[star] = {k: v for k, v in s.items() if k not in keys}                     return True             return False         elif isinstance(node, ast.MatchClass):             name = g.get(node.cls.id, None)             if name is None:                 raise NameError(\"name '{}' is not defined\".format(node.cls.id))             if not isinstance(s, name):                 return False             ma = getattr(s, \"__match_args__\", ())             l1 = len(ma)             l2 = len(node.patterns)             if l1 &lt; l2:                 raise TypeError(                     \"{}() accepts {} positional sub-patterns ({} given)\".format(                         name, l1, l2                     )                 )             for e, p in enumerate(node.patterns):                 if not hasattr(s, ma[e]):                     return False                 if not compare_match(getattr(s, ma[e]), g, p):                     return False             for a, p in zip(node.kwd_attrs, node.kwd_patterns):                 if not hasattr(s, a):                     return False                 if not compare_match(getattr(s, a), g, p):                     return False             return True         elif isinstance(node, ast.MatchAs):             if node.name is not None:                 g[node.name] = s             if node.pattern:                 return compare_match(s, g, node.pattern)             return True      raise RuntimeError(\"Unknown Match pattern {}\".format(str(node)))   def evaluate_except(node, e, g, loop=False):     \"\"\"Evaluate normal except block.\"\"\"      for n in node.handlers:         if n.name:             g[n.name] = e         if n.type is None:             for ne in n.body:                 yield from evaluate(ne, g, loop)             break         else:             if isinstance(                 e, eval(compile(ast.Expression(n.type), \"\", \"eval\"), g)             ):                 for ne in n.body:                     yield from evaluate(ne, g, loop)                 break     else:         raise   def evaluate(node, g, loop=False):     \"\"\"Evaluate.\"\"\"      if loop and isinstance(node, ast.Break):         raise BreakException      if loop and isinstance(node, ast.Continue):         raise ContinueException      if isinstance(node, ast.Expr):         _eval = ast.Expression(node.value)         yield eval(compile(_eval, \"\", \"eval\"), g)     elif isinstance(node, ast.If):         if eval(compile(ast.Expression(node.test), \"\", \"eval\"), g):             for n in node.body:                 yield from evaluate(n, g, loop)         elif node.orelse:             for n in node.orelse:                 yield from evaluate(n, g, loop)     elif isinstance(node, ast.While):         while eval(compile(ast.Expression(node.test), \"\", \"eval\"), g):             try:                 for n in node.body:                     yield from evaluate(n, g, True)             except BreakException:  # noqa                 break             except ContinueException:                 continue         else:             for n in node.orelse:                 yield from evaluate(n, g, loop)     elif isinstance(node, ast.For):         for x in eval(compile(ast.Expression(node.iter), \"\", \"eval\"), g):             if isinstance(node.target, ast.Tuple):                 for e, t in enumerate(node.target.dims):                     g[t.id] = x[e]             else:                 g[node.target.id] = x             try:                 for n in node.body:                     yield from evaluate(n, g, True)             except BreakException:  # noqa                 break             except ContinueException:                 continue         else:             for n in node.orelse:                 yield from evaluate(n, g, loop)     elif isinstance(node, ast.Try):         try:             for n in node.body:                 yield from evaluate(n, g, loop)         except Exception as e:             yield from evaluate_except(node, e, g, loop)         else:             for n in node.orelse:                 yield from evaluate(n, g, loop)         finally:             for n in node.finalbody:                 yield from evaluate(n, g, loop)     elif PY311 and isinstance(node, ast.TryStar):         try:             for n in node.body:                 yield from evaluate(n, g, loop)         except ExceptionGroup as e:  # noqa             for n in node.handlers:                 if n.name:                     g[n.name] = e                 m, e = e.split(                     eval(compile(ast.Expression(n.type), \"\", \"eval\"), g)                 )                 if m is not None:                     for ne in n.body:                         yield from evaluate(ne, g, loop)                 if e is None:                     break             if e is not None:                 raise e         except Exception as e:             yield from evaluate_except(node, e, g, loop)         else:             for n in node.orelse:                 yield from evaluate(n, g, loop)         finally:             for n in node.finalbody:                 yield from evaluate(n, g, loop)     elif PY310 and isinstance(node, ast.Match):         s = eval(compile(ast.Expression(node.subject), \"\", \"eval\"), g)         for c in node.cases:             if compare_match(s, g, c.pattern):                 if not c.guard or eval(                     compile(ast.Expression(c.guard), \"\", \"eval\"), g                 ):                     for n in c.body:                         yield from evaluate(n, g, loop)                     break     elif isinstance(node, ast.With):         yield from evaluate_with(node, g, loop)     else:         _exec = ast.Module([node], [])         exec(compile(_exec, \"\", \"exec\"), g)         yield None   def execute(cmd, no_except=True, inline=False, init=\"\", g=None):     \"\"\"Execute color commands.\"\"\"      console = \"\"      # Setup global initialisation     if g is None:         g = {             \"Ramp\": Ramp,             \"Steps\": Steps,             \"Row\": Row,             \"HtmlRow\": HtmlRow,             \"HtmlSteps\": HtmlSteps,             \"HtmlGradient\": HtmlGradient,         }     if init:         execute(init.strip(), g=g)      # Build AST tree     m = RE_INIT.match(cmd)     if m:         block_init = m.group(1)         src = cmd[m.end() :]  # noqa         execute(block_init, g=g)     else:         src = cmd     lines = src.split(\"\\n\")     try:         tree = ast.parse(src)     except Exception as e:         if no_except:             if not inline:                 from pymdownx.superfences import SuperFencesException                  raise SuperFencesException from e             else:                 from pymdownx.inlinehilite import InlineHiliteException                  raise InlineHiliteException from e         import traceback          return \"{}\".format(traceback.format_exc())      for node in tree.body:         result = []          # Format source as Python console statements         start = node.lineno         end = node.end_lineno         stmt = lines[start - 1 : end]  # noqa         command = \"\"         stmt = [             f\"&gt;&gt;&gt; {_stmt}\" if not idx else f\"... {_stmt}\"             for idx, _stmt in enumerate(stmt)         ]         command += \"\\n\".join(stmt)         if isinstance(node, AST_BLOCKS):             command += \"\\n... \"          try:             # Capture anything sent to standard out             with StreamOut() as s:                 # Execute code                 for x in evaluate(node, g):                     result.append(x)                      # Output captured standard out after statements                     text = s.read()                     if text:                         result.append(AtomicString(text))                  # Execution went well, so append command                 console += command          except Exception as e:  # noqa:  PERF203             if no_except:                 if not inline:                     from pymdownx.superfences import SuperFencesException                      raise SuperFencesException from e                 else:                     from pymdownx.inlinehilite import InlineHiliteException                      raise InlineHiliteException from e             import traceback              console += \"{}\\n{}\".format(command, traceback.format_exc())             # Failed for some reason, so quit             break          # If we got a result, output it as well         result_text = \"\\n\"         for r in result:             if r is None:                 continue             result_text += \"{}{}\".format(                 (                     repr(r)                     if isinstance(r, str) and not isinstance(r, AtomicString)                     else str(r)                 ),                 \"\\n\" if not isinstance(r, AtomicString) else \"\",             )         console += result_text      return console   def colorize(src, lang, **options):     \"\"\"Colorize.\"\"\"      HtmlFormatter = find_formatter_class(\"html\")     lexer = get_lexer_by_name(lang, **options)     formatter = HtmlFormatter(cssclass=\"highlight\", wrapcode=True)     return highlight(src, lexer, formatter).strip()   def color_command_validator(language, inputs, options, attrs, md):     \"\"\"Color validator.\"\"\"      valid_inputs = {\"exceptions\", \"play\", \"wheel\"}      for k, v in inputs.items():         if k in valid_inputs:             options[k] = True             continue         attrs[k] = v     return True   def _color_command_formatter(     src=\"\", language=\"\", class_name=None, options=None, md=\"\", init=\"\", **kwargs ):     \"\"\"Formatter wrapper.\"\"\"      global code_id      # Support the new way     gamut = kwargs.get(\"gamut\", WEBSPACE)     play = options.get(\"play\", False) if options is not None else False     # Support the old way     if not play and language == \"playground\":         play = True      if not play:         return md.preprocessors[\"fenced_code_block\"].extension.superfences[0][             \"formatter\"         ](             src=src,             class_name=class_name,             language=\"py\",             md=md,             options=options,             **kwargs,         )      if len(md.preprocessors[\"fenced_code_block\"].extension.stash) == 0:         code_id = 0      # Check if we should allow exceptions     exceptions = options.get(\"exceptions\", False) if options is not None else False      console = execute(src.strip(), not exceptions, init=init)      el = md.preprocessors[\"fenced_code_block\"].extension.superfences[0][\"formatter\"](         src=console,         class_name=\"highlight\",         language=\"pycon\",         md=md,         options=options,         **kwargs,     )     el = '{}'.format(el)     el = template.format(         el_id=code_id, raw_source=_escape(src), results=el, gamut=gamut     )     code_id += 1     return el   def color_command_formatter(init=\"\", gamut=WEBSPACE):     \"\"\"Return a Python command formatter with the provided imports.\"\"\"      return partial(_color_command_formatter, init=init, gamut=gamut)  <p>Pyodide specific code ############################</p> In\u00a0[\u00a0]: Copied! <pre>def _live_color_command_formatter(src, init=\"\", gamut=WEBSPACE):\n    \"\"\"Formatter wrapper.\"\"\"\n\n    try:\n        console = execute(src.strip(), False, init=init)\n        el = colorize(console, \"pycon\", **{\"python3\": True, \"stripnl\": False})\n        el = '&lt;div class=\"color-command\"&gt;{}&lt;/div&gt;'.format(el)\n    except Exception:\n        import traceback\n\n        return (\n            '&lt;div class=\"color-command\"&gt;&lt;div class=\"swatch-bar\"&gt;&lt;/div&gt;{}&lt;/div&gt;'.format(\n                colorize(traceback.format_exc(), \"pycon\")\n            )\n        )\n    return el\n\n\ndef live_color_command_formatter(init=\"\", gamut=WEBSPACE):\n    \"\"\"Return a Python command formatter with the provided imports.\"\"\"\n\n    return partial(_live_color_command_formatter, init=init, gamut=gamut)\n\n\ndef live_color_command_validator(language, inputs, options, attrs, md):\n    \"\"\"Color validator.\"\"\"\n\n    value = color_command_validator(language, inputs, options, attrs, md)\n    # Live edit, we always allow exceptions so not to crash the service.\n    options[\"exceptions\"] = True\n    return value\n</pre> def _live_color_command_formatter(src, init=\"\", gamut=WEBSPACE):     \"\"\"Formatter wrapper.\"\"\"      try:         console = execute(src.strip(), False, init=init)         el = colorize(console, \"pycon\", **{\"python3\": True, \"stripnl\": False})         el = '{}'.format(el)     except Exception:         import traceback          return (             '{}'.format(                 colorize(traceback.format_exc(), \"pycon\")             )         )     return el   def live_color_command_formatter(init=\"\", gamut=WEBSPACE):     \"\"\"Return a Python command formatter with the provided imports.\"\"\"      return partial(_live_color_command_formatter, init=init, gamut=gamut)   def live_color_command_validator(language, inputs, options, attrs, md):     \"\"\"Color validator.\"\"\"      value = color_command_validator(language, inputs, options, attrs, md)     # Live edit, we always allow exceptions so not to crash the service.     options[\"exceptions\"] = True     return value"},{"location":"_static/playground_whl/","title":"Playground whl","text":"In\u00a0[\u00a0]: Copied! <pre>import os\n</pre> import os In\u00a0[\u00a0]: Copied! <pre>import requests\n</pre> import requests In\u00a0[\u00a0]: Copied! <pre># Parameters\nOUTPUT_JS = \"docs/_static/\"\nPLAYGROUND_WHEELS = [\n    \"https://files.pythonhosted.org/packages/97/9c/372fef8377a6e340b1704768d20daaded98bf13282b5327beb2e2fe2c7ef/pygments-2.17.2-py3-none-any.whl\",\n]\nPACKAGES = [\"bigtree\"]\n</pre> # Parameters OUTPUT_JS = \"docs/_static/\" PLAYGROUND_WHEELS = [     \"https://files.pythonhosted.org/packages/97/9c/372fef8377a6e340b1704768d20daaded98bf13282b5327beb2e2fe2c7ef/pygments-2.17.2-py3-none-any.whl\", ] PACKAGES = [\"bigtree\"] In\u00a0[\u00a0]: Copied! <pre>DEFAULT_COMMANDS = [\"\"]\nCONFIG = \"\"\"\\\nvar colorNotebook = {{\n    \"playgroundWheels\": {},\n    \"notebookWheels\": [],\n    \"defaultPlayground\": \"{}\"\n}}\n\"\"\"\n</pre> DEFAULT_COMMANDS = [\"\"] CONFIG = \"\"\"\\ var colorNotebook = {{     \"playgroundWheels\": {},     \"notebookWheels\": [],     \"defaultPlayground\": \"{}\" }} \"\"\" In\u00a0[\u00a0]: Copied! <pre>if __name__ == \"__main__\":\n\n    if os.path.exists(OUTPUT_JS + \"playground-config.js\"):\n        os.remove(OUTPUT_JS + \"playground-config.js\")\n\n    # Scrape whl file\n    PACKAGE_WHEELS = []\n    for package in PACKAGES:\n        response = requests.get(f\"https://pypi.org/pypi/{package}/json\")\n        package_wheel = [\n            url[\"url\"] for url in response.json()[\"urls\"] if url[\"url\"].endswith(\"whl\")\n        ]\n        if len(package_wheel) &gt; 1:\n            package_wheel = sorted([url for url in package_wheel if \"macos\" in url])[\n                -1:\n            ]\n        PACKAGE_WHEELS.extend(package_wheel)\n    print(\"Fetched whls:\", PACKAGE_WHEELS)\n\n    # Create the config that specifies which wheels need to be used\n    config = (\n        CONFIG.format(\n            str(PLAYGROUND_WHEELS + PACKAGE_WHEELS), \"\\n\".join(DEFAULT_COMMANDS)\n        )\n        .replace(\"\\r\", \"\")\n        .encode(\"utf-8\")\n    )\n    with open(OUTPUT_JS + \"playground-config.js\", \"wb\") as f:\n        f.write(config)\n</pre> if __name__ == \"__main__\":      if os.path.exists(OUTPUT_JS + \"playground-config.js\"):         os.remove(OUTPUT_JS + \"playground-config.js\")      # Scrape whl file     PACKAGE_WHEELS = []     for package in PACKAGES:         response = requests.get(f\"https://pypi.org/pypi/{package}/json\")         package_wheel = [             url[\"url\"] for url in response.json()[\"urls\"] if url[\"url\"].endswith(\"whl\")         ]         if len(package_wheel) &gt; 1:             package_wheel = sorted([url for url in package_wheel if \"macos\" in url])[                 -1:             ]         PACKAGE_WHEELS.extend(package_wheel)     print(\"Fetched whls:\", PACKAGE_WHEELS)      # Create the config that specifies which wheels need to be used     config = (         CONFIG.format(             str(PLAYGROUND_WHEELS + PACKAGE_WHEELS), \"\\n\".join(DEFAULT_COMMANDS)         )         .replace(\"\\r\", \"\")         .encode(\"utf-8\")     )     with open(OUTPUT_JS + \"playground-config.js\", \"wb\") as f:         f.write(config)"},{"location":"bigtree/binarytree/construct/","title":"\u2728 Construct","text":"<p>Construct Binary Tree from a list.</p>"},{"location":"bigtree/binarytree/construct/#binary-tree-construct-methods","title":"Binary Tree Construct Methods","text":"Construct Binary Tree from Using heapq structure Add node attributes List <code>list_to_binarytree</code> No"},{"location":"bigtree/binarytree/construct/#bigtree.binarytree.construct","title":"bigtree.binarytree.construct","text":""},{"location":"bigtree/binarytree/construct/#bigtree.binarytree.construct.list_to_binarytree","title":"list_to_binarytree","text":"<pre><code>list_to_binarytree(heapq_list, node_type=BinaryNode)\n</code></pre> <p>Construct tree from a list of numbers (int or float) in heapq format.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import list_to_binarytree, tree_to_dot\n&gt;&gt;&gt; nums_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n&gt;&gt;&gt; root = list_to_binarytree(nums_list)\n&gt;&gt;&gt; root.show()\n1\n\u251c\u2500\u2500 2\n\u2502   \u251c\u2500\u2500 4\n\u2502   \u2502   \u251c\u2500\u2500 8\n\u2502   \u2502   \u2514\u2500\u2500 9\n\u2502   \u2514\u2500\u2500 5\n\u2502       \u2514\u2500\u2500 10\n\u2514\u2500\u2500 3\n    \u251c\u2500\u2500 6\n    \u2514\u2500\u2500 7\n&gt;&gt;&gt; graph = tree_to_dot(root, node_colour=\"gold\")\n&gt;&gt;&gt; graph.write_png(\"assets/construct_binarytree.png\")\n</code></pre> <p></p> <p>Parameters:</p> Name Type Description Default <code>heapq_list</code> <code>List[int]</code> <p>list containing integer node names, ordered in heapq fashion</p> required <code>node_type</code> <code>Type[T]</code> <p>node type of tree to be created</p> <code>BinaryNode</code> <p>Returns:</p> Type Description <code>T</code> <p>Binary node</p>"},{"location":"bigtree/dag/construct/","title":"\u2728 Construct","text":"<p>Construct Directed Acyclic Graph (DAG) from list, dictionary, and pandas DataFrame.</p>"},{"location":"bigtree/dag/construct/#dag-construct-methods","title":"DAG Construct Methods","text":"Construct DAG from Using parent-child relation Add node attributes List <code>list_to_dag</code> No Dictionary <code>dict_to_dag</code> Yes DataFrame <code>dataframe_to_dag</code> Yes"},{"location":"bigtree/dag/construct/#bigtree.dag.construct","title":"bigtree.dag.construct","text":""},{"location":"bigtree/dag/construct/#bigtree.dag.construct.list_to_dag","title":"list_to_dag","text":"<pre><code>list_to_dag(relations, node_type=DAGNode)\n</code></pre> <p>Construct DAG from list of tuples containing parent-child names. Note that node names must be unique.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import list_to_dag, dag_iterator\n&gt;&gt;&gt; relations_list = [(\"a\", \"c\"), (\"a\", \"d\"), (\"b\", \"c\"), (\"c\", \"d\"), (\"d\", \"e\")]\n&gt;&gt;&gt; dag = list_to_dag(relations_list)\n&gt;&gt;&gt; [(parent.node_name, child.node_name) for parent, child in dag_iterator(dag)]\n[('a', 'd'), ('c', 'd'), ('d', 'e'), ('a', 'c'), ('b', 'c')]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>relations</code> <code>List[Tuple[str, str]]</code> <p>list containing tuple of parent-child names</p> required <code>node_type</code> <code>Type[T]</code> <p>node type of DAG to be created</p> <code>DAGNode</code> <p>Returns:</p> Type Description <code>T</code> <p>DAG node</p>"},{"location":"bigtree/dag/construct/#bigtree.dag.construct.dict_to_dag","title":"dict_to_dag","text":"<pre><code>dict_to_dag(\n    relation_attrs, parent_key=\"parents\", node_type=DAGNode\n)\n</code></pre> <p>Construct DAG from nested dictionary, <code>key</code>: child name, <code>value</code>: dictionary of parent names and attributes. Note that node names must be unique.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import dict_to_dag, dag_iterator\n&gt;&gt;&gt; relation_dict = {\n...     \"a\": {\"step\": 1},\n...     \"b\": {\"step\": 1},\n...     \"c\": {\"parents\": [\"a\", \"b\"], \"step\": 2},\n...     \"d\": {\"parents\": [\"a\", \"c\"], \"step\": 2},\n...     \"e\": {\"parents\": [\"d\"], \"step\": 3},\n... }\n&gt;&gt;&gt; dag = dict_to_dag(relation_dict, parent_key=\"parents\")\n&gt;&gt;&gt; [(parent.node_name, child.node_name) for parent, child in dag_iterator(dag)]\n[('a', 'd'), ('c', 'd'), ('d', 'e'), ('a', 'c'), ('b', 'c')]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>relation_attrs</code> <code>Dict[str, Any]</code> <p>dictionary containing node, node parents, and node attribute information, key: child name, value: dictionary of parent names and attributes</p> required <code>parent_key</code> <code>str</code> <p>key of dictionary to retrieve list of parents name</p> <code>'parents'</code> <code>node_type</code> <code>Type[T]</code> <p>node type of DAG to be created</p> <code>DAGNode</code> <p>Returns:</p> Type Description <code>T</code> <p>DAG node</p>"},{"location":"bigtree/dag/construct/#bigtree.dag.construct.dataframe_to_dag","title":"dataframe_to_dag","text":"<pre><code>dataframe_to_dag(\n    data,\n    child_col=\"\",\n    parent_col=\"\",\n    attribute_cols=[],\n    node_type=DAGNode,\n)\n</code></pre> <p>Construct DAG from pandas DataFrame. Note that node names must be unique.</p> <ul> <li><code>child_col</code> and <code>parent_col</code> specify columns for child name and parent name to construct DAG.</li> <li><code>attribute_cols</code> specify columns for node attribute for child name.</li> <li>If columns are not specified, <code>child_col</code> takes first column, <code>parent_col</code> takes second column, and all other     columns are <code>attribute_cols</code>.</li> </ul> <p>Only attributes in <code>attribute_cols</code> with non-null values will be added to the tree.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from bigtree import dataframe_to_dag, dag_iterator\n&gt;&gt;&gt; relation_data = pd.DataFrame([\n...     [\"a\", None, 1],\n...     [\"b\", None, 1],\n...     [\"c\", \"a\", 2],\n...     [\"c\", \"b\", 2],\n...     [\"d\", \"a\", 2],\n...     [\"d\", \"c\", 2],\n...     [\"e\", \"d\", 3],\n... ],\n...     columns=[\"child\", \"parent\", \"step\"]\n... )\n&gt;&gt;&gt; dag = dataframe_to_dag(relation_data)\n&gt;&gt;&gt; [(parent.node_name, child.node_name) for parent, child in dag_iterator(dag)]\n[('a', 'd'), ('c', 'd'), ('d', 'e'), ('a', 'c'), ('b', 'c')]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>data containing path and node attribute information</p> required <code>child_col</code> <code>str</code> <p>column of data containing child name information, if not set, it will take the first column of data</p> <code>''</code> <code>parent_col</code> <code>str</code> <p>column of data containing parent name information, if not set, it will take the second column of data</p> <code>''</code> <code>attribute_cols</code> <code>List[str]</code> <p>columns of data containing child node attribute information, if not set, it will take all columns of data except <code>child_col</code> and <code>parent_col</code></p> <code>[]</code> <code>node_type</code> <code>Type[T]</code> <p>node type of DAG to be created</p> <code>DAGNode</code> <p>Returns:</p> Type Description <code>T</code> <p>DAG node</p>"},{"location":"bigtree/dag/export/","title":"\ud83d\udd28 Export","text":"<p>Export Directed Acyclic Graph (DAG) to list, dictionary, and pandas DataFrame.</p>"},{"location":"bigtree/dag/export/#dag-export-methods","title":"DAG Export Methods","text":"Export DAG to Method Extract node attributes List <code>dag_to_list</code> No Dictionary <code>dag_to_dict</code> Yes with <code>attr_dict</code> or <code>all_attrs</code> DataFrame <code>dag_to_dataframe</code> Yes with <code>attr_dict</code> or <code>all_attrs</code> Dot (for .dot, .png, .svg, .jpeg, etc.) <code>dag_to_dot</code> No"},{"location":"bigtree/dag/export/#bigtree.dag.export","title":"bigtree.dag.export","text":""},{"location":"bigtree/dag/export/#bigtree.dag.export.dag_to_list","title":"dag_to_list","text":"<pre><code>dag_to_list(dag)\n</code></pre> <p>Export DAG to list of tuples containing parent-child names.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import DAGNode, dag_to_list\n&gt;&gt;&gt; a = DAGNode(\"a\", step=1)\n&gt;&gt;&gt; b = DAGNode(\"b\", step=1)\n&gt;&gt;&gt; c = DAGNode(\"c\", step=2, parents=[a, b])\n&gt;&gt;&gt; d = DAGNode(\"d\", step=2, parents=[a, c])\n&gt;&gt;&gt; e = DAGNode(\"e\", step=3, parents=[d])\n&gt;&gt;&gt; dag_to_list(a)\n[('a', 'c'), ('a', 'd'), ('b', 'c'), ('c', 'd'), ('d', 'e')]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>dag</code> <code>T</code> <p>DAG to be exported</p> required <p>Returns:</p> Type Description <code>List[Tuple[str, str]]</code> <p>List of tuples containing parent-child names</p>"},{"location":"bigtree/dag/export/#bigtree.dag.export.dag_to_dict","title":"dag_to_dict","text":"<pre><code>dag_to_dict(\n    dag, parent_key=\"parents\", attr_dict={}, all_attrs=False\n)\n</code></pre> <p>Export DAG to dictionary. Exported dictionary will have key as child name, and values as a dictionary of parent names and node attributes.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import DAGNode, dag_to_dict\n&gt;&gt;&gt; a = DAGNode(\"a\", step=1)\n&gt;&gt;&gt; b = DAGNode(\"b\", step=1)\n&gt;&gt;&gt; c = DAGNode(\"c\", step=2, parents=[a, b])\n&gt;&gt;&gt; d = DAGNode(\"d\", step=2, parents=[a, c])\n&gt;&gt;&gt; e = DAGNode(\"e\", step=3, parents=[d])\n&gt;&gt;&gt; dag_to_dict(a, parent_key=\"parent\", attr_dict={\"step\": \"step no.\"})\n{'a': {'step no.': 1}, 'c': {'parent': ['a', 'b'], 'step no.': 2}, 'd': {'parent': ['a', 'c'], 'step no.': 2}, 'b': {'step no.': 1}, 'e': {'parent': ['d'], 'step no.': 3}}\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>dag</code> <code>T</code> <p>DAG to be exported</p> required <code>parent_key</code> <code>str</code> <p>dictionary key for <code>node.parent.node_name</code></p> <code>'parents'</code> <code>attr_dict</code> <code>Dict[str, str]</code> <p>dictionary mapping node attributes to dictionary key, key: node attributes, value: corresponding dictionary key</p> <code>{}</code> <code>all_attrs</code> <code>bool</code> <p>indicator whether to retrieve all <code>Node</code> attributes</p> <code>False</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary of node names to their attributes</p>"},{"location":"bigtree/dag/export/#bigtree.dag.export.dag_to_dataframe","title":"dag_to_dataframe","text":"<pre><code>dag_to_dataframe(\n    dag,\n    name_col=\"name\",\n    parent_col=\"parent\",\n    attr_dict={},\n    all_attrs=False,\n)\n</code></pre> <p>Export DAG to pandas DataFrame.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import DAGNode, dag_to_dataframe\n&gt;&gt;&gt; a = DAGNode(\"a\", step=1)\n&gt;&gt;&gt; b = DAGNode(\"b\", step=1)\n&gt;&gt;&gt; c = DAGNode(\"c\", step=2, parents=[a, b])\n&gt;&gt;&gt; d = DAGNode(\"d\", step=2, parents=[a, c])\n&gt;&gt;&gt; e = DAGNode(\"e\", step=3, parents=[d])\n&gt;&gt;&gt; dag_to_dataframe(a, name_col=\"name\", parent_col=\"parent\", attr_dict={\"step\": \"step no.\"})\n  name parent  step no.\n0    a   None         1\n1    c      a         2\n2    d      a         2\n3    b   None         1\n4    c      b         2\n5    d      c         2\n6    e      d         3\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>dag</code> <code>T</code> <p>DAG to be exported</p> required <code>name_col</code> <code>str</code> <p>column name for <code>node.node_name</code></p> <code>'name'</code> <code>parent_col</code> <code>str</code> <p>column name for <code>node.parent.node_name</code></p> <code>'parent'</code> <code>attr_dict</code> <code>Dict[str, str]</code> <p>dictionary mapping node attributes to column name, key: node attributes, value: corresponding column in dataframe</p> <code>{}</code> <code>all_attrs</code> <code>bool</code> <p>indicator whether to retrieve all <code>Node</code> attributes</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pandas DataFrame of DAG information</p>"},{"location":"bigtree/dag/export/#bigtree.dag.export.dag_to_dot","title":"dag_to_dot","text":"<pre><code>dag_to_dot(\n    dag,\n    rankdir=\"TB\",\n    bg_colour=\"\",\n    node_colour=\"\",\n    node_shape=\"\",\n    edge_colour=\"\",\n    node_attr=\"\",\n    edge_attr=\"\",\n)\n</code></pre> <p>Export DAG or list of DAGs to image. Note that node names must be unique. Possible node attributes include style, fillcolor, or shape.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import DAGNode, dag_to_dot\n&gt;&gt;&gt; a = DAGNode(\"a\", step=1)\n&gt;&gt;&gt; b = DAGNode(\"b\", step=1)\n&gt;&gt;&gt; c = DAGNode(\"c\", step=2, parents=[a, b])\n&gt;&gt;&gt; d = DAGNode(\"d\", step=2, parents=[a, c])\n&gt;&gt;&gt; e = DAGNode(\"e\", step=3, parents=[d])\n&gt;&gt;&gt; dag_graph = dag_to_dot(a)\n</code></pre> <p>Display image directly without saving (requires IPython)</p> <pre><code>&gt;&gt;&gt; from IPython.display import Image, display\n&gt;&gt;&gt; plt = Image(dag_graph.create_png())\n&gt;&gt;&gt; display(plt)\n&lt;IPython.core.display.Image object&gt;\n</code></pre> <p>Export to image, dot file, etc.</p> <pre><code>&gt;&gt;&gt; dag_graph.write_png(\"assets/tree_dag.png\")\n&gt;&gt;&gt; dag_graph.write_dot(\"assets/tree_dag.dot\")\n</code></pre> <p></p> <p>Export to string</p> <pre><code>&gt;&gt;&gt; dag_graph.to_string()\n'strict digraph G {\\nrankdir=TB;\\nc [label=c];\\na [label=a];\\na -&gt; c;\\nd [label=d];\\na [label=a];\\na -&gt; d;\\nc [label=c];\\nb [label=b];\\nb -&gt; c;\\nd [label=d];\\nc [label=c];\\nc -&gt; d;\\ne [label=e];\\nd [label=d];\\nd -&gt; e;\\n}\\n'\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>dag</code> <code>Union[T, List[T]]</code> <p>DAG or list of DAGs to be exported</p> required <code>rankdir</code> <code>str</code> <p>set direction of graph layout, accepts 'TB', 'BT, 'LR', or 'RL'</p> <code>'TB'</code> <code>bg_colour</code> <code>str</code> <p>background color of image</p> <code>''</code> <code>node_colour</code> <code>str</code> <p>fill colour of nodes</p> <code>''</code> <code>node_shape</code> <code>str</code> <p>shape of nodes. Possible node_shape include \"circle\", \"square\", \"diamond\", \"triangle\"</p> <code>''</code> <code>edge_colour</code> <code>str</code> <p>colour of edges</p> <code>''</code> <code>node_attr</code> <code>str</code> <p>node attribute for style, overrides node_colour. Possible node attributes include {\"style\": \"filled\", \"fillcolor\": \"gold\"}</p> <code>''</code> <code>edge_attr</code> <code>str</code> <p>edge attribute for style, overrides edge_colour. Possible edge attributes include {\"style\": \"bold\", \"label\": \"edge label\", \"color\": \"black\"}</p> <code>''</code> <p>Returns:</p> Type Description <code>Dot</code> <p>pydot object of DAG</p>"},{"location":"bigtree/node/basenode/","title":"\ud83c\udf31 BaseNode","text":""},{"location":"bigtree/node/basenode/#bigtree.node.basenode","title":"bigtree.node.basenode","text":""},{"location":"bigtree/node/basenode/#bigtree.node.basenode.BaseNode","title":"BaseNode","text":"<pre><code>BaseNode(parent=None, children=None, **kwargs)\n</code></pre> <p>BaseNode extends any Python class to a tree node. Nodes can have attributes if they are initialized from <code>Node</code>, dictionary, or pandas DataFrame.</p> <p>Nodes can be linked to each other with <code>parent</code> and <code>children</code> setter methods, or using bitshift operator with the convention <code>parent_node &gt;&gt; child_node</code> or <code>child_node &lt;&lt; parent_node</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, print_tree\n&gt;&gt;&gt; root = Node(\"a\", age=90)\n&gt;&gt;&gt; b = Node(\"b\", age=65)\n&gt;&gt;&gt; c = Node(\"c\", age=60)\n&gt;&gt;&gt; d = Node(\"d\", age=40)\n&gt;&gt;&gt; root.children = [b, c]\n&gt;&gt;&gt; d.parent = b\n&gt;&gt;&gt; print_tree(root, attr_list=[\"age\"])\na [age=90]\n\u251c\u2500\u2500 b [age=65]\n\u2502   \u2514\u2500\u2500 d [age=40]\n\u2514\u2500\u2500 c [age=60]\n</code></pre> <pre><code>&gt;&gt;&gt; from bigtree import Node\n&gt;&gt;&gt; root = Node(\"a\", age=90)\n&gt;&gt;&gt; b = Node(\"b\", age=65)\n&gt;&gt;&gt; c = Node(\"c\", age=60)\n&gt;&gt;&gt; d = Node(\"d\", age=40)\n&gt;&gt;&gt; root &gt;&gt; b\n&gt;&gt;&gt; root &gt;&gt; c\n&gt;&gt;&gt; d &lt;&lt; b\n&gt;&gt;&gt; print_tree(root, attr_list=[\"age\"])\na [age=90]\n\u251c\u2500\u2500 b [age=65]\n\u2502   \u2514\u2500\u2500 d [age=40]\n\u2514\u2500\u2500 c [age=60]\n</code></pre> <p>Directly passing <code>parent</code> argument.</p> <pre><code>&gt;&gt;&gt; from bigtree import Node\n&gt;&gt;&gt; root = Node(\"a\")\n&gt;&gt;&gt; b = Node(\"b\", parent=root)\n&gt;&gt;&gt; c = Node(\"c\", parent=root)\n&gt;&gt;&gt; d = Node(\"d\", parent=b)\n</code></pre> <p>Directly passing <code>children</code> argument.</p> <pre><code>&gt;&gt;&gt; from bigtree import Node\n&gt;&gt;&gt; d = Node(\"d\")\n&gt;&gt;&gt; c = Node(\"c\")\n&gt;&gt;&gt; b = Node(\"b\", children=[d])\n&gt;&gt;&gt; a = Node(\"a\", children=[b, c])\n</code></pre> <p>BaseNode Creation</p> <p>Node can be created by instantiating a <code>BaseNode</code> class or by using a dictionary. If node is created with dictionary, all keys of dictionary will be stored as class attributes.</p> <pre><code>&gt;&gt;&gt; from bigtree import Node\n&gt;&gt;&gt; root = Node.from_dict({\"name\": \"a\", \"age\": 90})\n</code></pre> <p>BaseNode Attributes</p> <p>These are node attributes that have getter and/or setter methods.</p> <p>Get and set other <code>BaseNode</code></p> <ol> <li><code>parent</code>: Get/set parent node</li> <li><code>children</code>: Get/set child nodes</li> </ol> <p>Get other <code>BaseNode</code></p> <ol> <li><code>ancestors</code>: Get ancestors of node excluding self, iterator</li> <li><code>descendants</code>: Get descendants of node excluding self, iterator</li> <li><code>leaves</code>: Get all leaf node(s) from self, iterator</li> <li><code>siblings</code>: Get siblings of self</li> <li><code>left_sibling</code>: Get sibling left of self</li> <li><code>right_sibling</code>: Get sibling right of self</li> </ol> <p>Get <code>BaseNode</code> configuration</p> <ol> <li><code>node_path</code>: Get tuple of nodes from root</li> <li><code>is_root</code>: Get indicator if self is root node</li> <li><code>is_leaf</code>: Get indicator if self is leaf node</li> <li><code>root</code>: Get root node of tree</li> <li><code>diameter</code>: Get diameter of self</li> <li><code>depth</code>: Get depth of self</li> <li><code>max_depth</code>: Get maximum depth from root to leaf node</li> </ol> <p>BaseNode Methods</p> <p>These are methods available to be performed on <code>BaseNode</code>.</p> <p>Constructor methods</p> <ol> <li><code>from_dict()</code>: Create BaseNode from dictionary</li> </ol> <p><code>BaseNode</code> methods</p> <ol> <li><code>describe()</code>: Get node information sorted by attributes, return list of tuples</li> <li><code>get_attr(attr_name: str)</code>: Get value of node attribute</li> <li><code>set_attrs(attrs: dict)</code>: Set node attribute name(s) and value(s)</li> <li><code>go_to(node: Self)</code>: Get a path from own node to another node from same tree</li> <li><code>append(node: Self)</code>: Add child to node</li> <li><code>extend(nodes: List[Self])</code>: Add multiple children to node</li> <li><code>copy()</code>: Deep copy self</li> <li><code>sort()</code>: Sort child nodes</li> <li><code>plot()</code>: Plot tree in line form</li> </ol>"},{"location":"bigtree/node/basenode/#bigtree.node.basenode.BaseNode.parent","title":"parent  <code>property</code> <code>writable</code>","text":"<pre><code>parent\n</code></pre> <p>Get parent node.</p> <p>Returns:</p> Type Description <code>Optional[T]</code> <p>Parent node, none if the node is root</p>"},{"location":"bigtree/node/basenode/#bigtree.node.basenode.BaseNode.parents","title":"parents  <code>property</code> <code>writable</code>","text":"<pre><code>parents\n</code></pre> <p>Do not allow <code>parents</code> attribute to be accessed.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>No such attribute</p>"},{"location":"bigtree/node/basenode/#bigtree.node.basenode.BaseNode.children","title":"children  <code>deletable</code> <code>property</code> <code>writable</code>","text":"<pre><code>children\n</code></pre> <p>Get child nodes.</p> <p>Returns:</p> Type Description <code>Tuple[T, ...]</code> <p>Child node(s)</p>"},{"location":"bigtree/node/basenode/#bigtree.node.basenode.BaseNode.ancestors","title":"ancestors  <code>property</code>","text":"<pre><code>ancestors\n</code></pre> <p>Get iterator to yield all ancestors of self, does not include self.</p> <p>Returns:</p> Type Description <code>Iterable[T]</code> <p>Ancestor(s) of node excluding itself</p>"},{"location":"bigtree/node/basenode/#bigtree.node.basenode.BaseNode.descendants","title":"descendants  <code>property</code>","text":"<pre><code>descendants\n</code></pre> <p>Get iterator to yield all descendants of self, does not include self.</p> <p>Returns:</p> Type Description <code>Iterable[T]</code> <p>Descendant(s) of node excluding itself</p>"},{"location":"bigtree/node/basenode/#bigtree.node.basenode.BaseNode.leaves","title":"leaves  <code>property</code>","text":"<pre><code>leaves\n</code></pre> <p>Get iterator to yield all leaf nodes from self.</p> <p>Returns:</p> Type Description <code>Iterable[T]</code> <p>Leaf node(s) of node</p>"},{"location":"bigtree/node/basenode/#bigtree.node.basenode.BaseNode.siblings","title":"siblings  <code>property</code>","text":"<pre><code>siblings\n</code></pre> <p>Get siblings of self.</p> <p>Returns:</p> Type Description <code>Iterable[T]</code> <p>Sibling(s) of node</p>"},{"location":"bigtree/node/basenode/#bigtree.node.basenode.BaseNode.left_sibling","title":"left_sibling  <code>property</code>","text":"<pre><code>left_sibling\n</code></pre> <p>Get sibling left of self.</p> <p>Returns:</p> Type Description <code>Optional[T]</code> <p>Left sibling of node</p>"},{"location":"bigtree/node/basenode/#bigtree.node.basenode.BaseNode.right_sibling","title":"right_sibling  <code>property</code>","text":"<pre><code>right_sibling\n</code></pre> <p>Get sibling right of self.</p> <p>Returns:</p> Type Description <code>Optional[T]</code> <p>Right sibling of node</p>"},{"location":"bigtree/node/basenode/#bigtree.node.basenode.BaseNode.node_path","title":"node_path  <code>property</code>","text":"<pre><code>node_path\n</code></pre> <p>Get tuple of nodes starting from root.</p> <p>Returns:</p> Type Description <code>Iterable[T]</code> <p>Node path from root to itself</p>"},{"location":"bigtree/node/basenode/#bigtree.node.basenode.BaseNode.is_root","title":"is_root  <code>property</code>","text":"<pre><code>is_root\n</code></pre> <p>Get indicator if self is root node.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Indicator if node is root node</p>"},{"location":"bigtree/node/basenode/#bigtree.node.basenode.BaseNode.is_leaf","title":"is_leaf  <code>property</code>","text":"<pre><code>is_leaf\n</code></pre> <p>Get indicator if self is leaf node.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Indicator if node is leaf node</p>"},{"location":"bigtree/node/basenode/#bigtree.node.basenode.BaseNode.root","title":"root  <code>property</code>","text":"<pre><code>root\n</code></pre> <p>Get root node of tree.</p> <p>Returns:</p> Type Description <code>T</code> <p>Root node</p>"},{"location":"bigtree/node/basenode/#bigtree.node.basenode.BaseNode.diameter","title":"diameter  <code>property</code>","text":"<pre><code>diameter\n</code></pre> <p>Get diameter of tree or subtree, the length of longest path between any two nodes.</p> <p>Returns:</p> Type Description <code>int</code> <p>Diameter of node</p>"},{"location":"bigtree/node/basenode/#bigtree.node.basenode.BaseNode.depth","title":"depth  <code>property</code>","text":"<pre><code>depth\n</code></pre> <p>Get depth of self, indexing starts from 1.</p> <p>Returns:</p> Type Description <code>int</code> <p>Depth of node</p>"},{"location":"bigtree/node/basenode/#bigtree.node.basenode.BaseNode.max_depth","title":"max_depth  <code>property</code>","text":"<pre><code>max_depth\n</code></pre> <p>Get maximum depth from root to leaf node.</p> <p>Returns:</p> Type Description <code>int</code> <p>Maximum depth of tree</p>"},{"location":"bigtree/node/basenode/#bigtree.node.basenode.BaseNode.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(input_dict)\n</code></pre> <p>Construct node from dictionary, all keys of dictionary will be stored as class attributes. Input dictionary must have key <code>name</code> if not <code>Node</code> will not have any name.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node\n&gt;&gt;&gt; a = Node.from_dict({\"name\": \"a\", \"age\": 90})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>input_dict</code> <code>Dict[str, Any]</code> <p>dictionary with node information, key: attribute name, value: attribute value</p> required <p>Returns:</p> Type Description <code>BaseNode</code> <p>Base node</p>"},{"location":"bigtree/node/basenode/#bigtree.node.basenode.BaseNode.describe","title":"describe","text":"<pre><code>describe(exclude_attributes=[], exclude_prefix='')\n</code></pre> <p>Get node information sorted by attribute name, returns list of tuples.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree.node.node import Node\n&gt;&gt;&gt; a = Node('a', age=90)\n&gt;&gt;&gt; a.describe()\n[('_BaseNode__children', []), ('_BaseNode__parent', None), ('_sep', '/'), ('age', 90), ('name', 'a')]\n&gt;&gt;&gt; a.describe(exclude_prefix=\"_\")\n[('age', 90), ('name', 'a')]\n&gt;&gt;&gt; a.describe(exclude_prefix=\"_\", exclude_attributes=[\"name\"])\n[('age', 90)]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>exclude_attributes</code> <code>List[str]</code> <p>list of attributes to exclude</p> <code>[]</code> <code>exclude_prefix</code> <code>str</code> <p>prefix of attributes to exclude</p> <code>''</code> <p>Returns:</p> Type Description <code>List[Tuple[str, Any]]</code> <p>List of attribute name and attribute value pairs</p>"},{"location":"bigtree/node/basenode/#bigtree.node.basenode.BaseNode.get_attr","title":"get_attr","text":"<pre><code>get_attr(attr_name, default_value=None)\n</code></pre> <p>Get value of node attribute. Returns default value if attribute name does not exist.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree.node.node import Node\n&gt;&gt;&gt; a = Node('a', age=90)\n&gt;&gt;&gt; a.get_attr(\"age\")\n90\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>attr_name</code> <code>str</code> <p>attribute name</p> required <code>default_value</code> <code>Any</code> <p>default value if attribute does not exist</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>Attribute value of node</p>"},{"location":"bigtree/node/basenode/#bigtree.node.basenode.BaseNode.set_attrs","title":"set_attrs","text":"<pre><code>set_attrs(attrs)\n</code></pre> <p>Set node attributes.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree.node.node import Node\n&gt;&gt;&gt; a = Node('a')\n&gt;&gt;&gt; a.set_attrs({\"age\": 90})\n&gt;&gt;&gt; a\nNode(/a, age=90)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>attrs</code> <code>Dict[str, Any]</code> <p>attribute dictionary, key: attribute name, value: attribute value</p> required"},{"location":"bigtree/node/basenode/#bigtree.node.basenode.BaseNode.go_to","title":"go_to","text":"<pre><code>go_to(node)\n</code></pre> <p>Get path from current node to specified node from same tree.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, print_tree\n&gt;&gt;&gt; a = Node(name=\"a\")\n&gt;&gt;&gt; b = Node(name=\"b\", parent=a)\n&gt;&gt;&gt; c = Node(name=\"c\", parent=a)\n&gt;&gt;&gt; d = Node(name=\"d\", parent=b)\n&gt;&gt;&gt; e = Node(name=\"e\", parent=b)\n&gt;&gt;&gt; f = Node(name=\"f\", parent=c)\n&gt;&gt;&gt; g = Node(name=\"g\", parent=e)\n&gt;&gt;&gt; h = Node(name=\"h\", parent=e)\n&gt;&gt;&gt; print_tree(a)\na\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 d\n\u2502   \u2514\u2500\u2500 e\n\u2502       \u251c\u2500\u2500 g\n\u2502       \u2514\u2500\u2500 h\n\u2514\u2500\u2500 c\n    \u2514\u2500\u2500 f\n&gt;&gt;&gt; d.go_to(d)\n[Node(/a/b/d, )]\n&gt;&gt;&gt; d.go_to(g)\n[Node(/a/b/d, ), Node(/a/b, ), Node(/a/b/e, ), Node(/a/b/e/g, )]\n&gt;&gt;&gt; d.go_to(f)\n[Node(/a/b/d, ), Node(/a/b, ), Node(/a, ), Node(/a/c, ), Node(/a/c/f, )]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>T</code> <p>node to travel to from current node, inclusive of start and end node</p> required <p>Returns:</p> Type Description <code>Iterable[T]</code> <p>Path from current node to destination node</p>"},{"location":"bigtree/node/basenode/#bigtree.node.basenode.BaseNode.append","title":"append","text":"<pre><code>append(other)\n</code></pre> <p>Add other as child of self.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>T</code> <p>other node, child to be added</p> required"},{"location":"bigtree/node/basenode/#bigtree.node.basenode.BaseNode.extend","title":"extend","text":"<pre><code>extend(others)\n</code></pre> <p>Add others as children of self.</p> <p>Parameters:</p> Name Type Description Default <code>others</code> <code>List[T]</code> <p>other nodes, children to be added</p> required"},{"location":"bigtree/node/basenode/#bigtree.node.basenode.BaseNode.copy","title":"copy","text":"<pre><code>copy()\n</code></pre> <p>Deep copy self; clone self.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree.node.node import Node\n&gt;&gt;&gt; a = Node('a')\n&gt;&gt;&gt; a_copy = a.copy()\n</code></pre> <p>Returns:</p> Type Description <code>T</code> <p>Cloned copy of node</p>"},{"location":"bigtree/node/basenode/#bigtree.node.basenode.BaseNode.sort","title":"sort","text":"<pre><code>sort(**kwargs)\n</code></pre> <p>Sort children, possible keyword arguments include <code>key=lambda node: node.node_name</code>, <code>reverse=True</code>. Accepts kwargs for sort() function.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, print_tree\n&gt;&gt;&gt; a = Node('a')\n&gt;&gt;&gt; c = Node(\"c\", parent=a)\n&gt;&gt;&gt; b = Node(\"b\", parent=a)\n&gt;&gt;&gt; print_tree(a)\na\n\u251c\u2500\u2500 c\n\u2514\u2500\u2500 b\n&gt;&gt;&gt; a.sort(key=lambda node: node.node_name)\n&gt;&gt;&gt; print_tree(a)\na\n\u251c\u2500\u2500 b\n\u2514\u2500\u2500 c\n</code></pre>"},{"location":"bigtree/node/basenode/#bigtree.node.basenode.BaseNode.plot","title":"plot","text":"<pre><code>plot(*args, **kwargs)\n</code></pre> <p>Plot tree in line form. Accepts args and kwargs for matplotlib.pyplot.plot() function.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; from bigtree import list_to_tree\n&gt;&gt;&gt; path_list = [\"a/b/d\", \"a/b/e/g\", \"a/b/e/h\", \"a/c/f\"]\n&gt;&gt;&gt; root = list_to_tree(path_list)\n&gt;&gt;&gt; root.plot(\"-ok\")\n&lt;Figure size 1280x960 with 1 Axes&gt;\n</code></pre>"},{"location":"bigtree/node/binarynode/","title":"\ud83c\udf38 BinaryNode","text":""},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode","title":"bigtree.node.binarynode","text":""},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode","title":"BinaryNode","text":"<pre><code>BinaryNode(\n    name=\"\",\n    left=None,\n    right=None,\n    parent=None,\n    children=None,\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>Node</code></p> <p>BinaryNode is an extension of Node, and is able to extend to any Python class for Binary Tree implementation. Nodes can have attributes if they are initialized from <code>BinaryNode</code>, dictionary, or pandas DataFrame.</p> <p>BinaryNode can be linked to each other with <code>children</code>, <code>left</code>, or <code>right</code> setter methods. If initialized with <code>children</code>, it must be length 2, denoting left and right child.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import BinaryNode, print_tree\n&gt;&gt;&gt; a = BinaryNode(1)\n&gt;&gt;&gt; b = BinaryNode(2)\n&gt;&gt;&gt; c = BinaryNode(3)\n&gt;&gt;&gt; d = BinaryNode(4)\n&gt;&gt;&gt; a.children = [b, c]\n&gt;&gt;&gt; b.right = d\n&gt;&gt;&gt; print_tree(a)\n1\n\u251c\u2500\u2500 2\n\u2502   \u2514\u2500\u2500 4\n\u2514\u2500\u2500 3\n</code></pre> <p>Directly passing <code>left</code>, <code>right</code>, or <code>children</code> argument.</p> <pre><code>&gt;&gt;&gt; from bigtree import BinaryNode\n&gt;&gt;&gt; d = BinaryNode(4)\n&gt;&gt;&gt; c = BinaryNode(3)\n&gt;&gt;&gt; b = BinaryNode(2, right=d)\n&gt;&gt;&gt; a = BinaryNode(1, children=[b, c])\n</code></pre> <p>BinaryNode Creation</p> <p>Node can be created by instantiating a <code>BinaryNode</code> class or by using a dictionary. If node is created with dictionary, all keys of dictionary will be stored as class attributes.</p> <pre><code>&gt;&gt;&gt; from bigtree import BinaryNode\n&gt;&gt;&gt; a = BinaryNode.from_dict({\"name\": \"1\"})\n&gt;&gt;&gt; a\nBinaryNode(name=1, val=1)\n</code></pre> <p>BinaryNode Attributes</p> <p>These are node attributes that have getter and/or setter methods.</p> <p>Get <code>BinaryNode</code> configuration</p> <ol> <li><code>left</code>: Get left children</li> <li><code>right</code>: Get right children</li> </ol>"},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode.left","title":"left  <code>property</code> <code>writable</code>","text":"<pre><code>left\n</code></pre> <p>Get left children.</p> <p>Returns:</p> Type Description <code>T</code> <p>Left child</p>"},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode.right","title":"right  <code>property</code> <code>writable</code>","text":"<pre><code>right\n</code></pre> <p>Get right children.</p> <p>Returns:</p> Type Description <code>T</code> <p>Right child</p>"},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode.parent","title":"parent  <code>property</code> <code>writable</code>","text":"<pre><code>parent\n</code></pre> <p>Get parent node.</p> <p>Returns:</p> Type Description <code>Optional[T]</code> <p>Parent node, none if the node is root</p>"},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode.children","title":"children  <code>deletable</code> <code>property</code> <code>writable</code>","text":"<pre><code>children\n</code></pre> <p>Get child nodes.</p> <p>Returns:</p> Type Description <code>Tuple[T, ...]</code> <p>Child nodes</p>"},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode.is_leaf","title":"is_leaf  <code>property</code>","text":"<pre><code>is_leaf\n</code></pre> <p>Get indicator if self is leaf node.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Indicator if node is leaf node</p>"},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode.parents","title":"parents  <code>property</code> <code>writable</code>","text":"<pre><code>parents\n</code></pre> <p>Do not allow <code>parents</code> attribute to be accessed.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>No such attribute</p>"},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode.ancestors","title":"ancestors  <code>property</code>","text":"<pre><code>ancestors\n</code></pre> <p>Get iterator to yield all ancestors of self, does not include self.</p> <p>Returns:</p> Type Description <code>Iterable[T]</code> <p>Ancestor(s) of node excluding itself</p>"},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode.descendants","title":"descendants  <code>property</code>","text":"<pre><code>descendants\n</code></pre> <p>Get iterator to yield all descendants of self, does not include self.</p> <p>Returns:</p> Type Description <code>Iterable[T]</code> <p>Descendant(s) of node excluding itself</p>"},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode.leaves","title":"leaves  <code>property</code>","text":"<pre><code>leaves\n</code></pre> <p>Get iterator to yield all leaf nodes from self.</p> <p>Returns:</p> Type Description <code>Iterable[T]</code> <p>Leaf node(s) of node</p>"},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode.siblings","title":"siblings  <code>property</code>","text":"<pre><code>siblings\n</code></pre> <p>Get siblings of self.</p> <p>Returns:</p> Type Description <code>Iterable[T]</code> <p>Sibling(s) of node</p>"},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode.left_sibling","title":"left_sibling  <code>property</code>","text":"<pre><code>left_sibling\n</code></pre> <p>Get sibling left of self.</p> <p>Returns:</p> Type Description <code>Optional[T]</code> <p>Left sibling of node</p>"},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode.right_sibling","title":"right_sibling  <code>property</code>","text":"<pre><code>right_sibling\n</code></pre> <p>Get sibling right of self.</p> <p>Returns:</p> Type Description <code>Optional[T]</code> <p>Right sibling of node</p>"},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode.node_path","title":"node_path  <code>property</code>","text":"<pre><code>node_path\n</code></pre> <p>Get tuple of nodes starting from root.</p> <p>Returns:</p> Type Description <code>Iterable[T]</code> <p>Node path from root to itself</p>"},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode.is_root","title":"is_root  <code>property</code>","text":"<pre><code>is_root\n</code></pre> <p>Get indicator if self is root node.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Indicator if node is root node</p>"},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode.root","title":"root  <code>property</code>","text":"<pre><code>root\n</code></pre> <p>Get root node of tree.</p> <p>Returns:</p> Type Description <code>T</code> <p>Root node</p>"},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode.diameter","title":"diameter  <code>property</code>","text":"<pre><code>diameter\n</code></pre> <p>Get diameter of tree or subtree, the length of longest path between any two nodes.</p> <p>Returns:</p> Type Description <code>int</code> <p>Diameter of node</p>"},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode.depth","title":"depth  <code>property</code>","text":"<pre><code>depth\n</code></pre> <p>Get depth of self, indexing starts from 1.</p> <p>Returns:</p> Type Description <code>int</code> <p>Depth of node</p>"},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode.max_depth","title":"max_depth  <code>property</code>","text":"<pre><code>max_depth\n</code></pre> <p>Get maximum depth from root to leaf node.</p> <p>Returns:</p> Type Description <code>int</code> <p>Maximum depth of tree</p>"},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode.sep","title":"sep  <code>property</code> <code>writable</code>","text":"<pre><code>sep\n</code></pre> <p>Get separator, gets from root node.</p> <p>Returns:</p> Type Description <code>str</code> <p>Seperator</p>"},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode.node_name","title":"node_name  <code>property</code>","text":"<pre><code>node_name\n</code></pre> <p>Get node name.</p> <p>Returns:</p> Type Description <code>str</code> <p>Node name</p>"},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode.path_name","title":"path_name  <code>property</code>","text":"<pre><code>path_name\n</code></pre> <p>Get path name, separated by self.sep.</p> <p>Returns:</p> Type Description <code>str</code> <p>Path name</p>"},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode.sort","title":"sort","text":"<pre><code>sort(**kwargs)\n</code></pre> <p>Sort children, possible keyword arguments include <code>key=lambda node: node.val</code>, <code>reverse=True</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import BinaryNode, print_tree\n&gt;&gt;&gt; a = BinaryNode(1)\n&gt;&gt;&gt; c = BinaryNode(3, parent=a)\n&gt;&gt;&gt; b = BinaryNode(2, parent=a)\n&gt;&gt;&gt; print_tree(a)\n1\n\u251c\u2500\u2500 3\n\u2514\u2500\u2500 2\n&gt;&gt;&gt; a.sort(key=lambda node: node.val)\n&gt;&gt;&gt; print_tree(a)\n1\n\u251c\u2500\u2500 2\n\u2514\u2500\u2500 3\n</code></pre>"},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(input_dict)\n</code></pre> <p>Construct node from dictionary, all keys of dictionary will be stored as class attributes. Input dictionary must have key <code>name</code> if not <code>Node</code> will not have any name.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node\n&gt;&gt;&gt; a = Node.from_dict({\"name\": \"a\", \"age\": 90})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>input_dict</code> <code>Dict[str, Any]</code> <p>dictionary with node information, key: attribute name, value: attribute value</p> required <p>Returns:</p> Type Description <code>BaseNode</code> <p>Base node</p>"},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode.describe","title":"describe","text":"<pre><code>describe(exclude_attributes=[], exclude_prefix='')\n</code></pre> <p>Get node information sorted by attribute name, returns list of tuples.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree.node.node import Node\n&gt;&gt;&gt; a = Node('a', age=90)\n&gt;&gt;&gt; a.describe()\n[('_BaseNode__children', []), ('_BaseNode__parent', None), ('_sep', '/'), ('age', 90), ('name', 'a')]\n&gt;&gt;&gt; a.describe(exclude_prefix=\"_\")\n[('age', 90), ('name', 'a')]\n&gt;&gt;&gt; a.describe(exclude_prefix=\"_\", exclude_attributes=[\"name\"])\n[('age', 90)]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>exclude_attributes</code> <code>List[str]</code> <p>list of attributes to exclude</p> <code>[]</code> <code>exclude_prefix</code> <code>str</code> <p>prefix of attributes to exclude</p> <code>''</code> <p>Returns:</p> Type Description <code>List[Tuple[str, Any]]</code> <p>List of attribute name and attribute value pairs</p>"},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode.get_attr","title":"get_attr","text":"<pre><code>get_attr(attr_name, default_value=None)\n</code></pre> <p>Get value of node attribute. Returns default value if attribute name does not exist.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree.node.node import Node\n&gt;&gt;&gt; a = Node('a', age=90)\n&gt;&gt;&gt; a.get_attr(\"age\")\n90\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>attr_name</code> <code>str</code> <p>attribute name</p> required <code>default_value</code> <code>Any</code> <p>default value if attribute does not exist</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>Attribute value of node</p>"},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode.set_attrs","title":"set_attrs","text":"<pre><code>set_attrs(attrs)\n</code></pre> <p>Set node attributes.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree.node.node import Node\n&gt;&gt;&gt; a = Node('a')\n&gt;&gt;&gt; a.set_attrs({\"age\": 90})\n&gt;&gt;&gt; a\nNode(/a, age=90)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>attrs</code> <code>Dict[str, Any]</code> <p>attribute dictionary, key: attribute name, value: attribute value</p> required"},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode.go_to","title":"go_to","text":"<pre><code>go_to(node)\n</code></pre> <p>Get path from current node to specified node from same tree.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, print_tree\n&gt;&gt;&gt; a = Node(name=\"a\")\n&gt;&gt;&gt; b = Node(name=\"b\", parent=a)\n&gt;&gt;&gt; c = Node(name=\"c\", parent=a)\n&gt;&gt;&gt; d = Node(name=\"d\", parent=b)\n&gt;&gt;&gt; e = Node(name=\"e\", parent=b)\n&gt;&gt;&gt; f = Node(name=\"f\", parent=c)\n&gt;&gt;&gt; g = Node(name=\"g\", parent=e)\n&gt;&gt;&gt; h = Node(name=\"h\", parent=e)\n&gt;&gt;&gt; print_tree(a)\na\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 d\n\u2502   \u2514\u2500\u2500 e\n\u2502       \u251c\u2500\u2500 g\n\u2502       \u2514\u2500\u2500 h\n\u2514\u2500\u2500 c\n    \u2514\u2500\u2500 f\n&gt;&gt;&gt; d.go_to(d)\n[Node(/a/b/d, )]\n&gt;&gt;&gt; d.go_to(g)\n[Node(/a/b/d, ), Node(/a/b, ), Node(/a/b/e, ), Node(/a/b/e/g, )]\n&gt;&gt;&gt; d.go_to(f)\n[Node(/a/b/d, ), Node(/a/b, ), Node(/a, ), Node(/a/c, ), Node(/a/c/f, )]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>T</code> <p>node to travel to from current node, inclusive of start and end node</p> required <p>Returns:</p> Type Description <code>Iterable[T]</code> <p>Path from current node to destination node</p>"},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode.append","title":"append","text":"<pre><code>append(other)\n</code></pre> <p>Add other as child of self.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>T</code> <p>other node, child to be added</p> required"},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode.extend","title":"extend","text":"<pre><code>extend(others)\n</code></pre> <p>Add others as children of self.</p> <p>Parameters:</p> Name Type Description Default <code>others</code> <code>List[T]</code> <p>other nodes, children to be added</p> required"},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode.copy","title":"copy","text":"<pre><code>copy()\n</code></pre> <p>Deep copy self; clone self.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree.node.node import Node\n&gt;&gt;&gt; a = Node('a')\n&gt;&gt;&gt; a_copy = a.copy()\n</code></pre> <p>Returns:</p> Type Description <code>T</code> <p>Cloned copy of node</p>"},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode.plot","title":"plot","text":"<pre><code>plot(*args, **kwargs)\n</code></pre> <p>Plot tree in line form. Accepts args and kwargs for matplotlib.pyplot.plot() function.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; from bigtree import list_to_tree\n&gt;&gt;&gt; path_list = [\"a/b/d\", \"a/b/e/g\", \"a/b/e/h\", \"a/c/f\"]\n&gt;&gt;&gt; root = list_to_tree(path_list)\n&gt;&gt;&gt; root.plot(\"-ok\")\n&lt;Figure size 1280x960 with 1 Axes&gt;\n</code></pre>"},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode.show","title":"show","text":"<pre><code>show(**kwargs)\n</code></pre> <p>Print tree to console, takes in same keyword arguments as <code>print_tree</code> function.</p>"},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode.hshow","title":"hshow","text":"<pre><code>hshow(**kwargs)\n</code></pre> <p>Print tree in horizontal orientation to console, takes in same keyword arguments as <code>hprint_tree</code> function.</p>"},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode.vshow","title":"vshow","text":"<pre><code>vshow(**kwargs)\n</code></pre> <p>Print tree in vertical orientation to console, takes in same keyword arguments as <code>vprint_tree</code> function.</p>"},{"location":"bigtree/node/dagnode/","title":"\ud83c\udf3c DAGNode","text":""},{"location":"bigtree/node/dagnode/#bigtree.node.dagnode","title":"bigtree.node.dagnode","text":""},{"location":"bigtree/node/dagnode/#bigtree.node.dagnode.DAGNode","title":"DAGNode","text":"<pre><code>DAGNode(name='', parents=None, children=None, **kwargs)\n</code></pre> <p>Base DAGNode extends any Python class to a DAG node, for DAG implementation. In DAG implementation, a node can have multiple parents.</p> <p>Parents and children cannot be reassigned once assigned, as Nodes are allowed to have multiple parents and children. If each node only has one parent, use <code>Node</code> class. DAGNodes can have attributes if they are initialized from <code>DAGNode</code> or dictionary.</p> <p>DAGNode can be linked to each other with <code>parents</code> and <code>children</code> setter methods, or using bitshift operator with the convention <code>parent_node &gt;&gt; child_node</code> or <code>child_node &lt;&lt; parent_node</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import DAGNode\n&gt;&gt;&gt; a = DAGNode(\"a\")\n&gt;&gt;&gt; b = DAGNode(\"b\")\n&gt;&gt;&gt; c = DAGNode(\"c\")\n&gt;&gt;&gt; d = DAGNode(\"d\")\n&gt;&gt;&gt; c.parents = [a, b]\n&gt;&gt;&gt; c.children = [d]\n</code></pre> <pre><code>&gt;&gt;&gt; from bigtree import DAGNode\n&gt;&gt;&gt; a = DAGNode(\"a\")\n&gt;&gt;&gt; b = DAGNode(\"b\")\n&gt;&gt;&gt; c = DAGNode(\"c\")\n&gt;&gt;&gt; d = DAGNode(\"d\")\n&gt;&gt;&gt; a &gt;&gt; c\n&gt;&gt;&gt; b &gt;&gt; c\n&gt;&gt;&gt; d &lt;&lt; c\n</code></pre> <p>Directly passing <code>parents</code> argument.</p> <pre><code>&gt;&gt;&gt; from bigtree import DAGNode\n&gt;&gt;&gt; a = DAGNode(\"a\")\n&gt;&gt;&gt; b = DAGNode(\"b\")\n&gt;&gt;&gt; c = DAGNode(\"c\", parents=[a, b])\n&gt;&gt;&gt; d = DAGNode(\"d\", parents=[c])\n</code></pre> <p>Directly passing <code>children</code> argument.</p> <pre><code>&gt;&gt;&gt; from bigtree import DAGNode\n&gt;&gt;&gt; d = DAGNode(\"d\")\n&gt;&gt;&gt; c = DAGNode(\"c\", children=[d])\n&gt;&gt;&gt; b = DAGNode(\"b\", children=[c])\n&gt;&gt;&gt; a = DAGNode(\"a\", children=[c])\n</code></pre> <p>DAGNode Creation</p> <p>Node can be created by instantiating a <code>DAGNode</code> class or by using a dictionary. If node is created with dictionary, all keys of dictionary will be stored as class attributes.</p> <pre><code>&gt;&gt;&gt; from bigtree import DAGNode\n&gt;&gt;&gt; a = DAGNode.from_dict({\"name\": \"a\", \"age\": 90})\n</code></pre> <p>DAGNode Attributes</p> <p>These are node attributes that have getter and/or setter methods.</p> <p>Get and set other <code>DAGNode</code></p> <ol> <li><code>parents</code>: Get/set parent nodes</li> <li><code>children</code>: Get/set child nodes</li> </ol> <p>Get other <code>DAGNode</code></p> <ol> <li><code>ancestors</code>: Get ancestors of node excluding self, iterator</li> <li><code>descendants</code>: Get descendants of node excluding self, iterator</li> <li><code>siblings</code>: Get siblings of self</li> </ol> <p>Get <code>DAGNode</code> configuration</p> <ol> <li><code>node_name</code>: Get node name, without accessing <code>name</code> directly</li> <li><code>is_root</code>: Get indicator if self is root node</li> <li><code>is_leaf</code>: Get indicator if self is leaf node</li> </ol> <p>DAGNode Methods</p> <p>These are methods available to be performed on <code>DAGNode</code>.</p> <p>Constructor methods</p> <ol> <li><code>from_dict()</code>: Create DAGNode from dictionary</li> </ol> <p><code>DAGNode</code> methods</p> <ol> <li><code>describe()</code>: Get node information sorted by attributes, return list of tuples</li> <li><code>get_attr(attr_name: str)</code>: Get value of node attribute</li> <li><code>set_attrs(attrs: dict)</code>: Set node attribute name(s) and value(s)</li> <li><code>go_to(node: Self)</code>: Get a path from own node to another node from same DAG</li> <li><code>copy()</code>: Deep copy self</li> </ol>"},{"location":"bigtree/node/dagnode/#bigtree.node.dagnode.DAGNode.parent","title":"parent  <code>property</code> <code>writable</code>","text":"<pre><code>parent\n</code></pre> <p>Do not allow <code>parent</code> attribute to be accessed.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>No such attribute</p>"},{"location":"bigtree/node/dagnode/#bigtree.node.dagnode.DAGNode.parents","title":"parents  <code>property</code> <code>writable</code>","text":"<pre><code>parents\n</code></pre> <p>Get parent nodes.</p> <p>Returns:</p> Type Description <code>Iterable[T]</code> <p>Parent node(s)</p>"},{"location":"bigtree/node/dagnode/#bigtree.node.dagnode.DAGNode.children","title":"children  <code>deletable</code> <code>property</code> <code>writable</code>","text":"<pre><code>children\n</code></pre> <p>Get child nodes.</p> <p>Returns:</p> Type Description <code>Iterable[T]</code> <p>Child node(s)</p>"},{"location":"bigtree/node/dagnode/#bigtree.node.dagnode.DAGNode.ancestors","title":"ancestors  <code>property</code>","text":"<pre><code>ancestors\n</code></pre> <p>Get iterator to yield all ancestors of self, does not include self.</p> <p>Returns:</p> Type Description <code>Iterable[T]</code> <p>Ancestor(s) of node excluding itself</p>"},{"location":"bigtree/node/dagnode/#bigtree.node.dagnode.DAGNode.descendants","title":"descendants  <code>property</code>","text":"<pre><code>descendants\n</code></pre> <p>Get iterator to yield all descendants of self, does not include self.</p> <p>Returns:</p> Type Description <code>Iterable[T]</code> <p>Descendant(s) of node excluding itself</p>"},{"location":"bigtree/node/dagnode/#bigtree.node.dagnode.DAGNode.siblings","title":"siblings  <code>property</code>","text":"<pre><code>siblings\n</code></pre> <p>Get siblings of self.</p> <p>Returns:</p> Type Description <code>Iterable[T]</code> <p>Sibling(s) of node</p>"},{"location":"bigtree/node/dagnode/#bigtree.node.dagnode.DAGNode.node_name","title":"node_name  <code>property</code>","text":"<pre><code>node_name\n</code></pre> <p>Get node name.</p> <p>Returns:</p> Type Description <code>str</code> <p>Node name</p>"},{"location":"bigtree/node/dagnode/#bigtree.node.dagnode.DAGNode.is_root","title":"is_root  <code>property</code>","text":"<pre><code>is_root\n</code></pre> <p>Get indicator if self is root node.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Indicator if node is root node</p>"},{"location":"bigtree/node/dagnode/#bigtree.node.dagnode.DAGNode.is_leaf","title":"is_leaf  <code>property</code>","text":"<pre><code>is_leaf\n</code></pre> <p>Get indicator if self is leaf node.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Indicator if node is leaf node</p>"},{"location":"bigtree/node/dagnode/#bigtree.node.dagnode.DAGNode.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(input_dict)\n</code></pre> <p>Construct node from dictionary, all keys of dictionary will be stored as class attributes. Input dictionary must have key <code>name</code> if not <code>Node</code> will not have any name.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import DAGNode\n&gt;&gt;&gt; a = DAGNode.from_dict({\"name\": \"a\", \"age\": 90})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>input_dict</code> <code>Dict[str, Any]</code> <p>dictionary with node information, key: attribute name, value: attribute value</p> required <p>Returns:</p> Type Description <code>DAGNode</code> <p>DAG node</p>"},{"location":"bigtree/node/dagnode/#bigtree.node.dagnode.DAGNode.describe","title":"describe","text":"<pre><code>describe(exclude_attributes=[], exclude_prefix='')\n</code></pre> <p>Get node information sorted by attribute name, returns list of tuples.</p> <p>Parameters:</p> Name Type Description Default <code>exclude_attributes</code> <code>List[str]</code> <p>list of attributes to exclude</p> <code>[]</code> <code>exclude_prefix</code> <code>str</code> <p>prefix of attributes to exclude</p> <code>''</code> <p>Returns:</p> Type Description <code>List[Tuple[str, Any]]</code> <p>List of attribute name and attribute value pairs</p>"},{"location":"bigtree/node/dagnode/#bigtree.node.dagnode.DAGNode.get_attr","title":"get_attr","text":"<pre><code>get_attr(attr_name, default_value=None)\n</code></pre> <p>Get value of node attribute. Returns default value if attribute name does not exist.</p> <p>Parameters:</p> Name Type Description Default <code>attr_name</code> <code>str</code> <p>attribute name</p> required <code>default_value</code> <code>Any</code> <p>default value if attribute does not exist</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>Attribute value of node</p>"},{"location":"bigtree/node/dagnode/#bigtree.node.dagnode.DAGNode.set_attrs","title":"set_attrs","text":"<pre><code>set_attrs(attrs)\n</code></pre> <p>Set node attributes.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree.node.dagnode import DAGNode\n&gt;&gt;&gt; a = DAGNode('a')\n&gt;&gt;&gt; a.set_attrs({\"age\": 90})\n&gt;&gt;&gt; a\nDAGNode(a, age=90)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>attrs</code> <code>Dict[str, Any]</code> <p>attribute dictionary, key: attribute name, value: attribute value</p> required"},{"location":"bigtree/node/dagnode/#bigtree.node.dagnode.DAGNode.go_to","title":"go_to","text":"<pre><code>go_to(node)\n</code></pre> <p>Get list of possible paths from current node to specified node from same tree.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import DAGNode\n&gt;&gt;&gt; a = DAGNode(\"a\")\n&gt;&gt;&gt; b = DAGNode(\"b\")\n&gt;&gt;&gt; c = DAGNode(\"c\")\n&gt;&gt;&gt; d = DAGNode(\"d\")\n&gt;&gt;&gt; a &gt;&gt; c\n&gt;&gt;&gt; b &gt;&gt; c\n&gt;&gt;&gt; c &gt;&gt; d\n&gt;&gt;&gt; a &gt;&gt; d\n&gt;&gt;&gt; a.go_to(c)\n[[DAGNode(a, ), DAGNode(c, )]]\n&gt;&gt;&gt; a.go_to(d)\n[[DAGNode(a, ), DAGNode(c, ), DAGNode(d, )], [DAGNode(a, ), DAGNode(d, )]]\n&gt;&gt;&gt; a.go_to(b)\nTraceback (most recent call last):\n    ...\nbigtree.utils.exceptions.exceptions.TreeError: It is not possible to go to DAGNode(b, )\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>T</code> <p>node to travel to from current node, inclusive of start and end node</p> required <p>Returns:</p> Type Description <code>List[List[T]]</code> <p>Path from current node to destination node</p>"},{"location":"bigtree/node/dagnode/#bigtree.node.dagnode.DAGNode.copy","title":"copy","text":"<pre><code>copy()\n</code></pre> <p>Deep copy self; clone DAGNode.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree.node.dagnode import DAGNode\n&gt;&gt;&gt; a = DAGNode('a')\n&gt;&gt;&gt; a_copy = a.copy()\n</code></pre> <p>Returns:</p> Type Description <code>T</code> <p>Cloned copy of node</p>"},{"location":"bigtree/node/node/","title":"\ud83c\udf3a Node","text":""},{"location":"bigtree/node/node/#bigtree.node.node","title":"bigtree.node.node","text":""},{"location":"bigtree/node/node/#bigtree.node.node.Node","title":"Node","text":"<pre><code>Node(name, sep='/', **kwargs)\n</code></pre> <p>               Bases: <code>BaseNode</code></p> <p>Node is an extension of BaseNode, and is able to extend to any Python class. Nodes can have attributes if they are initialized from <code>Node</code>, dictionary, or pandas DataFrame.</p> <p>Note</p> <p>Node names cannot contain separator symbol! This will not throw error, but you might run into issues when performing certain functions such as export-then-import of tree.</p> <p>Nodes can be linked to each other with <code>parent</code> and <code>children</code> setter methods.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node\n&gt;&gt;&gt; a = Node(\"a\")\n&gt;&gt;&gt; b = Node(\"b\")\n&gt;&gt;&gt; c = Node(\"c\")\n&gt;&gt;&gt; d = Node(\"d\")\n&gt;&gt;&gt; b.parent = a\n&gt;&gt;&gt; b.children = [c, d]\n</code></pre> <p>Directly passing <code>parent</code> argument.</p> <pre><code>&gt;&gt;&gt; from bigtree import Node\n&gt;&gt;&gt; a = Node(\"a\")\n&gt;&gt;&gt; b = Node(\"b\", parent=a)\n&gt;&gt;&gt; c = Node(\"c\", parent=b)\n&gt;&gt;&gt; d = Node(\"d\", parent=b)\n</code></pre> <p>Directly passing <code>children</code> argument.</p> <pre><code>&gt;&gt;&gt; from bigtree import Node\n&gt;&gt;&gt; d = Node(\"d\")\n&gt;&gt;&gt; c = Node(\"c\")\n&gt;&gt;&gt; b = Node(\"b\", children=[c, d])\n&gt;&gt;&gt; a = Node(\"a\", children=[b])\n</code></pre> <p>Node Creation</p> <p>Node can be created by instantiating a <code>Node</code> class or by using a dictionary. If node is created with dictionary, all keys of dictionary will be stored as class attributes.</p> <pre><code>&gt;&gt;&gt; from bigtree import Node\n&gt;&gt;&gt; a = Node.from_dict({\"name\": \"a\", \"age\": 90})\n</code></pre> <p>Node Attributes</p> <p>These are node attributes that have getter and/or setter methods.</p> <p>Get and set <code>Node</code> configuration</p> <ol> <li><code>sep</code>: Get/set separator for path name</li> </ol> <p>Get <code>Node</code> configuration</p> <ol> <li><code>node_name</code>: Get node name, without accessing <code>name</code> directly.     This is the preferred way to access node name as <code>node_name</code> is     immutable, whereas <code>name</code> is mutable.</li> <li><code>path_name</code>: Get path name from root, separated by <code>sep</code></li> </ol> <p>Node Methods</p> <p>These are methods available to be performed on <code>Node</code>.</p> <p><code>Node</code> methods</p> <ol> <li><code>show()</code>: Print tree to console</li> <li><code>hshow()</code>: Print tree in horizontal orientation to console</li> <li><code>vshow()</code>: Print tree in vertical orientation to console</li> </ol>"},{"location":"bigtree/node/node/#bigtree.node.node.Node.sep","title":"sep  <code>property</code> <code>writable</code>","text":"<pre><code>sep\n</code></pre> <p>Get separator, gets from root node.</p> <p>Returns:</p> Type Description <code>str</code> <p>Seperator</p>"},{"location":"bigtree/node/node/#bigtree.node.node.Node.node_name","title":"node_name  <code>property</code>","text":"<pre><code>node_name\n</code></pre> <p>Get node name.</p> <p>Returns:</p> Type Description <code>str</code> <p>Node name</p>"},{"location":"bigtree/node/node/#bigtree.node.node.Node.path_name","title":"path_name  <code>property</code>","text":"<pre><code>path_name\n</code></pre> <p>Get path name, separated by self.sep.</p> <p>Returns:</p> Type Description <code>str</code> <p>Path name</p>"},{"location":"bigtree/node/node/#bigtree.node.node.Node.parent","title":"parent  <code>property</code> <code>writable</code>","text":"<pre><code>parent\n</code></pre> <p>Get parent node.</p> <p>Returns:</p> Type Description <code>Optional[T]</code> <p>Parent node, none if the node is root</p>"},{"location":"bigtree/node/node/#bigtree.node.node.Node.children","title":"children  <code>deletable</code> <code>property</code> <code>writable</code>","text":"<pre><code>children\n</code></pre> <p>Get child nodes.</p> <p>Returns:</p> Type Description <code>Tuple[T, ...]</code> <p>Child node(s)</p>"},{"location":"bigtree/node/node/#bigtree.node.node.Node.parents","title":"parents  <code>property</code> <code>writable</code>","text":"<pre><code>parents\n</code></pre> <p>Do not allow <code>parents</code> attribute to be accessed.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>No such attribute</p>"},{"location":"bigtree/node/node/#bigtree.node.node.Node.ancestors","title":"ancestors  <code>property</code>","text":"<pre><code>ancestors\n</code></pre> <p>Get iterator to yield all ancestors of self, does not include self.</p> <p>Returns:</p> Type Description <code>Iterable[T]</code> <p>Ancestor(s) of node excluding itself</p>"},{"location":"bigtree/node/node/#bigtree.node.node.Node.descendants","title":"descendants  <code>property</code>","text":"<pre><code>descendants\n</code></pre> <p>Get iterator to yield all descendants of self, does not include self.</p> <p>Returns:</p> Type Description <code>Iterable[T]</code> <p>Descendant(s) of node excluding itself</p>"},{"location":"bigtree/node/node/#bigtree.node.node.Node.leaves","title":"leaves  <code>property</code>","text":"<pre><code>leaves\n</code></pre> <p>Get iterator to yield all leaf nodes from self.</p> <p>Returns:</p> Type Description <code>Iterable[T]</code> <p>Leaf node(s) of node</p>"},{"location":"bigtree/node/node/#bigtree.node.node.Node.siblings","title":"siblings  <code>property</code>","text":"<pre><code>siblings\n</code></pre> <p>Get siblings of self.</p> <p>Returns:</p> Type Description <code>Iterable[T]</code> <p>Sibling(s) of node</p>"},{"location":"bigtree/node/node/#bigtree.node.node.Node.left_sibling","title":"left_sibling  <code>property</code>","text":"<pre><code>left_sibling\n</code></pre> <p>Get sibling left of self.</p> <p>Returns:</p> Type Description <code>Optional[T]</code> <p>Left sibling of node</p>"},{"location":"bigtree/node/node/#bigtree.node.node.Node.right_sibling","title":"right_sibling  <code>property</code>","text":"<pre><code>right_sibling\n</code></pre> <p>Get sibling right of self.</p> <p>Returns:</p> Type Description <code>Optional[T]</code> <p>Right sibling of node</p>"},{"location":"bigtree/node/node/#bigtree.node.node.Node.node_path","title":"node_path  <code>property</code>","text":"<pre><code>node_path\n</code></pre> <p>Get tuple of nodes starting from root.</p> <p>Returns:</p> Type Description <code>Iterable[T]</code> <p>Node path from root to itself</p>"},{"location":"bigtree/node/node/#bigtree.node.node.Node.is_root","title":"is_root  <code>property</code>","text":"<pre><code>is_root\n</code></pre> <p>Get indicator if self is root node.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Indicator if node is root node</p>"},{"location":"bigtree/node/node/#bigtree.node.node.Node.is_leaf","title":"is_leaf  <code>property</code>","text":"<pre><code>is_leaf\n</code></pre> <p>Get indicator if self is leaf node.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Indicator if node is leaf node</p>"},{"location":"bigtree/node/node/#bigtree.node.node.Node.root","title":"root  <code>property</code>","text":"<pre><code>root\n</code></pre> <p>Get root node of tree.</p> <p>Returns:</p> Type Description <code>T</code> <p>Root node</p>"},{"location":"bigtree/node/node/#bigtree.node.node.Node.diameter","title":"diameter  <code>property</code>","text":"<pre><code>diameter\n</code></pre> <p>Get diameter of tree or subtree, the length of longest path between any two nodes.</p> <p>Returns:</p> Type Description <code>int</code> <p>Diameter of node</p>"},{"location":"bigtree/node/node/#bigtree.node.node.Node.depth","title":"depth  <code>property</code>","text":"<pre><code>depth\n</code></pre> <p>Get depth of self, indexing starts from 1.</p> <p>Returns:</p> Type Description <code>int</code> <p>Depth of node</p>"},{"location":"bigtree/node/node/#bigtree.node.node.Node.max_depth","title":"max_depth  <code>property</code>","text":"<pre><code>max_depth\n</code></pre> <p>Get maximum depth from root to leaf node.</p> <p>Returns:</p> Type Description <code>int</code> <p>Maximum depth of tree</p>"},{"location":"bigtree/node/node/#bigtree.node.node.Node.show","title":"show","text":"<pre><code>show(**kwargs)\n</code></pre> <p>Print tree to console, takes in same keyword arguments as <code>print_tree</code> function.</p>"},{"location":"bigtree/node/node/#bigtree.node.node.Node.hshow","title":"hshow","text":"<pre><code>hshow(**kwargs)\n</code></pre> <p>Print tree in horizontal orientation to console, takes in same keyword arguments as <code>hprint_tree</code> function.</p>"},{"location":"bigtree/node/node/#bigtree.node.node.Node.vshow","title":"vshow","text":"<pre><code>vshow(**kwargs)\n</code></pre> <p>Print tree in vertical orientation to console, takes in same keyword arguments as <code>vprint_tree</code> function.</p>"},{"location":"bigtree/node/node/#bigtree.node.node.Node.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(input_dict)\n</code></pre> <p>Construct node from dictionary, all keys of dictionary will be stored as class attributes. Input dictionary must have key <code>name</code> if not <code>Node</code> will not have any name.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node\n&gt;&gt;&gt; a = Node.from_dict({\"name\": \"a\", \"age\": 90})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>input_dict</code> <code>Dict[str, Any]</code> <p>dictionary with node information, key: attribute name, value: attribute value</p> required <p>Returns:</p> Type Description <code>BaseNode</code> <p>Base node</p>"},{"location":"bigtree/node/node/#bigtree.node.node.Node.describe","title":"describe","text":"<pre><code>describe(exclude_attributes=[], exclude_prefix='')\n</code></pre> <p>Get node information sorted by attribute name, returns list of tuples.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree.node.node import Node\n&gt;&gt;&gt; a = Node('a', age=90)\n&gt;&gt;&gt; a.describe()\n[('_BaseNode__children', []), ('_BaseNode__parent', None), ('_sep', '/'), ('age', 90), ('name', 'a')]\n&gt;&gt;&gt; a.describe(exclude_prefix=\"_\")\n[('age', 90), ('name', 'a')]\n&gt;&gt;&gt; a.describe(exclude_prefix=\"_\", exclude_attributes=[\"name\"])\n[('age', 90)]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>exclude_attributes</code> <code>List[str]</code> <p>list of attributes to exclude</p> <code>[]</code> <code>exclude_prefix</code> <code>str</code> <p>prefix of attributes to exclude</p> <code>''</code> <p>Returns:</p> Type Description <code>List[Tuple[str, Any]]</code> <p>List of attribute name and attribute value pairs</p>"},{"location":"bigtree/node/node/#bigtree.node.node.Node.get_attr","title":"get_attr","text":"<pre><code>get_attr(attr_name, default_value=None)\n</code></pre> <p>Get value of node attribute. Returns default value if attribute name does not exist.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree.node.node import Node\n&gt;&gt;&gt; a = Node('a', age=90)\n&gt;&gt;&gt; a.get_attr(\"age\")\n90\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>attr_name</code> <code>str</code> <p>attribute name</p> required <code>default_value</code> <code>Any</code> <p>default value if attribute does not exist</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>Attribute value of node</p>"},{"location":"bigtree/node/node/#bigtree.node.node.Node.set_attrs","title":"set_attrs","text":"<pre><code>set_attrs(attrs)\n</code></pre> <p>Set node attributes.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree.node.node import Node\n&gt;&gt;&gt; a = Node('a')\n&gt;&gt;&gt; a.set_attrs({\"age\": 90})\n&gt;&gt;&gt; a\nNode(/a, age=90)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>attrs</code> <code>Dict[str, Any]</code> <p>attribute dictionary, key: attribute name, value: attribute value</p> required"},{"location":"bigtree/node/node/#bigtree.node.node.Node.go_to","title":"go_to","text":"<pre><code>go_to(node)\n</code></pre> <p>Get path from current node to specified node from same tree.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, print_tree\n&gt;&gt;&gt; a = Node(name=\"a\")\n&gt;&gt;&gt; b = Node(name=\"b\", parent=a)\n&gt;&gt;&gt; c = Node(name=\"c\", parent=a)\n&gt;&gt;&gt; d = Node(name=\"d\", parent=b)\n&gt;&gt;&gt; e = Node(name=\"e\", parent=b)\n&gt;&gt;&gt; f = Node(name=\"f\", parent=c)\n&gt;&gt;&gt; g = Node(name=\"g\", parent=e)\n&gt;&gt;&gt; h = Node(name=\"h\", parent=e)\n&gt;&gt;&gt; print_tree(a)\na\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 d\n\u2502   \u2514\u2500\u2500 e\n\u2502       \u251c\u2500\u2500 g\n\u2502       \u2514\u2500\u2500 h\n\u2514\u2500\u2500 c\n    \u2514\u2500\u2500 f\n&gt;&gt;&gt; d.go_to(d)\n[Node(/a/b/d, )]\n&gt;&gt;&gt; d.go_to(g)\n[Node(/a/b/d, ), Node(/a/b, ), Node(/a/b/e, ), Node(/a/b/e/g, )]\n&gt;&gt;&gt; d.go_to(f)\n[Node(/a/b/d, ), Node(/a/b, ), Node(/a, ), Node(/a/c, ), Node(/a/c/f, )]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>T</code> <p>node to travel to from current node, inclusive of start and end node</p> required <p>Returns:</p> Type Description <code>Iterable[T]</code> <p>Path from current node to destination node</p>"},{"location":"bigtree/node/node/#bigtree.node.node.Node.append","title":"append","text":"<pre><code>append(other)\n</code></pre> <p>Add other as child of self.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>T</code> <p>other node, child to be added</p> required"},{"location":"bigtree/node/node/#bigtree.node.node.Node.extend","title":"extend","text":"<pre><code>extend(others)\n</code></pre> <p>Add others as children of self.</p> <p>Parameters:</p> Name Type Description Default <code>others</code> <code>List[T]</code> <p>other nodes, children to be added</p> required"},{"location":"bigtree/node/node/#bigtree.node.node.Node.copy","title":"copy","text":"<pre><code>copy()\n</code></pre> <p>Deep copy self; clone self.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree.node.node import Node\n&gt;&gt;&gt; a = Node('a')\n&gt;&gt;&gt; a_copy = a.copy()\n</code></pre> <p>Returns:</p> Type Description <code>T</code> <p>Cloned copy of node</p>"},{"location":"bigtree/node/node/#bigtree.node.node.Node.sort","title":"sort","text":"<pre><code>sort(**kwargs)\n</code></pre> <p>Sort children, possible keyword arguments include <code>key=lambda node: node.node_name</code>, <code>reverse=True</code>. Accepts kwargs for sort() function.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, print_tree\n&gt;&gt;&gt; a = Node('a')\n&gt;&gt;&gt; c = Node(\"c\", parent=a)\n&gt;&gt;&gt; b = Node(\"b\", parent=a)\n&gt;&gt;&gt; print_tree(a)\na\n\u251c\u2500\u2500 c\n\u2514\u2500\u2500 b\n&gt;&gt;&gt; a.sort(key=lambda node: node.node_name)\n&gt;&gt;&gt; print_tree(a)\na\n\u251c\u2500\u2500 b\n\u2514\u2500\u2500 c\n</code></pre>"},{"location":"bigtree/node/node/#bigtree.node.node.Node.plot","title":"plot","text":"<pre><code>plot(*args, **kwargs)\n</code></pre> <p>Plot tree in line form. Accepts args and kwargs for matplotlib.pyplot.plot() function.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; from bigtree import list_to_tree\n&gt;&gt;&gt; path_list = [\"a/b/d\", \"a/b/e/g\", \"a/b/e/h\", \"a/c/f\"]\n&gt;&gt;&gt; root = list_to_tree(path_list)\n&gt;&gt;&gt; root.plot(\"-ok\")\n&lt;Figure size 1280x960 with 1 Axes&gt;\n</code></pre>"},{"location":"bigtree/tree/construct/","title":"\u2728 Construct","text":""},{"location":"bigtree/tree/construct/#tree-construct-methods","title":"Tree Construct Methods","text":"<p>Construct Tree from list, dictionary, and pandas DataFrame.</p> <p>To decide which method to use, consider your data type and data values.</p> Construct tree from Using full path Using parent-child relation Using notation Add node attributes String <code>str_to_tree</code> NA <code>newick_to_tree</code> No (for <code>str_to_tree</code>)Yes (for  <code>newick_to_tree</code>) List <code>list_to_tree</code> <code>list_to_tree_by_relation</code> NA No Dictionary <code>dict_to_tree</code> <code>nested_dict_to_tree</code> NA Yes pandas DataFrame <code>dataframe_to_tree</code> <code>dataframe_to_tree_by_relation</code> NA Yes polars DataFrame <code>polars_to_tree</code> <code>polars_to_tree_by_relation</code> NA Yes"},{"location":"bigtree/tree/construct/#tree-add-attributes-methods","title":"Tree Add Attributes Methods","text":"<p>To add attributes to an existing tree,</p> Add attributes from Using full path Using node name String <code>add_path_to_tree</code> NA Dictionary <code>add_dict_to_tree_by_path</code> <code>add_dict_to_tree_by_name</code> pandas DataFrame <code>add_dataframe_to_tree_by_path</code> <code>add_dataframe_to_tree_by_name</code> polars DataFrame <code>add_polars_to_tree_by_path</code> <code>add_polars_to_tree_by_name</code> <p>Note</p> <p>If attributes are added to existing tree using full path, paths that previously did not exist will be added. If attributes are added to existing tree using node name, names that previously did not exist will not be created.</p> <p>These functions are not standalone functions. Under the hood, they have the following dependency,</p> <p></p>"},{"location":"bigtree/tree/construct/#bigtree.tree.construct","title":"bigtree.tree.construct","text":""},{"location":"bigtree/tree/construct/#bigtree.tree.construct.add_dataframe_to_tree_by_name","title":"add_dataframe_to_tree_by_name","text":"<pre><code>add_dataframe_to_tree_by_name(\n    tree, data, name_col=\"\", attribute_cols=[]\n)\n</code></pre> <p>Add attributes to existing tree in-place. Adds to existing tree from pandas DataFrame.</p> <p><code>name_col</code> and <code>attribute_cols</code> specify columns for node name and attributes to add to existing tree. If columns are not specified, the first column will be taken as name column and all other columns as attributes.</p> <ul> <li>Only attributes in <code>attribute_cols</code> with non-null values will be added to the tree</li> <li>Input data node names that are not existing node names will be ignored. Note that if multiple nodes have the same name, attributes will be added to all nodes sharing same name</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from bigtree import add_dataframe_to_tree_by_name, Node\n&gt;&gt;&gt; root = Node(\"a\")\n&gt;&gt;&gt; b = Node(\"b\", parent=root)\n&gt;&gt;&gt; name_data = pd.DataFrame([\n...     [\"a\", 90],\n...     [\"b\", 65],\n... ],\n...     columns=[\"NAME\", \"age\"]\n... )\n&gt;&gt;&gt; root = add_dataframe_to_tree_by_name(root, name_data)\n&gt;&gt;&gt; root.show(attr_list=[\"age\"])\na [age=90]\n\u2514\u2500\u2500 b [age=65]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>T</code> <p>existing tree</p> required <code>data</code> <code>DataFrame</code> <p>data containing node name and attribute information</p> required <code>name_col</code> <code>str</code> <p>column of data containing <code>name</code> information, if not set, it will take the first column of data</p> <code>''</code> <code>attribute_cols</code> <code>List[str]</code> <p>column(s) of data containing node attribute information, if not set, it will take all columns of data except <code>path_col</code></p> <code>[]</code> <p>Returns:</p> Type Description <code>T</code> <p>Node</p>"},{"location":"bigtree/tree/construct/#bigtree.tree.construct.add_dataframe_to_tree_by_path","title":"add_dataframe_to_tree_by_path","text":"<pre><code>add_dataframe_to_tree_by_path(\n    tree,\n    data,\n    path_col=\"\",\n    attribute_cols=[],\n    sep=\"/\",\n    duplicate_name_allowed=True,\n)\n</code></pre> <p>Add nodes and attributes to tree in-place, return root of tree. Adds to existing tree from pandas DataFrame.</p> <p><code>path_col</code> and <code>attribute_cols</code> specify columns for node path and attributes to add to existing tree. If columns are not specified, <code>path_col</code> takes first column and all other columns are <code>attribute_cols</code></p> <ul> <li>Only attributes in <code>attribute_cols</code> with non-null values will be added to the tree</li> </ul> <p>Path in path column should contain <code>Node</code> name, separated by <code>sep</code>.</p> <ul> <li>For example: Path string \"a/b\" refers to Node(\"b\") with parent Node(\"a\")</li> <li>Path separator <code>sep</code> is for the input <code>path</code> and can differ from existing tree</li> </ul> <p>Path in path column can start from root node <code>name</code>, or start with <code>sep</code>.</p> <ul> <li>For example: Path string can be \"/a/b\" or \"a/b\", if sep is \"/\"</li> </ul> <p>All paths should start from the same root node.</p> <ul> <li>For example: Path strings should be \"a/b\", \"a/c\", \"a/b/d\" etc. and should not start with another root node</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from bigtree import add_dataframe_to_tree_by_path, Node\n&gt;&gt;&gt; root = Node(\"a\")\n&gt;&gt;&gt; path_data = pd.DataFrame([\n...     [\"a\", 90],\n...     [\"a/b\", 65],\n...     [\"a/c\", 60],\n...     [\"a/b/d\", 40],\n...     [\"a/b/e\", 35],\n...     [\"a/c/f\", 38],\n...     [\"a/b/e/g\", 10],\n...     [\"a/b/e/h\", 6],\n... ],\n...     columns=[\"PATH\", \"age\"]\n... )\n&gt;&gt;&gt; root = add_dataframe_to_tree_by_path(root, path_data)\n&gt;&gt;&gt; root.show(attr_list=[\"age\"])\na [age=90]\n\u251c\u2500\u2500 b [age=65]\n\u2502   \u251c\u2500\u2500 d [age=40]\n\u2502   \u2514\u2500\u2500 e [age=35]\n\u2502       \u251c\u2500\u2500 g [age=10]\n\u2502       \u2514\u2500\u2500 h [age=6]\n\u2514\u2500\u2500 c [age=60]\n    \u2514\u2500\u2500 f [age=38]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>T</code> <p>existing tree</p> required <code>data</code> <code>DataFrame</code> <p>data containing node path and attribute information</p> required <code>path_col</code> <code>str</code> <p>column of data containing <code>path_name</code> information, if not set, it will take the first column of data</p> <code>''</code> <code>attribute_cols</code> <code>List[str]</code> <p>columns of data containing node attribute information, if not set, it will take all columns of data except <code>path_col</code></p> <code>[]</code> <code>sep</code> <code>str</code> <p>path separator for input <code>path_col</code></p> <code>'/'</code> <code>duplicate_name_allowed</code> <code>bool</code> <p>indicator if nodes with duplicate <code>Node</code> name is allowed</p> <code>True</code> <p>Returns:</p> Type Description <code>T</code> <p>Node</p>"},{"location":"bigtree/tree/construct/#bigtree.tree.construct.add_polars_to_tree_by_name","title":"add_polars_to_tree_by_name","text":"<pre><code>add_polars_to_tree_by_name(\n    tree, data, name_col=\"\", attribute_cols=[]\n)\n</code></pre> <p>Add attributes to existing tree in-place. Adds to existing tree from polars DataFrame.</p> <p><code>name_col</code> and <code>attribute_cols</code> specify columns for node name and attributes to add to existing tree. If columns are not specified, the first column will be taken as name column and all other columns as attributes.</p> <ul> <li>Only attributes in <code>attribute_cols</code> with non-null values will be added to the tree</li> <li>Input data node names that are not existing node names will be ignored. Note that if multiple nodes have the same name, attributes will be added to all nodes sharing same name</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from bigtree import add_polars_to_tree_by_name, Node\n&gt;&gt;&gt; root = Node(\"a\")\n&gt;&gt;&gt; b = Node(\"b\", parent=root)\n&gt;&gt;&gt; name_data = pl.DataFrame({\n...     \"NAME\": [\"a\", \"b\"],\n...     \"age\": [90, 65],\n... })\n&gt;&gt;&gt; root = add_polars_to_tree_by_name(root, name_data)\n&gt;&gt;&gt; root.show(attr_list=[\"age\"])\na [age=90]\n\u2514\u2500\u2500 b [age=65]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>T</code> <p>existing tree</p> required <code>data</code> <code>DataFrame</code> <p>data containing node name and attribute information</p> required <code>name_col</code> <code>str</code> <p>column of data containing <code>name</code> information, if not set, it will take the first column of data</p> <code>''</code> <code>attribute_cols</code> <code>List[str]</code> <p>column(s) of data containing node attribute information, if not set, it will take all columns of data except <code>path_col</code></p> <code>[]</code> <p>Returns:</p> Type Description <code>T</code> <p>Node</p>"},{"location":"bigtree/tree/construct/#bigtree.tree.construct.add_polars_to_tree_by_path","title":"add_polars_to_tree_by_path","text":"<pre><code>add_polars_to_tree_by_path(\n    tree,\n    data,\n    path_col=\"\",\n    attribute_cols=[],\n    sep=\"/\",\n    duplicate_name_allowed=True,\n)\n</code></pre> <p>Add nodes and attributes to tree in-place, return root of tree. Adds to existing tree from polars DataFrame.</p> <p><code>path_col</code> and <code>attribute_cols</code> specify columns for node path and attributes to add to existing tree. If columns are not specified, <code>path_col</code> takes first column and all other columns are <code>attribute_cols</code></p> <ul> <li>Only attributes in <code>attribute_cols</code> with non-null values will be added to the tree</li> </ul> <p>Path in path column should contain <code>Node</code> name, separated by <code>sep</code>.</p> <ul> <li>For example: Path string \"a/b\" refers to Node(\"b\") with parent Node(\"a\")</li> <li>Path separator <code>sep</code> is for the input <code>path</code> and can differ from existing tree</li> </ul> <p>Path in path column can start from root node <code>name</code>, or start with <code>sep</code>.</p> <ul> <li>For example: Path string can be \"/a/b\" or \"a/b\", if sep is \"/\"</li> </ul> <p>All paths should start from the same root node.</p> <ul> <li>For example: Path strings should be \"a/b\", \"a/c\", \"a/b/d\" etc. and should not start with another root node</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from bigtree import add_polars_to_tree_by_path, Node\n&gt;&gt;&gt; root = Node(\"a\")\n&gt;&gt;&gt; path_data = pl.DataFrame([\n...     [\"a\", 90],\n...     [\"a/b\", 65],\n...     [\"a/c\", 60],\n...     [\"a/b/d\", 40],\n...     [\"a/b/e\", 35],\n...     [\"a/c/f\", 38],\n...     [\"a/b/e/g\", 10],\n...     [\"a/b/e/h\", 6],\n... ],\n...     schema=[\"PATH\", \"age\"]\n... )\n&gt;&gt;&gt; root = add_polars_to_tree_by_path(root, path_data)\n&gt;&gt;&gt; root.show(attr_list=[\"age\"])\na [age=90]\n\u251c\u2500\u2500 b [age=65]\n\u2502   \u251c\u2500\u2500 d [age=40]\n\u2502   \u2514\u2500\u2500 e [age=35]\n\u2502       \u251c\u2500\u2500 g [age=10]\n\u2502       \u2514\u2500\u2500 h [age=6]\n\u2514\u2500\u2500 c [age=60]\n    \u2514\u2500\u2500 f [age=38]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>T</code> <p>existing tree</p> required <code>data</code> <code>DataFrame</code> <p>data containing node path and attribute information</p> required <code>path_col</code> <code>str</code> <p>column of data containing <code>path_name</code> information, if not set, it will take the first column of data</p> <code>''</code> <code>attribute_cols</code> <code>List[str]</code> <p>columns of data containing node attribute information, if not set, it will take all columns of data except <code>path_col</code></p> <code>[]</code> <code>sep</code> <code>str</code> <p>path separator for input <code>path_col</code></p> <code>'/'</code> <code>duplicate_name_allowed</code> <code>bool</code> <p>indicator if nodes with duplicate <code>Node</code> name is allowed</p> <code>True</code> <p>Returns:</p> Type Description <code>T</code> <p>Node</p>"},{"location":"bigtree/tree/construct/#bigtree.tree.construct.dataframe_to_tree","title":"dataframe_to_tree","text":"<pre><code>dataframe_to_tree(\n    data,\n    path_col=\"\",\n    attribute_cols=[],\n    sep=\"/\",\n    duplicate_name_allowed=True,\n    node_type=Node,\n)\n</code></pre> <p>Construct tree from pandas DataFrame using path, return root of tree.</p> <p><code>path_col</code> and <code>attribute_cols</code> specify columns for node path and attributes to construct tree. If columns are not specified, <code>path_col</code> takes first column and all other columns are <code>attribute_cols</code>.</p> <ul> <li>Only attributes in <code>attribute_cols</code> with non-null values will be added to the tree</li> </ul> <p>Path in path column should contain <code>Node</code> name, separated by <code>sep</code>.</p> <ul> <li>For example: Path string \"a/b\" refers to Node(\"b\") with parent Node(\"a\")</li> </ul> <p>Path in path column can start from root node <code>name</code>, or start with <code>sep</code>.</p> <ul> <li>For example: Path string can be \"/a/b\" or \"a/b\", if sep is \"/\"</li> </ul> <p>All paths should start from the same root node.</p> <ul> <li>For example: Path strings should be \"a/b\", \"a/c\", \"a/b/d\" etc. and should not start with another root node</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from bigtree import dataframe_to_tree\n&gt;&gt;&gt; path_data = pd.DataFrame([\n...     [\"a\", 90],\n...     [\"a/b\", 65],\n...     [\"a/c\", 60],\n...     [\"a/b/d\", 40],\n...     [\"a/b/e\", 35],\n...     [\"a/c/f\", 38],\n...     [\"a/b/e/g\", 10],\n...     [\"a/b/e/h\", 6],\n... ],\n...     columns=[\"PATH\", \"age\"]\n... )\n&gt;&gt;&gt; root = dataframe_to_tree(path_data)\n&gt;&gt;&gt; root.show(attr_list=[\"age\"])\na [age=90]\n\u251c\u2500\u2500 b [age=65]\n\u2502   \u251c\u2500\u2500 d [age=40]\n\u2502   \u2514\u2500\u2500 e [age=35]\n\u2502       \u251c\u2500\u2500 g [age=10]\n\u2502       \u2514\u2500\u2500 h [age=6]\n\u2514\u2500\u2500 c [age=60]\n    \u2514\u2500\u2500 f [age=38]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>data containing path and node attribute information</p> required <code>path_col</code> <code>str</code> <p>column of data containing <code>path_name</code> information, if not set, it will take the first column of data</p> <code>''</code> <code>attribute_cols</code> <code>List[str]</code> <p>columns of data containing node attribute information, if not set, it will take all columns of data except <code>path_col</code></p> <code>[]</code> <code>sep</code> <code>str</code> <p>path separator of input <code>path_col</code> and created tree</p> <code>'/'</code> <code>duplicate_name_allowed</code> <code>bool</code> <p>indicator if nodes with duplicate <code>Node</code> name is allowed</p> <code>True</code> <code>node_type</code> <code>Type[T]</code> <p>node type of tree to be created</p> <code>Node</code> <p>Returns:</p> Type Description <code>T</code> <p>Node</p>"},{"location":"bigtree/tree/construct/#bigtree.tree.construct.dataframe_to_tree_by_relation","title":"dataframe_to_tree_by_relation","text":"<pre><code>dataframe_to_tree_by_relation(\n    data,\n    child_col=\"\",\n    parent_col=\"\",\n    attribute_cols=[],\n    allow_duplicates=False,\n    node_type=Node,\n)\n</code></pre> <p>Construct tree from pandas DataFrame using parent and child names, return root of tree.</p> <p>Root node is inferred when parent name is empty, or when name appears in parent column but not in child column.</p> <p>Since tree is created from parent-child names, only names of leaf nodes may be repeated. Error will be thrown if names of intermediate nodes are repeated as there will be confusion. This error can be ignored by setting <code>allow_duplicates</code> to be True.</p> <p><code>child_col</code> and <code>parent_col</code> specify columns for child name and parent name to construct tree. <code>attribute_cols</code> specify columns for node attribute for child name. If columns are not specified, <code>child_col</code> takes first column, <code>parent_col</code> takes second column, and all other columns are <code>attribute_cols</code>.</p> <ul> <li>Only attributes in <code>attribute_cols</code> with non-null values will be added to the tree</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from bigtree import dataframe_to_tree_by_relation\n&gt;&gt;&gt; relation_data = pd.DataFrame([\n...     [\"a\", None, 90],\n...     [\"b\", \"a\", 65],\n...     [\"c\", \"a\", 60],\n...     [\"d\", \"b\", 40],\n...     [\"e\", \"b\", 35],\n...     [\"f\", \"c\", 38],\n...     [\"g\", \"e\", 10],\n...     [\"h\", \"e\", 6],\n... ],\n...     columns=[\"child\", \"parent\", \"age\"]\n... )\n&gt;&gt;&gt; root = dataframe_to_tree_by_relation(relation_data)\n&gt;&gt;&gt; root.show(attr_list=[\"age\"])\na [age=90]\n\u251c\u2500\u2500 b [age=65]\n\u2502   \u251c\u2500\u2500 d [age=40]\n\u2502   \u2514\u2500\u2500 e [age=35]\n\u2502       \u251c\u2500\u2500 g [age=10]\n\u2502       \u2514\u2500\u2500 h [age=6]\n\u2514\u2500\u2500 c [age=60]\n    \u2514\u2500\u2500 f [age=38]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>data containing path and node attribute information</p> required <code>child_col</code> <code>str</code> <p>column of data containing child name information, if not set, it will take the first column of data</p> <code>''</code> <code>parent_col</code> <code>str</code> <p>column of data containing parent name information, if not set, it will take the second column of data</p> <code>''</code> <code>attribute_cols</code> <code>List[str]</code> <p>columns of data containing node attribute information, if not set, it will take all columns of data except <code>child_col</code> and <code>parent_col</code></p> <code>[]</code> <code>allow_duplicates</code> <code>bool</code> <p>allow duplicate intermediate nodes such that child node will be tagged to multiple parent nodes</p> <code>False</code> <code>node_type</code> <code>Type[T]</code> <p>node type of tree to be created</p> <code>Node</code> <p>Returns:</p> Type Description <code>T</code> <p>Node</p>"},{"location":"bigtree/tree/construct/#bigtree.tree.construct.polars_to_tree","title":"polars_to_tree","text":"<pre><code>polars_to_tree(\n    data,\n    path_col=\"\",\n    attribute_cols=[],\n    sep=\"/\",\n    duplicate_name_allowed=True,\n    node_type=Node,\n)\n</code></pre> <p>Construct tree from polars DataFrame using path, return root of tree.</p> <p><code>path_col</code> and <code>attribute_cols</code> specify columns for node path and attributes to construct tree. If columns are not specified, <code>path_col</code> takes first column and all other columns are <code>attribute_cols</code>.</p> <ul> <li>Only attributes in <code>attribute_cols</code> with non-null values will be added to the tree</li> </ul> <p>Path in path column should contain <code>Node</code> name, separated by <code>sep</code>.</p> <ul> <li>For example: Path string \"a/b\" refers to Node(\"b\") with parent Node(\"a\")</li> </ul> <p>Path in path column can start from root node <code>name</code>, or start with <code>sep</code>.</p> <ul> <li>For example: Path string can be \"/a/b\" or \"a/b\", if sep is \"/\"</li> </ul> <p>All paths should start from the same root node.</p> <ul> <li>For example: Path strings should be \"a/b\", \"a/c\", \"a/b/d\" etc. and should not start with another root node</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from bigtree import polars_to_tree\n&gt;&gt;&gt; path_data = pl.DataFrame([\n...     [\"a\", 90],\n...     [\"a/b\", 65],\n...     [\"a/c\", 60],\n...     [\"a/b/d\", 40],\n...     [\"a/b/e\", 35],\n...     [\"a/c/f\", 38],\n...     [\"a/b/e/g\", 10],\n...     [\"a/b/e/h\", 6],\n... ],\n...     schema=[\"PATH\", \"age\"]\n... )\n&gt;&gt;&gt; root = polars_to_tree(path_data)\n&gt;&gt;&gt; root.show(attr_list=[\"age\"])\na [age=90]\n\u251c\u2500\u2500 b [age=65]\n\u2502   \u251c\u2500\u2500 d [age=40]\n\u2502   \u2514\u2500\u2500 e [age=35]\n\u2502       \u251c\u2500\u2500 g [age=10]\n\u2502       \u2514\u2500\u2500 h [age=6]\n\u2514\u2500\u2500 c [age=60]\n    \u2514\u2500\u2500 f [age=38]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>data containing path and node attribute information</p> required <code>path_col</code> <code>str</code> <p>column of data containing <code>path_name</code> information, if not set, it will take the first column of data</p> <code>''</code> <code>attribute_cols</code> <code>List[str]</code> <p>columns of data containing node attribute information, if not set, it will take all columns of data except <code>path_col</code></p> <code>[]</code> <code>sep</code> <code>str</code> <p>path separator of input <code>path_col</code> and created tree</p> <code>'/'</code> <code>duplicate_name_allowed</code> <code>bool</code> <p>indicator if nodes with duplicate <code>Node</code> name is allowed</p> <code>True</code> <code>node_type</code> <code>Type[T]</code> <p>node type of tree to be created</p> <code>Node</code> <p>Returns:</p> Type Description <code>T</code> <p>Node</p>"},{"location":"bigtree/tree/construct/#bigtree.tree.construct.polars_to_tree_by_relation","title":"polars_to_tree_by_relation","text":"<pre><code>polars_to_tree_by_relation(\n    data,\n    child_col=\"\",\n    parent_col=\"\",\n    attribute_cols=[],\n    allow_duplicates=False,\n    node_type=Node,\n)\n</code></pre> <p>Construct tree from polars DataFrame using parent and child names, return root of tree.</p> <p>Root node is inferred when parent name is empty, or when name appears in parent column but not in child column.</p> <p>Since tree is created from parent-child names, only names of leaf nodes may be repeated. Error will be thrown if names of intermediate nodes are repeated as there will be confusion. This error can be ignored by setting <code>allow_duplicates</code> to be True.</p> <p><code>child_col</code> and <code>parent_col</code> specify columns for child name and parent name to construct tree. <code>attribute_cols</code> specify columns for node attribute for child name. If columns are not specified, <code>child_col</code> takes first column, <code>parent_col</code> takes second column, and all other columns are <code>attribute_cols</code>.</p> <ul> <li>Only attributes in <code>attribute_cols</code> with non-null values will be added to the tree</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from bigtree import polars_to_tree_by_relation\n&gt;&gt;&gt; relation_data = pl.DataFrame([\n...     [\"a\", None, 90],\n...     [\"b\", \"a\", 65],\n...     [\"c\", \"a\", 60],\n...     [\"d\", \"b\", 40],\n...     [\"e\", \"b\", 35],\n...     [\"f\", \"c\", 38],\n...     [\"g\", \"e\", 10],\n...     [\"h\", \"e\", 6],\n... ],\n...     schema=[\"child\", \"parent\", \"age\"]\n... )\n&gt;&gt;&gt; root = polars_to_tree_by_relation(relation_data)\n&gt;&gt;&gt; root.show(attr_list=[\"age\"])\na [age=90]\n\u251c\u2500\u2500 b [age=65]\n\u2502   \u251c\u2500\u2500 d [age=40]\n\u2502   \u2514\u2500\u2500 e [age=35]\n\u2502       \u251c\u2500\u2500 g [age=10]\n\u2502       \u2514\u2500\u2500 h [age=6]\n\u2514\u2500\u2500 c [age=60]\n    \u2514\u2500\u2500 f [age=38]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>data containing path and node attribute information</p> required <code>child_col</code> <code>str</code> <p>column of data containing child name information, if not set, it will take the first column of data</p> <code>''</code> <code>parent_col</code> <code>str</code> <p>column of data containing parent name information, if not set, it will take the second column of data</p> <code>''</code> <code>attribute_cols</code> <code>List[str]</code> <p>columns of data containing node attribute information, if not set, it will take all columns of data except <code>child_col</code> and <code>parent_col</code></p> <code>[]</code> <code>allow_duplicates</code> <code>bool</code> <p>allow duplicate intermediate nodes such that child node will be tagged to multiple parent nodes</p> <code>False</code> <code>node_type</code> <code>Type[T]</code> <p>node type of tree to be created</p> <code>Node</code> <p>Returns:</p> Type Description <code>T</code> <p>Node</p>"},{"location":"bigtree/tree/construct/#bigtree.tree.construct.add_dict_to_tree_by_name","title":"add_dict_to_tree_by_name","text":"<pre><code>add_dict_to_tree_by_name(tree, name_attrs)\n</code></pre> <p>Add attributes to existing tree in-place. Adds to existing tree from nested dictionary, <code>key</code>: name, <code>value</code>: dict of attribute name and attribute value.</p> <p>All attributes in <code>name_attrs</code> will be added to the tree, including attributes with null values.</p> <p>Input dictionary keys that are not existing node names will be ignored. Note that if multiple nodes have the same name, attributes will be added to all nodes sharing the same name.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, add_dict_to_tree_by_name\n&gt;&gt;&gt; root = Node(\"a\")\n&gt;&gt;&gt; b = Node(\"b\", parent=root)\n&gt;&gt;&gt; name_dict = {\n...     \"a\": {\"age\": 90},\n...     \"b\": {\"age\": 65},\n... }\n&gt;&gt;&gt; root = add_dict_to_tree_by_name(root, name_dict)\n&gt;&gt;&gt; root.show(attr_list=[\"age\"])\na [age=90]\n\u2514\u2500\u2500 b [age=65]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>T</code> <p>existing tree</p> required <code>name_attrs</code> <code>Dict[str, Dict[str, Any]]</code> <p>dictionary containing node name and attribute information, key: node name, value: dict of node attribute name and attribute value</p> required <p>Returns:</p> Type Description <code>T</code> <p>Node</p>"},{"location":"bigtree/tree/construct/#bigtree.tree.construct.add_dict_to_tree_by_path","title":"add_dict_to_tree_by_path","text":"<pre><code>add_dict_to_tree_by_path(\n    tree, path_attrs, sep=\"/\", duplicate_name_allowed=True\n)\n</code></pre> <p>Add nodes and attributes to tree in-place, return root of tree. Adds to existing tree from nested dictionary, <code>key</code>: path, <code>value</code>: dict of attribute name and attribute value.</p> <p>All attributes in <code>path_attrs</code> will be added to the tree, including attributes with null values.</p> <p>Path should contain <code>Node</code> name, separated by <code>sep</code>.</p> <ul> <li>For example: Path string \"a/b\" refers to Node(\"b\") with parent Node(\"a\")</li> <li>Path separator <code>sep</code> is for the input <code>path</code> and can differ from existing tree</li> </ul> <p>Path can start from root node <code>name</code>, or start with <code>sep</code>.</p> <ul> <li>For example: Path string can be \"/a/b\" or \"a/b\", if sep is \"/\"</li> </ul> <p>All paths should start from the same root node.</p> <ul> <li>For example: Path strings should be \"a/b\", \"a/c\", \"a/b/d\" etc. and should not start with another root node</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, add_dict_to_tree_by_path\n&gt;&gt;&gt; root = Node(\"a\")\n&gt;&gt;&gt; path_dict = {\n...     \"a\": {\"age\": 90},\n...     \"a/b\": {\"age\": 65},\n...     \"a/c\": {\"age\": 60},\n...     \"a/b/d\": {\"age\": 40},\n...     \"a/b/e\": {\"age\": 35},\n...     \"a/c/f\": {\"age\": 38},\n...     \"a/b/e/g\": {\"age\": 10},\n...     \"a/b/e/h\": {\"age\": 6},\n... }\n&gt;&gt;&gt; root = add_dict_to_tree_by_path(root, path_dict)\n&gt;&gt;&gt; root.show()\na\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 d\n\u2502   \u2514\u2500\u2500 e\n\u2502       \u251c\u2500\u2500 g\n\u2502       \u2514\u2500\u2500 h\n\u2514\u2500\u2500 c\n    \u2514\u2500\u2500 f\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>T</code> <p>existing tree</p> required <code>path_attrs</code> <code>Dict[str, Dict[str, Any]]</code> <p>dictionary containing node path and attribute information, key: node path, value: dict of node attribute name and attribute value</p> required <code>sep</code> <code>str</code> <p>path separator for input <code>path_attrs</code></p> <code>'/'</code> <code>duplicate_name_allowed</code> <code>bool</code> <p>indicator if nodes with duplicate <code>Node</code> name is allowed</p> <code>True</code> <p>Returns:</p> Type Description <code>T</code> <p>Node</p>"},{"location":"bigtree/tree/construct/#bigtree.tree.construct.dict_to_tree","title":"dict_to_tree","text":"<pre><code>dict_to_tree(\n    path_attrs,\n    sep=\"/\",\n    duplicate_name_allowed=True,\n    node_type=Node,\n)\n</code></pre> <p>Construct tree from nested dictionary using path, <code>key</code>: path, <code>value</code>: dict of attribute name and attribute value.</p> <p>Path should contain <code>Node</code> name, separated by <code>sep</code>.</p> <ul> <li>For example: Path string \"a/b\" refers to Node(\"b\") with parent Node(\"a\")</li> </ul> <p>Path can start from root node <code>name</code>, or start with <code>sep</code>.</p> <ul> <li>For example: Path string can be \"/a/b\" or \"a/b\", if sep is \"/\"</li> </ul> <p>All paths should start from the same root node.</p> <ul> <li>For example: Path strings should be \"a/b\", \"a/c\", \"a/b/d\" etc. and should not start with another root node</li> </ul> <p>All attributes in <code>path_attrs</code> will be added to the tree, including attributes with null values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import dict_to_tree\n&gt;&gt;&gt; path_dict = {\n...     \"a\": {\"age\": 90},\n...     \"a/b\": {\"age\": 65},\n...     \"a/c\": {\"age\": 60},\n...     \"a/b/d\": {\"age\": 40},\n...     \"a/b/e\": {\"age\": 35},\n...     \"a/c/f\": {\"age\": 38},\n...     \"a/b/e/g\": {\"age\": 10},\n...     \"a/b/e/h\": {\"age\": 6},\n... }\n&gt;&gt;&gt; root = dict_to_tree(path_dict)\n&gt;&gt;&gt; root.show(attr_list=[\"age\"])\na [age=90]\n\u251c\u2500\u2500 b [age=65]\n\u2502   \u251c\u2500\u2500 d [age=40]\n\u2502   \u2514\u2500\u2500 e [age=35]\n\u2502       \u251c\u2500\u2500 g [age=10]\n\u2502       \u2514\u2500\u2500 h [age=6]\n\u2514\u2500\u2500 c [age=60]\n    \u2514\u2500\u2500 f [age=38]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>path_attrs</code> <code>Dict[str, Any]</code> <p>dictionary containing node path and attribute information, key: node path, value: dict of node attribute name and attribute value</p> required <code>sep</code> <code>str</code> <p>path separator of input <code>path_attrs</code> and created tree</p> <code>'/'</code> <code>duplicate_name_allowed</code> <code>bool</code> <p>indicator if nodes with duplicate <code>Node</code> name is allowed</p> <code>True</code> <code>node_type</code> <code>Type[T]</code> <p>node type of tree to be created</p> <code>Node</code> <p>Returns:</p> Type Description <code>T</code> <p>Node</p>"},{"location":"bigtree/tree/construct/#bigtree.tree.construct.nested_dict_to_tree","title":"nested_dict_to_tree","text":"<pre><code>nested_dict_to_tree(\n    node_attrs,\n    name_key=\"name\",\n    child_key=\"children\",\n    node_type=Node,\n)\n</code></pre> <p>Construct tree from nested recursive dictionary.</p> <ul> <li><code>key</code>: <code>name_key</code>, <code>child_key</code>, or any attributes key</li> <li><code>value</code> of <code>name_key</code>: node name</li> <li><code>value</code> of <code>child_key</code>: list of dict containing <code>name_key</code> and <code>child_key</code> (recursive)</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import nested_dict_to_tree\n&gt;&gt;&gt; path_dict = {\n...     \"name\": \"a\",\n...     \"age\": 90,\n...     \"children\": [\n...         {\"name\": \"b\",\n...          \"age\": 65,\n...          \"children\": [\n...              {\"name\": \"d\", \"age\": 40},\n...              {\"name\": \"e\", \"age\": 35, \"children\": [\n...                  {\"name\": \"g\", \"age\": 10},\n...              ]},\n...          ]},\n...     ],\n... }\n&gt;&gt;&gt; root = nested_dict_to_tree(path_dict)\n&gt;&gt;&gt; root.show(attr_list=[\"age\"])\na [age=90]\n\u2514\u2500\u2500 b [age=65]\n    \u251c\u2500\u2500 d [age=40]\n    \u2514\u2500\u2500 e [age=35]\n        \u2514\u2500\u2500 g [age=10]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>node_attrs</code> <code>Dict[str, Any]</code> <p>dictionary containing node, children, and node attribute information, key: <code>name_key</code> and <code>child_key</code> value of <code>name_key</code> (str): node name value of <code>child_key</code> (List[Dict[str, Any]]): list of dict containing <code>name_key</code> and <code>child_key</code> (recursive)</p> required <code>name_key</code> <code>str</code> <p>key of node name, value is type str</p> <code>'name'</code> <code>child_key</code> <code>str</code> <p>key of child list, value is type list</p> <code>'children'</code> <code>node_type</code> <code>Type[T]</code> <p>node type of tree to be created</p> <code>Node</code> <p>Returns:</p> Type Description <code>T</code> <p>Node</p>"},{"location":"bigtree/tree/construct/#bigtree.tree.construct.list_to_tree","title":"list_to_tree","text":"<pre><code>list_to_tree(\n    paths,\n    sep=\"/\",\n    duplicate_name_allowed=True,\n    node_type=Node,\n)\n</code></pre> <p>Construct tree from list of path strings.</p> <p>Path should contain <code>Node</code> name, separated by <code>sep</code>.</p> <ul> <li>For example: Path string \"a/b\" refers to Node(\"b\") with parent Node(\"a\")</li> </ul> <p>Path can start from root node <code>name</code>, or start with <code>sep</code>.</p> <ul> <li>For example: Path string can be \"/a/b\" or \"a/b\", if sep is \"/\"</li> </ul> <p>All paths should start from the same root node.</p> <ul> <li>For example: Path strings should be \"a/b\", \"a/c\", \"a/b/d\" etc. and should not start with another root node</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import list_to_tree\n&gt;&gt;&gt; path_list = [\"a/b\", \"a/c\", \"a/b/d\", \"a/b/e\", \"a/c/f\", \"a/b/e/g\", \"a/b/e/h\"]\n&gt;&gt;&gt; root = list_to_tree(path_list)\n&gt;&gt;&gt; root.show()\na\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 d\n\u2502   \u2514\u2500\u2500 e\n\u2502       \u251c\u2500\u2500 g\n\u2502       \u2514\u2500\u2500 h\n\u2514\u2500\u2500 c\n    \u2514\u2500\u2500 f\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>paths</code> <code>List[str]</code> <p>list containing path strings</p> required <code>sep</code> <code>str</code> <p>path separator for input <code>paths</code> and created tree</p> <code>'/'</code> <code>duplicate_name_allowed</code> <code>bool</code> <p>indicator if nodes with duplicate <code>Node</code> name is allowed</p> <code>True</code> <code>node_type</code> <code>Type[T]</code> <p>node type of tree to be created</p> <code>Node</code> <p>Returns:</p> Type Description <code>T</code> <p>Node</p>"},{"location":"bigtree/tree/construct/#bigtree.tree.construct.list_to_tree_by_relation","title":"list_to_tree_by_relation","text":"<pre><code>list_to_tree_by_relation(\n    relations, allow_duplicates=False, node_type=Node\n)\n</code></pre> <p>Construct tree from list of tuple containing parent-child names.</p> <p>Root node is inferred when parent is empty, or when name appears as parent but not as child.</p> <p>Since tree is created from parent-child names, only names of leaf nodes may be repeated. Error will be thrown if names of intermediate nodes are repeated as there will be confusion. This error can be ignored by setting <code>allow_duplicates</code> to be True.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import list_to_tree_by_relation\n&gt;&gt;&gt; relations_list = [(\"a\", \"b\"), (\"a\", \"c\"), (\"b\", \"d\"), (\"b\", \"e\"), (\"c\", \"f\"), (\"e\", \"g\"), (\"e\", \"h\")]\n&gt;&gt;&gt; root = list_to_tree_by_relation(relations_list)\n&gt;&gt;&gt; root.show()\na\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 d\n\u2502   \u2514\u2500\u2500 e\n\u2502       \u251c\u2500\u2500 g\n\u2502       \u2514\u2500\u2500 h\n\u2514\u2500\u2500 c\n    \u2514\u2500\u2500 f\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>relations</code> <code>List[Tuple[str, str]]</code> <p>list containing tuple containing parent-child names</p> required <code>allow_duplicates</code> <p>allow duplicate intermediate nodes such that child node will be tagged to multiple parent nodes</p> <code>False</code> <code>node_type</code> <code>Type[T]</code> <p>node type of tree to be created</p> <code>Node</code> <p>Returns:</p> Type Description <code>T</code> <p>Node</p>"},{"location":"bigtree/tree/construct/#bigtree.tree.construct.add_path_to_tree","title":"add_path_to_tree","text":"<pre><code>add_path_to_tree(\n    tree,\n    path,\n    sep=\"/\",\n    duplicate_name_allowed=True,\n    node_attrs={},\n)\n</code></pre> <p>Add nodes and attributes to existing tree in-place, return node of path added. Adds to existing tree from list of path strings.</p> <p>Path should contain <code>Node</code> name, separated by <code>sep</code>.</p> <ul> <li>For example: Path string \"a/b\" refers to Node(\"b\") with parent Node(\"a\")</li> <li>Path separator <code>sep</code> is for the input <code>path</code> and can differ from existing tree</li> </ul> <p>Path can start from root node <code>name</code>, or start with <code>sep</code>.</p> <ul> <li>For example: Path string can be \"/a/b\" or \"a/b\", if sep is \"/\"</li> </ul> <p>All paths should start from the same root node.</p> <ul> <li>For example: Path strings should be \"a/b\", \"a/c\", \"a/b/d\" etc. and should not start with another root node</li> </ul> <p>All attributes in <code>node_attrs</code> will be added to the tree, including attributes with null values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import add_path_to_tree, Node\n&gt;&gt;&gt; root = Node(\"a\")\n&gt;&gt;&gt; add_path_to_tree(root, \"a/b/c\")\nNode(/a/b/c, )\n&gt;&gt;&gt; root.show()\na\n\u2514\u2500\u2500 b\n    \u2514\u2500\u2500 c\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>T</code> <p>existing tree</p> required <code>path</code> <code>str</code> <p>path to be added to tree</p> required <code>sep</code> <code>str</code> <p>path separator for input <code>path</code></p> <code>'/'</code> <code>duplicate_name_allowed</code> <code>bool</code> <p>indicator if nodes with duplicate <code>Node</code> name is allowed</p> <code>True</code> <code>node_attrs</code> <code>Dict[str, Any]</code> <p>attributes to add to node, key: attribute name, value: attribute value</p> <code>{}</code> <p>Returns:</p> Type Description <code>T</code> <p>Node</p>"},{"location":"bigtree/tree/construct/#bigtree.tree.construct.newick_to_tree","title":"newick_to_tree","text":"<pre><code>newick_to_tree(\n    tree_string,\n    length_attr=\"length\",\n    attr_prefix=\"&amp;&amp;NHX:\",\n    node_type=Node,\n)\n</code></pre> <p>Construct tree from Newick notation, return root of tree.</p> <p>In the Newick Notation (or New Hampshire Notation)</p> <ul> <li>Tree is represented in round brackets i.e., <code>(child1,child2,child3)parent</code></li> <li>If there are nested trees, they will be in nested round brackets i.e., <code>((grandchild1)child1,(grandchild2,grandchild3)child2)parent</code></li> <li>If there is length attribute, they will be beside the name i.e., <code>(child1:0.5,child2:0.1)parent</code></li> <li>If there are other attributes, attributes are represented in square brackets i.e., <code>(child1:0.5[S:human],child2:0.1[S:human])parent[S:parent]</code></li> </ul> <p>Variations supported</p> <ul> <li>Support special characters (<code>[</code>, <code>]</code>, <code>(</code>, <code>)</code>, <code>:</code>, <code>,</code>) in node name, attribute name, and attribute values if     they are enclosed in single quotes i.e., '(name:!)'</li> <li>If there are no node names, it will be auto-filled with convention <code>nodeN</code> with N representing a number</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import newick_to_tree\n&gt;&gt;&gt; root = newick_to_tree(\"((d,e)b,c)a\")\n&gt;&gt;&gt; root.show()\na\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 d\n\u2502   \u2514\u2500\u2500 e\n\u2514\u2500\u2500 c\n</code></pre> <pre><code>&gt;&gt;&gt; root = newick_to_tree(\"((d:40,e:35)b:65,c:60)a\", length_attr=\"age\")\n&gt;&gt;&gt; root.show(attr_list=[\"age\"])\na\n\u251c\u2500\u2500 b [age=65]\n\u2502   \u251c\u2500\u2500 d [age=40]\n\u2502   \u2514\u2500\u2500 e [age=35]\n\u2514\u2500\u2500 c [age=60]\n</code></pre> <pre><code>&gt;&gt;&gt; root = newick_to_tree(\n...     \"((d:40[&amp;&amp;NHX:species=human],e:35[&amp;&amp;NHX:species=human])b:65[&amp;&amp;NHX:species=human],c:60[&amp;&amp;NHX:species=human])a[&amp;&amp;NHX:species=human]\",\n...     length_attr=\"age\",\n... )\n&gt;&gt;&gt; root.show(all_attrs=True)\na [species=human]\n\u251c\u2500\u2500 b [age=65, species=human]\n\u2502   \u251c\u2500\u2500 d [age=40, species=human]\n\u2502   \u2514\u2500\u2500 e [age=35, species=human]\n\u2514\u2500\u2500 c [age=60, species=human]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree_string</code> <code>str</code> <p>Newick notation to construct tree</p> required <code>length_attr</code> <code>str</code> <p>attribute name to store node length, optional</p> <code>'length'</code> <code>attr_prefix</code> <code>str</code> <p>prefix before all attributes, within square bracket, used to detect attributes</p> <code>'&amp;&amp;NHX:'</code> <code>node_type</code> <code>Type[T]</code> <p>node type of tree to be created</p> <code>Node</code> <p>Returns:</p> Type Description <code>T</code> <p>Node</p>"},{"location":"bigtree/tree/construct/#bigtree.tree.construct.str_to_tree","title":"str_to_tree","text":"<pre><code>str_to_tree(\n    tree_string, tree_prefix_list=[], node_type=Node\n)\n</code></pre> <p>Construct tree from tree string.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import str_to_tree\n&gt;&gt;&gt; tree_str = 'a\\n\u251c\u2500\u2500 b\\n\u2502   \u251c\u2500\u2500 d\\n\u2502   \u2514\u2500\u2500 e\\n\u2502       \u251c\u2500\u2500 g\\n\u2502       \u2514\u2500\u2500 h\\n\u2514\u2500\u2500 c\\n    \u2514\u2500\u2500 f'\n&gt;&gt;&gt; root = str_to_tree(tree_str, tree_prefix_list=[\"\u251c\u2500\u2500\", \"\u2514\u2500\u2500\"])\n&gt;&gt;&gt; root.show()\na\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 d\n\u2502   \u2514\u2500\u2500 e\n\u2502       \u251c\u2500\u2500 g\n\u2502       \u2514\u2500\u2500 h\n\u2514\u2500\u2500 c\n    \u2514\u2500\u2500 f\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree_string</code> <code>str</code> <p>String to construct tree</p> required <code>tree_prefix_list</code> <code>List[str]</code> <p>List of prefix to mark the end of tree branch/stem and start of node name, optional. If not specified, it will infer unicode characters and whitespace as prefix</p> <code>[]</code> <code>node_type</code> <code>Type[T]</code> <p>node type of tree to be created</p> <code>Node</code> <p>Returns:</p> Type Description <code>T</code> <p>Node</p>"},{"location":"bigtree/tree/export/","title":"\ud83d\udd28 Export","text":""},{"location":"bigtree/tree/export/#tree-export-methods","title":"Tree Export Methods","text":"<p>Export Tree to list, dictionary, and pandas DataFrame.</p> Export Tree to Method Command Line / Print <code>print_tree</code>, <code>hprint_tree</code>, <code>vprint_tree</code> Generator (versatile) <code>yield_tree</code>, <code>hyield_tree</code>, <code>vyield_tree</code> String <code>tree_to_newick</code> Dictionary <code>tree_to_dict</code>, <code>tree_to_nested_dict</code> DataFrame (pandas, polars) <code>tree_to_dataframe</code>, <code>tree_to_polars</code> Dot (for .dot, .png, .svg, .jpeg, etc.) <code>tree_to_dot</code> Pillow (for .png, .jpg, .jpeg, etc.) <code>tree_to_pillow</code>, <code>tree_to_pillow_graph</code> Mermaid Markdown (for .md) <code>tree_to_mermaid</code>"},{"location":"bigtree/tree/export/#tree-export-customisations","title":"Tree Export Customisations","text":"<p>While exporting to another data type, methods can take in arguments to determine what information to extract.</p> Method Extract node attributes Specify maximum depth Skip depth Extract leaves only Others <code>print_tree</code> Yes with <code>attr_list</code> or <code>all_attrs</code> Yes No No Tree style <code>yield_tree</code> No, returns node Yes No No Tree style <code>hprint_tree</code> No Yes No Yes, by hiding intermediate node name Tree style, border style <code>hyield_tree</code> No Yes No Yes, by hiding intermediate node name Tree style, border style <code>vprint_tree</code> No Yes No Yes, by hiding intermediate node name Tree style, border style <code>vyield_tree</code> No Yes No Yes, by hiding intermediate node name Tree style, border style <code>tree_to_newick</code> Yes with <code>attr_list</code> No No Yes, by hiding intermediate node name Length separator and attribute prefix and separator <code>tree_to_dict</code> Yes with <code>attr_dict</code> or <code>all_attrs</code> Yes Yes Yes with <code>leaf_only</code> Dict key for parent <code>tree_to_nested_dict</code> Yes with <code>attr_dict</code> or <code>all_attrs</code> Yes No No Dict key for node name and node children <code>tree_to_dataframe</code> Yes with <code>attr_dict</code> or <code>all_attrs</code> Yes Yes Yes with <code>leaf_only</code> Column name for path, node name, node parent <code>tree_to_polars</code> Yes with <code>attr_dict</code> or <code>all_attrs</code> Yes Yes Yes with <code>leaf_only</code> Column name for path, node name, node parent <code>tree_to_dot</code> No No No No Graph attributes, background, node, edge colour, etc. <code>tree_to_pillow_graph</code> Yes with <code>node_content</code> Yes No No Font (family, size, colour), background colour, etc. <code>tree_to_pillow</code> No Yes No No Font (family, size, colour), background colour, etc. <code>tree_to_mermaid</code> No Yes No No Node shape, node fill, edge arrow, edge label etc."},{"location":"bigtree/tree/export/#bigtree.tree.export","title":"bigtree.tree.export","text":""},{"location":"bigtree/tree/export/#bigtree.tree.export.tree_to_dataframe","title":"tree_to_dataframe","text":"<pre><code>tree_to_dataframe(\n    tree,\n    path_col=\"path\",\n    name_col=\"name\",\n    parent_col=\"\",\n    attr_dict={},\n    all_attrs=False,\n    max_depth=0,\n    skip_depth=0,\n    leaf_only=False,\n)\n</code></pre> <p>Export tree to pandas DataFrame.</p> <p>All descendants from <code>tree</code> will be exported, <code>tree</code> can be the root node or child node of tree.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, tree_to_dataframe\n&gt;&gt;&gt; root = Node(\"a\", age=90)\n&gt;&gt;&gt; b = Node(\"b\", age=65, parent=root)\n&gt;&gt;&gt; c = Node(\"c\", age=60, parent=root)\n&gt;&gt;&gt; d = Node(\"d\", age=40, parent=b)\n&gt;&gt;&gt; e = Node(\"e\", age=35, parent=b)\n&gt;&gt;&gt; tree_to_dataframe(root, name_col=\"name\", parent_col=\"parent\", path_col=\"path\", attr_dict={\"age\": \"person age\"})\n     path name parent  person age\n0      /a    a   None          90\n1    /a/b    b      a          65\n2  /a/b/d    d      b          40\n3  /a/b/e    e      b          35\n4    /a/c    c      a          60\n</code></pre> <p>For a subset of a tree.</p> <pre><code>&gt;&gt;&gt; tree_to_dataframe(b, name_col=\"name\", parent_col=\"parent\", path_col=\"path\", attr_dict={\"age\": \"person age\"})\n     path name parent  person age\n0    /a/b    b      a          65\n1  /a/b/d    d      b          40\n2  /a/b/e    e      b          35\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>T</code> <p>tree to be exported</p> required <code>path_col</code> <code>str</code> <p>column name for <code>node.path_name</code></p> <code>'path'</code> <code>name_col</code> <code>str</code> <p>column name for <code>node.node_name</code></p> <code>'name'</code> <code>parent_col</code> <code>str</code> <p>column name for <code>node.parent.node_name</code></p> <code>''</code> <code>attr_dict</code> <code>Dict[str, str]</code> <p>dictionary mapping node attributes to column name, key: node attributes, value: corresponding column in dataframe</p> <code>{}</code> <code>all_attrs</code> <code>bool</code> <p>indicator whether to retrieve all <code>Node</code> attributes, overrides <code>attr_dict</code></p> <code>False</code> <code>max_depth</code> <code>int</code> <p>maximum depth to export tree</p> <code>0</code> <code>skip_depth</code> <code>int</code> <p>number of initial depths to skip</p> <code>0</code> <code>leaf_only</code> <code>bool</code> <p>indicator to retrieve only information from leaf nodes</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pandas DataFrame containing tree information</p>"},{"location":"bigtree/tree/export/#bigtree.tree.export.tree_to_polars","title":"tree_to_polars","text":"<pre><code>tree_to_polars(\n    tree,\n    path_col=\"path\",\n    name_col=\"name\",\n    parent_col=\"\",\n    attr_dict={},\n    all_attrs=False,\n    max_depth=0,\n    skip_depth=0,\n    leaf_only=False,\n)\n</code></pre> <p>Export tree to polars DataFrame.</p> <p>All descendants from <code>tree</code> will be exported, <code>tree</code> can be the root node or child node of tree.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, tree_to_polars\n&gt;&gt;&gt; root = Node(\"a\", age=90)\n&gt;&gt;&gt; b = Node(\"b\", age=65, parent=root)\n&gt;&gt;&gt; c = Node(\"c\", age=60, parent=root)\n&gt;&gt;&gt; d = Node(\"d\", age=40, parent=b)\n&gt;&gt;&gt; e = Node(\"e\", age=35, parent=b)\n&gt;&gt;&gt; tree_to_polars(root, name_col=\"name\", parent_col=\"parent\", path_col=\"path\", attr_dict={\"age\": \"person age\"})\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 path   \u2506 name \u2506 parent \u2506 person age \u2502\n\u2502 ---    \u2506 ---  \u2506 ---    \u2506 ---        \u2502\n\u2502 str    \u2506 str  \u2506 str    \u2506 i64        \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 /a     \u2506 a    \u2506 null   \u2506 90         \u2502\n\u2502 /a/b   \u2506 b    \u2506 a      \u2506 65         \u2502\n\u2502 /a/b/d \u2506 d    \u2506 b      \u2506 40         \u2502\n\u2502 /a/b/e \u2506 e    \u2506 b      \u2506 35         \u2502\n\u2502 /a/c   \u2506 c    \u2506 a      \u2506 60         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>For a subset of a tree.</p> <pre><code>&gt;&gt;&gt; tree_to_polars(b, name_col=\"name\", parent_col=\"parent\", path_col=\"path\", attr_dict={\"age\": \"person age\"})\nshape: (3, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 path   \u2506 name \u2506 parent \u2506 person age \u2502\n\u2502 ---    \u2506 ---  \u2506 ---    \u2506 ---        \u2502\n\u2502 str    \u2506 str  \u2506 str    \u2506 i64        \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 /a/b   \u2506 b    \u2506 a      \u2506 65         \u2502\n\u2502 /a/b/d \u2506 d    \u2506 b      \u2506 40         \u2502\n\u2502 /a/b/e \u2506 e    \u2506 b      \u2506 35         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>T</code> <p>tree to be exported</p> required <code>path_col</code> <code>str</code> <p>column name for <code>node.path_name</code></p> <code>'path'</code> <code>name_col</code> <code>str</code> <p>column name for <code>node.node_name</code></p> <code>'name'</code> <code>parent_col</code> <code>str</code> <p>column name for <code>node.parent.node_name</code></p> <code>''</code> <code>attr_dict</code> <code>Dict[str, str]</code> <p>dictionary mapping node attributes to column name, key: node attributes, value: corresponding column in dataframe</p> <code>{}</code> <code>all_attrs</code> <code>bool</code> <p>indicator whether to retrieve all <code>Node</code> attributes, overrides <code>attr_dict</code></p> <code>False</code> <code>max_depth</code> <code>int</code> <p>maximum depth to export tree</p> <code>0</code> <code>skip_depth</code> <code>int</code> <p>number of initial depths to skip</p> <code>0</code> <code>leaf_only</code> <code>bool</code> <p>indicator to retrieve only information from leaf nodes</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>polars DataFrame containing tree information</p>"},{"location":"bigtree/tree/export/#bigtree.tree.export.tree_to_dict","title":"tree_to_dict","text":"<pre><code>tree_to_dict(\n    tree,\n    name_key=\"name\",\n    parent_key=\"\",\n    attr_dict={},\n    all_attrs=False,\n    max_depth=0,\n    skip_depth=0,\n    leaf_only=False,\n)\n</code></pre> <p>Export tree to dictionary.</p> <p>All descendants from <code>tree</code> will be exported, <code>tree</code> can be the root node or child node of tree.</p> <p>Exported dictionary will have key as node path, and node attributes as a nested dictionary.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, tree_to_dict\n&gt;&gt;&gt; root = Node(\"a\", age=90)\n&gt;&gt;&gt; b = Node(\"b\", age=65, parent=root)\n&gt;&gt;&gt; c = Node(\"c\", age=60, parent=root)\n&gt;&gt;&gt; d = Node(\"d\", age=40, parent=b)\n&gt;&gt;&gt; e = Node(\"e\", age=35, parent=b)\n&gt;&gt;&gt; tree_to_dict(root, name_key=\"name\", parent_key=\"parent\", attr_dict={\"age\": \"person age\"})\n{'/a': {'name': 'a', 'parent': None, 'person age': 90}, '/a/b': {'name': 'b', 'parent': 'a', 'person age': 65}, '/a/b/d': {'name': 'd', 'parent': 'b', 'person age': 40}, '/a/b/e': {'name': 'e', 'parent': 'b', 'person age': 35}, '/a/c': {'name': 'c', 'parent': 'a', 'person age': 60}}\n</code></pre> <p>For a subset of a tree</p> <pre><code>&gt;&gt;&gt; tree_to_dict(c, name_key=\"name\", parent_key=\"parent\", attr_dict={\"age\": \"person age\"})\n{'/a/c': {'name': 'c', 'parent': 'a', 'person age': 60}}\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>T</code> <p>tree to be exported</p> required <code>name_key</code> <code>str</code> <p>dictionary key for <code>node.node_name</code></p> <code>'name'</code> <code>parent_key</code> <code>str</code> <p>dictionary key for <code>node.parent.node_name</code></p> <code>''</code> <code>attr_dict</code> <code>Dict[str, str]</code> <p>dictionary mapping node attributes to dictionary key, key: node attributes, value: corresponding dictionary key</p> <code>{}</code> <code>all_attrs</code> <code>bool</code> <p>indicator whether to retrieve all <code>Node</code> attributes, overrides <code>attr_dict</code></p> <code>False</code> <code>max_depth</code> <code>int</code> <p>maximum depth to export tree</p> <code>0</code> <code>skip_depth</code> <code>int</code> <p>number of initial depths to skip</p> <code>0</code> <code>leaf_only</code> <code>bool</code> <p>indicator to retrieve only information from leaf nodes</p> <code>False</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary containing tree information</p>"},{"location":"bigtree/tree/export/#bigtree.tree.export.tree_to_nested_dict","title":"tree_to_nested_dict","text":"<pre><code>tree_to_nested_dict(\n    tree,\n    name_key=\"name\",\n    child_key=\"children\",\n    attr_dict={},\n    all_attrs=False,\n    max_depth=0,\n)\n</code></pre> <p>Export tree to nested dictionary.</p> <p>All descendants from <code>tree</code> will be exported, <code>tree</code> can be the root node or child node of tree.</p> <p>Exported dictionary will have key as node attribute names, and children as a nested recursive dictionary.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, tree_to_nested_dict\n&gt;&gt;&gt; root = Node(\"a\", age=90)\n&gt;&gt;&gt; b = Node(\"b\", age=65, parent=root)\n&gt;&gt;&gt; c = Node(\"c\", age=60, parent=root)\n&gt;&gt;&gt; d = Node(\"d\", age=40, parent=b)\n&gt;&gt;&gt; e = Node(\"e\", age=35, parent=b)\n&gt;&gt;&gt; tree_to_nested_dict(root, all_attrs=True)\n{'name': 'a', 'age': 90, 'children': [{'name': 'b', 'age': 65, 'children': [{'name': 'd', 'age': 40}, {'name': 'e', 'age': 35}]}, {'name': 'c', 'age': 60}]}\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>T</code> <p>tree to be exported</p> required <code>name_key</code> <code>str</code> <p>dictionary key for <code>node.node_name</code></p> <code>'name'</code> <code>child_key</code> <code>str</code> <p>dictionary key for list of children</p> <code>'children'</code> <code>attr_dict</code> <code>Dict[str, str]</code> <p>dictionary mapping node attributes to dictionary key, key: node attributes, value: corresponding dictionary key</p> <code>{}</code> <code>all_attrs</code> <code>bool</code> <p>indicator whether to retrieve all <code>Node</code> attributes, overrides <code>attr_dict</code></p> <code>False</code> <code>max_depth</code> <code>int</code> <p>maximum depth to export tree</p> <code>0</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary containing tree information</p>"},{"location":"bigtree/tree/export/#bigtree.tree.export.tree_to_dot","title":"tree_to_dot","text":"<pre><code>tree_to_dot(\n    tree,\n    directed=True,\n    rankdir=\"TB\",\n    bg_colour=\"\",\n    node_colour=\"\",\n    node_shape=\"\",\n    edge_colour=\"\",\n    node_attr=\"\",\n    edge_attr=\"\",\n)\n</code></pre> <p>Export tree or list of trees to pydot.Dot object. Object can be converted to other format, such as png, dot file or dot string. Dot string can be imported to work with networkx.</p> <p>Possible node attributes include style, fillcolor, shape.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, tree_to_dot\n&gt;&gt;&gt; root = Node(\"a\", age=90)\n&gt;&gt;&gt; b = Node(\"b\", age=65, parent=root)\n&gt;&gt;&gt; c = Node(\"c\", age=60, parent=root)\n&gt;&gt;&gt; d = Node(\"d\", age=40, parent=b)\n&gt;&gt;&gt; e = Node(\"e\", age=35, parent=b)\n&gt;&gt;&gt; graph = tree_to_dot(root)\n</code></pre> <p>Display image directly without saving (requires IPython)</p> <pre><code>&gt;&gt;&gt; from IPython.display import Image, display\n&gt;&gt;&gt; plt = Image(graph.create_png())\n&gt;&gt;&gt; display(plt)\n&lt;IPython.core.display.Image object&gt;\n</code></pre> <p>Export to image, dot file, etc.</p> <pre><code>&gt;&gt;&gt; graph.write_png(\"assets/tree.png\")\n&gt;&gt;&gt; graph.write_dot(\"assets/tree.dot\")\n</code></pre> <p></p> <p>Export to string</p> <pre><code>&gt;&gt;&gt; graph.to_string()\n'strict digraph G {\\nrankdir=TB;\\na0 [label=a];\\nb0 [label=b];\\na0 -&gt; b0;\\nd0 [label=d];\\nb0 -&gt; d0;\\ne0 [label=e];\\nb0 -&gt; e0;\\nc0 [label=c];\\na0 -&gt; c0;\\n}\\n'\n</code></pre> <p>Defining node and edge attributes (using node attribute)</p> <pre><code>&gt;&gt;&gt; class CustomNode(Node):\n...     def __init__(self, name, node_shape=\"\", edge_label=\"\", **kwargs):\n...         super().__init__(name, **kwargs)\n...         self.node_shape = node_shape\n...         self.edge_label = edge_label\n...\n...     @property\n...     def edge_attr(self):\n...         if self.edge_label:\n...             return {\"label\": self.edge_label}\n...         return {}\n...\n...     @property\n...     def node_attr(self):\n...         if self.node_shape:\n...             return {\"shape\": self.node_shape}\n...         return {}\n&gt;&gt;&gt;\n&gt;&gt;&gt;\n&gt;&gt;&gt; root = CustomNode(\"a\", node_shape=\"circle\")\n&gt;&gt;&gt; b = CustomNode(\"b\", edge_label=\"child\", parent=root)\n&gt;&gt;&gt; c = CustomNode(\"c\", edge_label=\"child\", parent=root)\n&gt;&gt;&gt; d = CustomNode(\"d\", node_shape=\"square\", edge_label=\"child\", parent=b)\n&gt;&gt;&gt; e = CustomNode(\"e\", node_shape=\"square\", edge_label=\"child\", parent=b)\n&gt;&gt;&gt; graph = tree_to_dot(root, node_colour=\"gold\", node_shape=\"diamond\", node_attr=\"node_attr\", edge_attr=\"edge_attr\")\n&gt;&gt;&gt; graph.write_png(\"assets/export_tree_dot.png\")\n</code></pre> <p></p> <p>Alternative way to define node and edge attributes (using callable function)</p> <pre><code>&gt;&gt;&gt; def get_node_attribute(node: Node):\n...     if node.is_leaf:\n...         return {\"shape\": \"square\"}\n...     return {\"shape\": \"circle\"}\n&gt;&gt;&gt;\n&gt;&gt;&gt;\n&gt;&gt;&gt; root = CustomNode(\"a\")\n&gt;&gt;&gt; b = CustomNode(\"b\", parent=root)\n&gt;&gt;&gt; c = CustomNode(\"c\", parent=root)\n&gt;&gt;&gt; d = CustomNode(\"d\", parent=b)\n&gt;&gt;&gt; e = CustomNode(\"e\", parent=b)\n&gt;&gt;&gt; graph = tree_to_dot(root, node_colour=\"gold\", node_attr=get_node_attribute)\n&gt;&gt;&gt; graph.write_png(\"assets/export_tree_dot_callable.png\")\n</code></pre> <p></p> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>Union[T, List[T]]</code> <p>tree or list of trees to be exported</p> required <code>directed</code> <code>bool</code> <p>indicator whether graph should be directed or undirected</p> <code>True</code> <code>rankdir</code> <code>str</code> <p>layout direction, accepts 'TB' (top to bottom), 'BT' (bottom to top), 'LR' (left to right), or 'RL' (right to left)</p> <code>'TB'</code> <code>bg_colour</code> <code>str</code> <p>background color of image</p> <code>''</code> <code>node_colour</code> <code>str</code> <p>fill colour of nodes</p> <code>''</code> <code>node_shape</code> <code>str</code> <p>shape of nodes. Possible node_shape include \"circle\", \"square\", \"diamond\", \"triangle\"</p> <code>''</code> <code>edge_colour</code> <code>str</code> <p>colour of edges</p> <code>''</code> <code>node_attr</code> <code>Callable[[T], Dict[str, Any]] | str</code> <p>If string type, it refers to <code>Node</code> attribute for node style. If callable type, it takes in the node itself and returns the node style. This overrides <code>node_colour</code> and <code>node_shape</code>. Possible node styles include {\"style\": \"filled\", \"fillcolor\": \"gold\", \"shape\": \"diamond\"}</p> <code>''</code> <code>edge_attr</code> <code>Callable[[T], Dict[str, Any]] | str</code> <p>If string type, it refers to <code>Node</code> attribute for edge style. If callable type, it takes in the node itself and returns the edge style. This overrides <code>edge_colour</code>. Possible edge styles include</p> <code>''</code> <p>Returns:</p> Type Description <code>Dot</code> <p>Dot object of tree</p>"},{"location":"bigtree/tree/export/#bigtree.tree.export.tree_to_mermaid","title":"tree_to_mermaid","text":"<pre><code>tree_to_mermaid(\n    tree,\n    title=\"\",\n    theme=None,\n    rankdir=\"TB\",\n    line_shape=\"basis\",\n    node_colour=\"\",\n    node_border_colour=\"\",\n    node_border_width=1,\n    node_shape=\"rounded_edge\",\n    node_shape_attr=\"\",\n    edge_arrow=\"normal\",\n    edge_arrow_attr=\"\",\n    edge_label=\"\",\n    node_attr=\"\",\n    **kwargs\n)\n</code></pre> <p>Export tree to mermaid Markdown text. Accepts additional keyword arguments as input to <code>yield_tree</code>.</p> Parameters for customisations that apply to entire flowchart include <ul> <li>Title, <code>title</code></li> <li>Theme, <code>theme</code></li> <li>Layout direction, <code>rankdir</code></li> <li>Line shape or curvature, <code>line_shape</code></li> <li>Fill colour of nodes, <code>node_colour</code></li> <li>Border colour of nodes, <code>node_border_colour</code></li> <li>Border width of nodes, <code>node_border_width</code></li> <li>Node shape, <code>node_shape</code></li> <li>Edge arrow style, <code>edge_arrow</code></li> </ul> Parameters for customisations that apply to customised nodes <ul> <li>Fill colour of nodes, fill under <code>node_attr</code></li> <li>Border colour of nodes, stroke under <code>node_attr</code></li> <li>Border width of nodes, stroke-width under <code>node_attr</code></li> <li>Node shape, <code>node_shape_attr</code></li> <li>Edge arrow style, <code>edge_arrow_attr</code></li> <li>Edge label, <code>edge_label</code></li> </ul> <p>Accepted Parameter Values</p> Possible theme <ul> <li>default</li> <li>neutral: great for black and white documents</li> <li>dark: great for dark-mode</li> <li>forest: shades of geen</li> <li>base: theme that can be modified, use it for customisations</li> </ul> Possible rankdir <ul> <li><code>TB</code>: top-to-bottom</li> <li><code>BT</code>: bottom-to-top</li> <li><code>LR</code>: left-to-right</li> <li><code>RL</code>: right-to-left</li> </ul> Possible line_shape <ul> <li><code>basis</code></li> <li><code>bumpX</code>: used in LR or RL direction</li> <li><code>bumpY</code></li> <li><code>cardinal</code>: undirected</li> <li><code>catmullRom</code>: undirected</li> <li><code>linear</code>:</li> <li><code>monotoneX</code>: used in LR or RL direction</li> <li><code>monotoneY</code></li> <li><code>natural</code></li> <li><code>step</code>: used in LR or RL direction</li> <li><code>stepAfter</code></li> <li><code>stepBefore</code>: used in LR or RL direction</li> </ul> Possible node_shape <ul> <li><code>rounded_edge</code>: rectangular with rounded edges</li> <li><code>stadium</code>: (_) shape, rectangular with rounded ends</li> <li><code>subroutine</code>: ||_|| shape, rectangular with additional line at the ends</li> <li><code>cylindrical</code>: database node</li> <li><code>circle</code>: circular</li> <li><code>asymmetric</code>: &gt;_| shape</li> <li><code>rhombus</code>: decision node</li> <li><code>hexagon</code>: &lt;_&gt; shape</li> <li><code>parallelogram</code>: /_/ shape</li> <li><code>parallelogram_alt</code>: \\_\\ shape, inverted parallelogram</li> <li><code>trapezoid</code>: /_\\ shape</li> <li><code>trapezoid_alt</code>: \\_/ shape, inverted trapezoid</li> <li><code>double_circle</code></li> </ul> Possible edge_arrow <ul> <li><code>normal</code>: directed arrow, shaded arrowhead</li> <li><code>bold</code>: bold directed arrow</li> <li><code>dotted</code>: dotted directed arrow</li> <li><code>open</code>: line, undirected arrow</li> <li><code>bold_open</code>: bold line</li> <li><code>dotted_open</code>: dotted line</li> <li><code>invisible</code>: no line</li> <li><code>circle</code>: directed arrow with filled circle arrowhead</li> <li><code>cross</code>: directed arrow with cross arrowhead</li> <li><code>double_normal</code>: bidirectional directed arrow</li> <li><code>double_circle</code>: bidirectional directed arrow with filled circle arrowhead</li> <li><code>double_cross</code>: bidirectional directed arrow with cross arrowhead</li> </ul> <p>Refer to mermaid documentation for more information. Paste the output into any markdown file renderer to view the flowchart, alternatively visit the mermaid playground here.</p> <p>Note</p> <p>Advanced mermaid flowchart functionalities such as subgraphs and interactions (script, click) are not supported.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import tree_to_mermaid\n&gt;&gt;&gt; root = Node(\"a\", node_shape=\"rhombus\")\n&gt;&gt;&gt; b = Node(\"b\", edge_arrow=\"bold\", edge_label=\"Child 1\", parent=root)\n&gt;&gt;&gt; c = Node(\"c\", edge_arrow=\"dotted\", edge_label=\"Child 2\", parent=root)\n&gt;&gt;&gt; d = Node(\"d\", node_style=\"fill:yellow, stroke:black\", parent=b)\n&gt;&gt;&gt; e = Node(\"e\", parent=b)\n&gt;&gt;&gt; graph = tree_to_mermaid(root)\n&gt;&gt;&gt; print(graph)\n```mermaid\n%%{ init: { 'flowchart': { 'curve': 'basis' } } }%%\nflowchart TB\n0(\"a\") --&gt; 0-0(\"b\")\n0-0 --&gt; 0-0-0(\"d\")\n0-0 --&gt; 0-0-1(\"e\")\n0(\"a\") --&gt; 0-1(\"c\")\nclassDef default stroke-width:1\n```\n</code></pre> <p>Customise node shape, edge label, edge arrow, and custom node attributes</p> <pre><code>&gt;&gt;&gt; graph = tree_to_mermaid(\n...     root,\n...     title=\"Mermaid Diagram\",\n...     theme=\"forest\",\n...     node_shape_attr=\"node_shape\",\n...     edge_label=\"edge_label\",\n...     edge_arrow_attr=\"edge_arrow\",\n...     node_attr=\"node_style\",\n... )\n&gt;&gt;&gt; print(graph)\n```mermaid\n---\ntitle: Mermaid Diagram\n---\n%%{ init: { 'flowchart': { 'curve': 'basis' }, 'theme': 'forest' } }%%\nflowchart TB\n0{\"a\"} ==&gt;|Child 1| 0-0(\"b\")\n0-0 --&gt; 0-0-0(\"d\"):::class0-0-0\n0-0 --&gt; 0-0-1(\"e\")\n0{\"a\"} -.-&gt;|Child 2| 0-1(\"c\")\nclassDef default stroke-width:1\nclassDef class0-0-0 fill:yellow, stroke:black\n```\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>T</code> <p>tree to be exported</p> required <code>title</code> <code>str</code> <p>title</p> <code>''</code> <code>theme</code> <code>Optional[str]</code> <p>theme or colour scheme</p> <code>None</code> <code>rankdir</code> <code>str</code> <p>layout direction, accepts 'TB' (top to bottom), 'BT' (bottom to top), 'LR' (left to right), 'RL' (right to left)</p> <code>'TB'</code> <code>line_shape</code> <code>str</code> <p>line shape or curvature</p> <code>'basis'</code> <code>node_colour</code> <code>str</code> <p>fill colour of nodes, can be colour name or hexcode</p> <code>''</code> <code>node_border_colour</code> <code>str</code> <p>border colour of nodes, can be colour name or hexcode</p> <code>''</code> <code>node_border_width</code> <code>float</code> <p>width of node border</p> <code>1</code> <code>node_shape</code> <code>str</code> <p>node shape, sets the shape of every node</p> <code>'rounded_edge'</code> <code>node_shape_attr</code> <code>Callable[[T], str] | str</code> <p>If string type, it refers to <code>Node</code> attribute for node shape. If callable type, it takes in the node itself and returns the node shape. This sets the shape of custom nodes, and overrides default <code>node_shape</code></p> <code>''</code> <code>edge_arrow</code> <code>str</code> <p>edge arrow style from parent to itself, sets the arrow style of every edge</p> <code>'normal'</code> <code>edge_arrow_attr</code> <code>Callable[[T], str] | str</code> <p>If string type, it refers to <code>Node</code> attribute for edge arrow style. If callable type, it takes in the node itself and returns the edge arrow style. This sets the edge arrow style of custom nodes from parent to itself, and overrides default <code>edge_arrow</code></p> <code>''</code> <code>edge_label</code> <code>str</code> <p><code>Node</code> attribute for edge label from parent to itself</p> <code>''</code> <code>node_attr</code> <code>Callable[[T], str] | str</code> <p>If string type, it refers to <code>Node</code> attribute for node style. If callable type, it takes in the node itself and returns the node style. This overrides <code>node_colour</code>, <code>node_border_colour</code>, and <code>node_border_width</code></p> <code>''</code> <p>Returns:</p> Type Description <code>str</code> <p>Mermaid string of tree</p>"},{"location":"bigtree/tree/export/#bigtree.tree.export.tree_to_pillow","title":"tree_to_pillow","text":"<pre><code>tree_to_pillow(\n    tree,\n    width=0,\n    height=0,\n    start_pos=(10, 10),\n    font_family=\"\",\n    font_size=12,\n    font_colour=\"black\",\n    bg_colour=\"white\",\n    **kwargs\n)\n</code></pre> <p>Export tree to PIL.Image.Image object. Object can be converted to other formats, such as jpg, or png. Image will be similar format as <code>print_tree</code>, accepts additional keyword arguments as input to <code>yield_tree</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, tree_to_pillow\n&gt;&gt;&gt; root = Node(\"a\", age=90)\n&gt;&gt;&gt; b = Node(\"b\", age=65, parent=root)\n&gt;&gt;&gt; c = Node(\"c\", age=60, parent=root)\n&gt;&gt;&gt; d = Node(\"d\", age=40, parent=b)\n&gt;&gt;&gt; e = Node(\"e\", age=35, parent=b)\n&gt;&gt;&gt; pillow_image = tree_to_pillow(root)\n</code></pre> <p>Export to image (PNG, JPG) file, etc.</p> <pre><code>&gt;&gt;&gt; pillow_image.save(\"assets/tree_pillow.png\")\n&gt;&gt;&gt; pillow_image.save(\"assets/tree_pillow.jpg\")\n</code></pre> <p></p> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>T</code> <p>tree to be exported</p> required <code>width</code> <code>int</code> <p>width of image, optional as width of image is calculated automatically</p> <code>0</code> <code>height</code> <code>int</code> <p>height of image, optional as height of image is calculated automatically</p> <code>0</code> <code>start_pos</code> <code>Tuple[int, int]</code> <p>start position of text, (x-offset, y-offset)</p> <code>(10, 10)</code> <code>font_family</code> <code>str</code> <p>file path of font family, requires .ttf file, defaults to DejaVuSans</p> <code>''</code> <code>font_size</code> <code>int</code> <p>font size</p> <code>12</code> <code>font_colour</code> <code>Union[Tuple[int, int, int], str]</code> <p>font colour, accepts tuple of RGB values or string</p> <code>'black'</code> <code>bg_colour</code> <code>Union[Tuple[int, int, int], str]</code> <p>background of image, accepts tuple of RGB values or string</p> <code>'white'</code> <p>Returns:</p> Type Description <code>Image</code> <p>Pillow object of tree, in condensed text format</p>"},{"location":"bigtree/tree/export/#bigtree.tree.export.tree_to_pillow_graph","title":"tree_to_pillow_graph","text":"<pre><code>tree_to_pillow_graph(\n    tree,\n    node_content=\"{node_name}\",\n    *,\n    margin=None,\n    height_buffer=20,\n    width_buffer=10,\n    font_family=\"\",\n    font_size=12,\n    font_colour=\"black\",\n    text_align=\"center\",\n    bg_colour=\"white\",\n    rect_margin=None,\n    rect_fill=\"white\",\n    rect_cmap_attr=None,\n    rect_outline=\"black\",\n    rect_width=1,\n    **kwargs\n)\n</code></pre> <p>Export tree to PIL.Image.Image object. Object can be converted to other formats, such as jpg, or png. Image will look like a tree/graph-like structure, accepts additional keyword arguments as input to <code>yield_tree</code>.</p> <p>Customisations:</p> <pre><code>- To change the margin of tree within diagram, vary `margin`\n- To change the margin of the text within node, vary `rect_margin`\n- For more separation between nodes, change `height_buffer` and `width_buffer`\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, tree_to_pillow_graph\n&gt;&gt;&gt; root = Node(\"a\", age=90)\n&gt;&gt;&gt; b = Node(\"b\", age=65, parent=root)\n&gt;&gt;&gt; c = Node(\"c\", age=60, parent=root)\n&gt;&gt;&gt; d = Node(\"d\", age=40, parent=b)\n&gt;&gt;&gt; e = Node(\"e\", age=35, parent=b)\n&gt;&gt;&gt; pillow_image = tree_to_pillow_graph(root, node_content=\"{node_name}\\nAge: {age}\")\n</code></pre> <p>Export to image (PNG, JPG) file, etc.</p> <pre><code>&gt;&gt;&gt; pillow_image.save(\"assets/tree_pillow_graph.png\")\n&gt;&gt;&gt; pillow_image.save(\"assets/tree_pillow_graph.jpg\")\n</code></pre> <p></p> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>T</code> <p>tree to be exported</p> required <code>node_content</code> <code>str</code> <p>display text in node</p> <code>'{node_name}'</code> <code>margin</code> <code>Optional[Dict[str, int]]</code> <p>margin of diagram</p> <code>None</code> <code>height_buffer</code> <code>Union[int, float]</code> <p>height buffer between node layers, in pixels</p> <code>20</code> <code>width_buffer</code> <code>Union[int, float]</code> <p>width buffer between sibling nodes, in pixels</p> <code>10</code> <code>font_family</code> <code>str</code> <p>file path of font family, requires .ttf file, defaults to DejaVuSans</p> <code>''</code> <code>font_size</code> <code>int</code> <p>font size</p> <code>12</code> <code>font_colour</code> <code>Union[Tuple[int, int, int], str]</code> <p>font colour, accepts tuple of RGB values or string</p> <code>'black'</code> <code>text_align</code> <code>str</code> <p>text align for multi-line text</p> <code>'center'</code> <code>bg_colour</code> <code>Union[Tuple[int, int, int], str]</code> <p>background of image, accepts tuple of RGB values or string</p> <code>'white'</code> <code>rect_margin</code> <code>Optional[Dict[str, int]]</code> <p>(for rectangle) margin of text to rectangle, in pixels</p> <code>None</code> <code>rect_fill</code> <code>Union[Tuple[int, int, int], str, Colormap]</code> <p>(for rectangle) colour to use for fill</p> <code>'white'</code> <code>rect_cmap_attr</code> <code>Optional[str]</code> <p>(for rectangle) if rect_fill is a colormap, attribute of node to retrieve fill from colormap, must be a float/int attribute</p> <code>None</code> <code>rect_outline</code> <code>Union[Tuple[int, int, int], str]</code> <p>(for rectangle) colour to use for outline</p> <code>'black'</code> <code>rect_width</code> <code>int</code> <p>(for rectangle) line width, in pixels</p> <code>1</code> <p>Returns:</p> Type Description <code>Image</code> <p>Pillow object of tree, in graph format</p>"},{"location":"bigtree/tree/export/#bigtree.tree.export.hprint_tree","title":"hprint_tree","text":"<pre><code>hprint_tree(\n    tree,\n    alias=\"node_name\",\n    node_name_or_path=\"\",\n    max_depth=0,\n    intermediate_node_name=True,\n    spacing=0,\n    style=\"const\",\n    border_style=None,\n    strip=True,\n    **kwargs\n)\n</code></pre> <p>Print tree in horizontal orientation to console, starting from <code>tree</code>. Accepts kwargs for print() function.</p> <ul> <li>Able to have alias for node name if alias attribute is present, else it falls back to node_name, using <code>alias</code></li> <li>Able to select which node to print from, resulting in a subtree, using <code>node_name_or_path</code></li> <li>Able to customise for maximum depth to print, using <code>max_depth</code></li> <li>Able to hide names of intermediate nodes, using <code>intermediate_node_name</code></li> <li>Able to select horizontal spacing between nodes, using <code>spacing</code></li> <li>Able to customise style, to choose from str, Iterable[str], or inherit from constants.BaseHPrintStyle, using <code>style</code></li> <li>Able to toggle border, with border style to choose from str, Iterable[str], or inherit from constants.BorderStyle,     using <code>border_style</code></li> <li>Able to have constant width output string or to strip the trailing spaces, using <code>strip</code></li> </ul> <p>For style,</p> <ul> <li>(str): <code>ansi</code>, <code>ascii</code>, <code>const</code> (default), <code>const_bold</code>, <code>rounded</code>, <code>double</code> style</li> <li>(Iterable[str]): Choose own style icons, they must have the same number of characters</li> <li>(constants.BaseHPrintStyle): <code>ANSIHPrintStyle</code>, <code>ASCIIHPrintStyle</code>, <code>ConstHPrintStyle</code>, <code>ConstBoldHPrintStyle</code>,     <code>RoundedHPrintStyle</code>, <code>DoubleHPrintStyle</code> style or inherit from constants.BaseHPrintStyle</li> </ul> <p>For border_style,</p> <ul> <li>(str): <code>ansi</code>, <code>ascii</code>, <code>const</code> (default), <code>const_bold</code>, <code>rounded</code>, <code>double</code> style</li> <li>(Iterable[str]): Choose own style icons, they must be 1 character long</li> <li>(constants.BorderStyle): <code>ANSIBorderStyle</code>, <code>ASCIIBorderStyle</code>, <code>ConstBorderStyle</code>, <code>ConstBoldBorderStyle</code>,     <code>RoundedBorderStyle</code>, <code>DoubleBorderStyle</code> style or inherit from constants.BorderStyle</li> </ul> <p>Examples:</p> <p>Printing tree</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, hprint_tree\n&gt;&gt;&gt; root = Node(\"a\")\n&gt;&gt;&gt; b = Node(\"b\", parent=root)\n&gt;&gt;&gt; c = Node(\"c\", parent=root)\n&gt;&gt;&gt; d = Node(\"d\", parent=b)\n&gt;&gt;&gt; e = Node(\"e\", parent=b)\n&gt;&gt;&gt; hprint_tree(root)\n           \u250c\u2500 d\n     \u250c\u2500 b \u2500\u2524\n\u2500 a \u2500\u2524     \u2514\u2500 e\n     \u2514\u2500 c\n</code></pre> <p>Printing Sub-tree</p> <pre><code>&gt;&gt;&gt; hprint_tree(root, node_name_or_path=\"b\")\n     \u250c\u2500 d\n\u2500 b \u2500\u2524\n     \u2514\u2500 e\n</code></pre> <pre><code>&gt;&gt;&gt; hprint_tree(root, max_depth=2)\n     \u250c\u2500 b\n\u2500 a \u2500\u2524\n     \u2514\u2500 c\n</code></pre> <p>Available Styles</p> <pre><code>&gt;&gt;&gt; hprint_tree(root, style=\"ansi\")\n           /- d\n     /- b -+\n- a -+     \\- e\n     \\- c\n</code></pre> <pre><code>&gt;&gt;&gt; hprint_tree(root, style=\"ascii\")\n           +- d\n     +- b -+\n- a -+     +- e\n     +- c\n</code></pre> <pre><code>&gt;&gt;&gt; hprint_tree(root, style=\"const\")\n           \u250c\u2500 d\n     \u250c\u2500 b \u2500\u2524\n\u2500 a \u2500\u2524     \u2514\u2500 e\n     \u2514\u2500 c\n</code></pre> <pre><code>&gt;&gt;&gt; hprint_tree(root, style=\"const_bold\")\n           \u250f\u2501 d\n     \u250f\u2501 b \u2501\u252b\n\u2501 a \u2501\u252b     \u2517\u2501 e\n     \u2517\u2501 c\n</code></pre> <pre><code>&gt;&gt;&gt; hprint_tree(root, style=\"rounded\")\n           \u256d\u2500 d\n     \u256d\u2500 b \u2500\u2524\n\u2500 a \u2500\u2524     \u2570\u2500 e\n     \u2570\u2500 c\n</code></pre> <pre><code>&gt;&gt;&gt; hprint_tree(root, style=\"double\")\n           \u2554\u2550 d\n     \u2554\u2550 b \u2550\u2563\n\u2550 a \u2550\u2563     \u255a\u2550 e\n     \u255a\u2550 c\n</code></pre> <p>Custom Styles</p> <pre><code>&gt;&gt;&gt; from bigtree import ANSIHPrintStyle\n&gt;&gt;&gt; hprint_tree(root, style=ANSIHPrintStyle)\n           /- d\n     /- b -+\n- a -+     \\- e\n     \\- c\n</code></pre> <p>Border</p> <pre><code>&gt;&gt;&gt; hprint_tree(root, style=\"rounded\", border_style=\"rounded\")\n                    \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n          \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\u256d\u2524   d   \u2502\n         \u256d\u2524   b   \u251c\u2524\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\u2502\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\u2502\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502   a   \u251c\u2524         \u2570\u2524   e   \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\u2502          \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n         \u2502\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n         \u2570\u2524   c   \u2502\n          \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>Printing to a file</p> <pre><code>&gt;&gt;&gt; import io\n&gt;&gt;&gt; output = io.StringIO()\n&gt;&gt;&gt; hprint_tree(root, file=output)\n&gt;&gt;&gt; tree_string = output.getvalue()\n&gt;&gt;&gt; print(tree_string)\n           \u250c\u2500 d\n     \u250c\u2500 b \u2500\u2524\n\u2500 a \u2500\u2524     \u2514\u2500 e\n     \u2514\u2500 c\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>T</code> <p>tree to print</p> required <code>alias</code> <code>str</code> <p>node attribute to use for node name in tree as alias to <code>node_name</code></p> <code>'node_name'</code> <code>node_name_or_path</code> <code>str</code> <p>node to print from, becomes the root node of printing</p> <code>''</code> <code>max_depth</code> <code>int</code> <p>maximum depth of tree to print, based on <code>depth</code> attribute</p> <code>0</code> <code>intermediate_node_name</code> <code>bool</code> <p>indicator if intermediate nodes have node names</p> <code>True</code> <code>spacing</code> <code>int</code> <p>horizontal spacing between node displays</p> <code>0</code> <code>style</code> <code>Union[str, Iterable[str], BaseHPrintStyle]</code> <p>style of print</p> <code>'const'</code> <code>border_style</code> <code>Optional[Union[str, Iterable[str], BorderStyle]]</code> <p>style of border</p> <code>None</code> <code>strip</code> <code>bool</code> <p>whether to strip results</p> <code>True</code>"},{"location":"bigtree/tree/export/#bigtree.tree.export.hyield_tree","title":"hyield_tree","text":"<pre><code>hyield_tree(\n    tree,\n    alias=\"node_name\",\n    node_name_or_path=\"\",\n    max_depth=0,\n    intermediate_node_name=True,\n    spacing=0,\n    style=\"const\",\n    border_style=None,\n    strip=True,\n)\n</code></pre> <p>Yield tree in horizontal orientation to console, starting from <code>tree</code>.</p> <ul> <li>Able to have alias for node name if alias attribute is present, else it falls back to node_name, using <code>alias</code></li> <li>Able to select which node to print from, resulting in a subtree, using <code>node_name_or_path</code></li> <li>Able to customise for maximum depth to print, using <code>max_depth</code></li> <li>Able to hide names of intermediate nodes, using <code>intermediate_node_name</code></li> <li>Able to select horizontal spacing between nodes, using <code>spacing</code></li> <li>Able to customise style, to choose from str, Iterable[str], or inherit from constants.BaseHPrintStyle, using <code>style</code></li> <li>Able to toggle border, with border style to choose from str, Iterable[str], or inherit from constants.BorderStyle,     using <code>border_style</code></li> <li>Able to have constant width output string or to strip the trailing spaces, using <code>strip</code></li> </ul> <p>For style,</p> <ul> <li>(str): <code>ansi</code>, <code>ascii</code>, <code>const</code> (default), <code>const_bold</code>, <code>rounded</code>, <code>double</code> style</li> <li>(Iterable[str]): Choose own style icons, they must be 1 character long</li> <li>(constants.BaseHPrintStyle): <code>ANSIHPrintStyle</code>, <code>ASCIIHPrintStyle</code>, <code>ConstHPrintStyle</code>, <code>ConstBoldHPrintStyle</code>,     <code>RoundedHPrintStyle</code>, <code>DoubleHPrintStyle</code> style or inherit from constants.BaseHPrintStyle</li> </ul> <p>For border_style,</p> <ul> <li>(str): <code>ansi</code>, <code>ascii</code>, <code>const</code> (default), <code>const_bold</code>, <code>rounded</code>, <code>double</code> style</li> <li>(Iterable[str]): Choose own style icons, they must be 1 character long</li> <li>(constants.BorderStyle): <code>ANSIBorderStyle</code>, <code>ASCIIBorderStyle</code>, <code>ConstBorderStyle</code>, <code>ConstBoldBorderStyle</code>,     <code>RoundedBorderStyle</code>, <code>DoubleBorderStyle</code> style or inherit from constants.BorderStyle</li> </ul> <p>Examples:</p> <p>Printing tree</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, hyield_tree\n&gt;&gt;&gt; root = Node(\"a\")\n&gt;&gt;&gt; b = Node(\"b\", parent=root)\n&gt;&gt;&gt; c = Node(\"c\", parent=root)\n&gt;&gt;&gt; d = Node(\"d\", parent=b)\n&gt;&gt;&gt; e = Node(\"e\", parent=b)\n&gt;&gt;&gt; result = hyield_tree(root)\n&gt;&gt;&gt; print(\"\\n\".join(result))\n           \u250c\u2500 d\n     \u250c\u2500 b \u2500\u2524\n\u2500 a \u2500\u2524     \u2514\u2500 e\n     \u2514\u2500 c\n</code></pre> <p>Printing Sub-tree</p> <pre><code>&gt;&gt;&gt; result = hyield_tree(root, node_name_or_path=\"b\")\n&gt;&gt;&gt; print(\"\\n\".join(result))\n     \u250c\u2500 d\n\u2500 b \u2500\u2524\n     \u2514\u2500 e\n</code></pre> <pre><code>&gt;&gt;&gt; result = hyield_tree(root, max_depth=2)\n&gt;&gt;&gt; print(\"\\n\".join(result))\n     \u250c\u2500 b\n\u2500 a \u2500\u2524\n     \u2514\u2500 c\n</code></pre> <p>Available Styles</p> <pre><code>&gt;&gt;&gt; result = hyield_tree(root, style=\"ansi\")\n&gt;&gt;&gt; print(\"\\n\".join(result))\n           /- d\n     /- b -+\n- a -+     \\- e\n     \\- c\n</code></pre> <pre><code>&gt;&gt;&gt; result = hyield_tree(root, style=\"ascii\")\n&gt;&gt;&gt; print(\"\\n\".join(result))\n           +- d\n     +- b -+\n- a -+     +- e\n     +- c\n</code></pre> <pre><code>&gt;&gt;&gt; result = hyield_tree(root, style=\"const\")\n&gt;&gt;&gt; print(\"\\n\".join(result))\n           \u250c\u2500 d\n     \u250c\u2500 b \u2500\u2524\n\u2500 a \u2500\u2524     \u2514\u2500 e\n     \u2514\u2500 c\n</code></pre> <pre><code>&gt;&gt;&gt; result = hyield_tree(root, style=\"const_bold\")\n&gt;&gt;&gt; print(\"\\n\".join(result))\n           \u250f\u2501 d\n     \u250f\u2501 b \u2501\u252b\n\u2501 a \u2501\u252b     \u2517\u2501 e\n     \u2517\u2501 c\n</code></pre> <pre><code>&gt;&gt;&gt; result = hyield_tree(root, style=\"rounded\")\n&gt;&gt;&gt; print(\"\\n\".join(result))\n           \u256d\u2500 d\n     \u256d\u2500 b \u2500\u2524\n\u2500 a \u2500\u2524     \u2570\u2500 e\n     \u2570\u2500 c\n</code></pre> <pre><code>&gt;&gt;&gt; result = hyield_tree(root, style=\"double\")\n&gt;&gt;&gt; print(\"\\n\".join(result))\n           \u2554\u2550 d\n     \u2554\u2550 b \u2550\u2563\n\u2550 a \u2550\u2563     \u255a\u2550 e\n     \u255a\u2550 c\n</code></pre> <p>Custom Styles</p> <pre><code>&gt;&gt;&gt; from bigtree import ANSIHPrintStyle\n&gt;&gt;&gt; result = hyield_tree(root, style=ANSIHPrintStyle)\n&gt;&gt;&gt; print(\"\\n\".join(result))\n           /- d\n     /- b -+\n- a -+     \\- e\n     \\- c\n</code></pre> <p>Border</p> <pre><code>&gt;&gt;&gt; result = hyield_tree(root, style=\"rounded\", border_style=\"rounded\")\n&gt;&gt;&gt; print(\"\\n\".join(result))\n                    \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n          \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\u256d\u2524   d   \u2502\n         \u256d\u2524   b   \u251c\u2524\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\u2502\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\u2502\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502   a   \u251c\u2524         \u2570\u2524   e   \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\u2502          \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n         \u2502\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n         \u2570\u2524   c   \u2502\n          \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>T</code> <p>tree to print</p> required <code>alias</code> <code>str</code> <p>node attribute to use for node name in tree as alias to <code>node_name</code></p> <code>'node_name'</code> <code>node_name_or_path</code> <code>str</code> <p>node to print from, becomes the root node of printing</p> <code>''</code> <code>max_depth</code> <code>int</code> <p>maximum depth of tree to print, based on <code>depth</code> attribute</p> <code>0</code> <code>intermediate_node_name</code> <code>bool</code> <p>indicator if intermediate nodes have node names</p> <code>True</code> <code>spacing</code> <code>int</code> <p>horizontal spacing between node displays</p> <code>0</code> <code>style</code> <code>Union[str, Iterable[str], BaseHPrintStyle]</code> <p>style of print</p> <code>'const'</code> <code>border_style</code> <code>Optional[Union[str, Iterable[str], BorderStyle]]</code> <p>style of border</p> <code>None</code> <code>strip</code> <code>bool</code> <p>whether to strip results</p> <code>True</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>Yield tree in horizontal format</p>"},{"location":"bigtree/tree/export/#bigtree.tree.export.print_tree","title":"print_tree","text":"<pre><code>print_tree(\n    tree,\n    alias=\"node_name\",\n    node_name_or_path=\"\",\n    max_depth=0,\n    all_attrs=False,\n    attr_list=[],\n    attr_omit_null=False,\n    attr_bracket=[\"[\", \"]\"],\n    style=\"const\",\n    **kwargs\n)\n</code></pre> <p>Print tree to console, starting from <code>tree</code>. Accepts kwargs for print() function.</p> <ul> <li>Able to have alias for node name if alias attribute is present, else it falls back to node_name, using <code>alias</code></li> <li>Able to select which node to print from, resulting in a subtree, using <code>node_name_or_path</code></li> <li>Able to customise for maximum depth to print, using <code>max_depth</code></li> <li>Able to choose which attributes to show or show all attributes, using <code>all_attrs</code> and <code>attr_list</code></li> <li>Able to omit showing of attributes if it is null, using <code>attr_omit_null</code></li> <li>Able to customise open and close brackets if attributes are shown, using <code>attr_bracket</code></li> <li>Able to customise style, to choose from str, List[str], or inherit from constants.BasePrintStyle, using <code>style</code></li> </ul> <p>For style,</p> <ul> <li>(str): <code>ansi</code>, <code>ascii</code>, <code>const</code> (default), <code>const_bold</code>, <code>rounded</code>, <code>double</code> style</li> <li>(List[str]): Choose own style for stem, branch, and final stem icons, they must have the same number of characters</li> <li>(constants.BasePrintStyle): <code>ANSIPrintStyle</code>, <code>ASCIIPrintStyle</code>, <code>ConstPrintStyle</code>, <code>ConstBoldPrintStyle</code>,     <code>RoundedPrintStyle</code>, <code>DoublePrintStyle</code> style or inherit from <code>constants.BasePrintStyle</code></li> </ul> <p>Examples:</p> <p>Printing tree</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, print_tree\n&gt;&gt;&gt; root = Node(\"a\", alias=\"alias-a\", age=90)\n&gt;&gt;&gt; b = Node(\"b\", age=65, parent=root)\n&gt;&gt;&gt; c = Node(\"c\", alias=\"alias-c\", age=60, parent=root)\n&gt;&gt;&gt; d = Node(\"d\", age=40, parent=b)\n&gt;&gt;&gt; e = Node(\"e\", age=35, parent=b)\n&gt;&gt;&gt; print_tree(root)\na\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 d\n\u2502   \u2514\u2500\u2500 e\n\u2514\u2500\u2500 c\n</code></pre> <p>Printing alias</p> <pre><code>&gt;&gt;&gt; print_tree(root, alias=\"alias\")\nalias-a\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 d\n\u2502   \u2514\u2500\u2500 e\n\u2514\u2500\u2500 alias-c\n</code></pre> <p>Printing Sub-tree</p> <pre><code>&gt;&gt;&gt; print_tree(root, node_name_or_path=\"b\")\nb\n\u251c\u2500\u2500 d\n\u2514\u2500\u2500 e\n</code></pre> <pre><code>&gt;&gt;&gt; print_tree(root, max_depth=2)\na\n\u251c\u2500\u2500 b\n\u2514\u2500\u2500 c\n</code></pre> <p>Printing Attributes</p> <pre><code>&gt;&gt;&gt; print_tree(root, attr_list=[\"age\"])\na [age=90]\n\u251c\u2500\u2500 b [age=65]\n\u2502   \u251c\u2500\u2500 d [age=40]\n\u2502   \u2514\u2500\u2500 e [age=35]\n\u2514\u2500\u2500 c [age=60]\n</code></pre> <pre><code>&gt;&gt;&gt; print_tree(root, attr_list=[\"age\"], attr_bracket=[\"*(\", \")\"])\na *(age=90)\n\u251c\u2500\u2500 b *(age=65)\n\u2502   \u251c\u2500\u2500 d *(age=40)\n\u2502   \u2514\u2500\u2500 e *(age=35)\n\u2514\u2500\u2500 c *(age=60)\n</code></pre> <p>Available Styles</p> <pre><code>&gt;&gt;&gt; print_tree(root, style=\"ansi\")\na\n|-- b\n|   |-- d\n|   `-- e\n`-- c\n</code></pre> <pre><code>&gt;&gt;&gt; print_tree(root, style=\"ascii\")\na\n|-- b\n|   |-- d\n|   +-- e\n+-- c\n</code></pre> <pre><code>&gt;&gt;&gt; print_tree(root, style=\"const\")\na\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 d\n\u2502   \u2514\u2500\u2500 e\n\u2514\u2500\u2500 c\n</code></pre> <pre><code>&gt;&gt;&gt; print_tree(root, style=\"const_bold\")\na\n\u2523\u2501\u2501 b\n\u2503   \u2523\u2501\u2501 d\n\u2503   \u2517\u2501\u2501 e\n\u2517\u2501\u2501 c\n</code></pre> <pre><code>&gt;&gt;&gt; print_tree(root, style=\"rounded\")\na\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 d\n\u2502   \u2570\u2500\u2500 e\n\u2570\u2500\u2500 c\n</code></pre> <pre><code>&gt;&gt;&gt; print_tree(root, style=\"double\")\na\n\u2560\u2550\u2550 b\n\u2551   \u2560\u2550\u2550 d\n\u2551   \u255a\u2550\u2550 e\n\u255a\u2550\u2550 c\n</code></pre> <p>Custom Styles</p> <pre><code>&gt;&gt;&gt; from bigtree import ANSIPrintStyle\n&gt;&gt;&gt; print_tree(root, style=ANSIPrintStyle)\na\n|-- b\n|   |-- d\n|   `-- e\n`-- c\n</code></pre> <p>Printing to a file</p> <pre><code>&gt;&gt;&gt; import io\n&gt;&gt;&gt; output = io.StringIO()\n&gt;&gt;&gt; print_tree(root, file=output)\n&gt;&gt;&gt; tree_string = output.getvalue()\n&gt;&gt;&gt; print(tree_string)\na\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 d\n\u2502   \u2514\u2500\u2500 e\n\u2514\u2500\u2500 c\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>T</code> <p>tree to print</p> required <code>alias</code> <code>str</code> <p>node attribute to use for node name in tree as alias to <code>node_name</code></p> <code>'node_name'</code> <code>node_name_or_path</code> <code>str</code> <p>node to print from, becomes the root node of printing</p> <code>''</code> <code>max_depth</code> <code>int</code> <p>maximum depth of tree to print, based on <code>depth</code> attribute</p> <code>0</code> <code>all_attrs</code> <code>bool</code> <p>indicator to show all attributes, overrides <code>attr_list</code> and <code>attr_omit_null</code></p> <code>False</code> <code>attr_list</code> <code>Iterable[str]</code> <p>list of node attributes to print</p> <code>[]</code> <code>attr_omit_null</code> <code>bool</code> <p>indicator whether to omit showing of null attributes</p> <code>False</code> <code>attr_bracket</code> <code>List[str]</code> <p>open and close bracket for <code>all_attrs</code> or <code>attr_list</code></p> <code>['[', ']']</code> <code>style</code> <code>Union[str, Iterable[str], BasePrintStyle]</code> <p>style of print</p> <code>'const'</code>"},{"location":"bigtree/tree/export/#bigtree.tree.export.tree_to_newick","title":"tree_to_newick","text":"<pre><code>tree_to_newick(\n    tree,\n    intermediate_node_name=True,\n    length_attr=\"\",\n    length_sep=SEP,\n    attr_list=[],\n    attr_prefix=\"&amp;&amp;NHX:\",\n    attr_sep=SEP,\n)\n</code></pre> <p>Export tree to Newick notation. Useful for describing phylogenetic tree.</p> <p>In the Newick Notation (or New Hampshire Notation)</p> <ul> <li>Tree is represented in round brackets i.e., <code>(child1,child2,child3)parent</code></li> <li>If there are nested trees, they will be in nested round brackets i.e., <code>((grandchild1)child1,(grandchild2,grandchild3)child2)parent</code></li> <li>If there is length attribute, they will be beside the name i.e., <code>(child1:0.5,child2:0.1)parent</code></li> <li>If there are other attributes, attributes are represented in square brackets i.e., <code>(child1:0.5[S:human],child2:0.1[S:human])parent[S:parent]</code></li> </ul> <p>Customisations include</p> <ul> <li>Omitting names of root and intermediate nodes, default all node names are shown</li> <li>Changing length separator to another symbol, default is <code>:</code></li> <li>Adding an attribute prefix, default is <code>&amp;&amp;NHX:</code></li> <li>Changing the attribute separator to another symbol, default is <code>:</code></li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, tree_to_newick\n&gt;&gt;&gt; root = Node(\"a\", species=\"human\")\n&gt;&gt;&gt; b = Node(\"b\", age=65, species=\"human\", parent=root)\n&gt;&gt;&gt; c = Node(\"c\", age=60, species=\"human\", parent=root)\n&gt;&gt;&gt; d = Node(\"d\", age=40, species=\"human\", parent=b)\n&gt;&gt;&gt; e = Node(\"e\", age=35, species=\"human\", parent=b)\n&gt;&gt;&gt; root.show()\na\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 d\n\u2502   \u2514\u2500\u2500 e\n\u2514\u2500\u2500 c\n</code></pre> <pre><code>&gt;&gt;&gt; tree_to_newick(root)\n'((d,e)b,c)a'\n</code></pre> <pre><code>&gt;&gt;&gt; tree_to_newick(root, length_attr=\"age\")\n'((d:40,e:35)b:65,c:60)a'\n</code></pre> <pre><code>&gt;&gt;&gt; tree_to_newick(root, length_attr=\"age\", attr_list=[\"species\"])\n'((d:40[&amp;&amp;NHX:species=human],e:35[&amp;&amp;NHX:species=human])b:65[&amp;&amp;NHX:species=human],c:60[&amp;&amp;NHX:species=human])a[&amp;&amp;NHX:species=human]'\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>T</code> <p>tree to be exported</p> required <code>intermediate_node_name</code> <code>bool</code> <p>indicator if intermediate nodes have node names</p> <code>True</code> <code>length_attr</code> <code>str</code> <p>node length attribute to extract to beside name</p> <code>''</code> <code>length_sep</code> <code>Union[str, NewickCharacter]</code> <p>separator between node name and length, used if length_attr is non-empty</p> <code>SEP</code> <code>attr_list</code> <code>Iterable[str]</code> <p>list of node attributes to extract into square bracket</p> <code>[]</code> <code>attr_prefix</code> <code>str</code> <p>prefix before all attributes, within square bracket, used if attr_list is non-empty</p> <code>'&amp;&amp;NHX:'</code> <code>attr_sep</code> <code>Union[str, NewickCharacter]</code> <p>separator between attributes, within square brackets, used if attr_list is non-empty</p> <code>SEP</code> <p>Returns:</p> Type Description <code>str</code> <p>Newick string representation of tree</p>"},{"location":"bigtree/tree/export/#bigtree.tree.export.vprint_tree","title":"vprint_tree","text":"<pre><code>vprint_tree(\n    tree,\n    alias=\"node_name\",\n    node_name_or_path=\"\",\n    max_depth=0,\n    intermediate_node_name=True,\n    spacing=2,\n    style=\"const\",\n    border_style=\"const\",\n    strip=False,\n    **kwargs\n)\n</code></pre> <p>Print tree in vertical orientation to console, starting from <code>tree</code>. Accepts kwargs for print() function.</p> <ul> <li>Able to have alias for node name if alias attribute is present, else it falls back to node_name, using <code>alias</code></li> <li>Able to select which node to print from, resulting in a subtree, using <code>node_name_or_path</code></li> <li>Able to customise for maximum depth to print, using <code>max_depth</code></li> <li>Able to hide names of intermediate nodes, using <code>intermediate_node_name</code></li> <li>Able to select horizontal spacing between nodes, using <code>spacing</code></li> <li>Able to customise style, to choose from str, Iterable[str], or inherit from constants.BaseVPrintStyle, using <code>style</code></li> <li>Able to toggle border, with border style to choose from str, Iterable[str], or inherit from constants.BorderStyle,     using <code>border_style</code></li> <li>Able to have constant width output string or to strip the trailing spaces, using <code>strip</code></li> </ul> <p>For style,</p> <ul> <li>(str): <code>ansi</code>, <code>ascii</code>, <code>const</code> (default), <code>const_bold</code>, <code>rounded</code>, <code>double</code> style</li> <li>(Iterable[str]): Choose own style icons, they must be 1 character long</li> <li>(constants.BaseVPrintStyle): <code>ANSIVPrintStyle</code>, <code>ASCIIVPrintStyle</code>, <code>ConstVPrintStyle</code>, <code>ConstBoldVPrintStyle</code>,     <code>RoundedVPrintStyle</code>, <code>DoubleVPrintStyle</code> style or inherit from constants.BaseVPrintStyle</li> </ul> <p>For border_style,</p> <ul> <li>(str): <code>ansi</code>, <code>ascii</code>, <code>const</code> (default), <code>const_bold</code>, <code>rounded</code>, <code>double</code> style</li> <li>(Iterable[str]): Choose own style icons, they must be 1 character long</li> <li>(constants.BorderStyle): <code>ANSIBorderStyle</code>, <code>ASCIIBorderStyle</code>, <code>ConstBorderStyle</code>, <code>ConstBoldBorderStyle</code>,     <code>RoundedBorderStyle</code>, <code>DoubleBorderStyle</code> style or inherit from constants.BorderStyle</li> </ul> <p>Examples:</p> <p>Printing tree</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, vprint_tree\n&gt;&gt;&gt; root = Node(\"a\")\n&gt;&gt;&gt; b = Node(\"b\", parent=root)\n&gt;&gt;&gt; c = Node(\"c\", parent=root)\n&gt;&gt;&gt; d = Node(\"d\", parent=b)\n&gt;&gt;&gt; e = Node(\"e\", parent=b)\n&gt;&gt;&gt; vprint_tree(root, strip=True)\n        \u250c\u2500\u2500\u2500\u2510\n        \u2502 a \u2502\n        \u2514\u2500\u252c\u2500\u2518\n     \u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2510\n   \u250c\u2500\u2534\u2500\u2510      \u250c\u2500\u2534\u2500\u2510\n   \u2502 b \u2502      \u2502 c \u2502\n   \u2514\u2500\u252c\u2500\u2518      \u2514\u2500\u2500\u2500\u2518\n  \u250c\u2500\u2500\u2534\u2500\u2500\u2500\u2510\n\u250c\u2500\u2534\u2500\u2510  \u250c\u2500\u2534\u2500\u2510\n\u2502 d \u2502  \u2502 e \u2502\n\u2514\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2518\n</code></pre> <p>Printing Sub-tree</p> <pre><code>&gt;&gt;&gt; vprint_tree(root, node_name_or_path=\"b\", strip=True)\n   \u250c\u2500\u2500\u2500\u2510\n   \u2502 b \u2502\n   \u2514\u2500\u252c\u2500\u2518\n  \u250c\u2500\u2500\u2534\u2500\u2500\u2500\u2510\n\u250c\u2500\u2534\u2500\u2510  \u250c\u2500\u2534\u2500\u2510\n\u2502 d \u2502  \u2502 e \u2502\n\u2514\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>&gt;&gt;&gt; vprint_tree(root, max_depth=2, strip=True)\n   \u250c\u2500\u2500\u2500\u2510\n   \u2502 a \u2502\n   \u2514\u2500\u252c\u2500\u2518\n  \u250c\u2500\u2500\u2534\u2500\u2500\u2500\u2510\n\u250c\u2500\u2534\u2500\u2510  \u250c\u2500\u2534\u2500\u2510\n\u2502 b \u2502  \u2502 c \u2502\n\u2514\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2518\n</code></pre> <p>Available Styles</p> <pre><code>&gt;&gt;&gt; vprint_tree(root, style=\"ansi\", border_style=\"ansi\", strip=True)\n        `---`\n        | a |\n        `-+-`\n     /----+-----\\\n   `-+-`      `-+-`\n   | b |      | c |\n   `-+-`      `---`\n  /--+---\\\n`-+-`  `-+-`\n| d |  | e |\n`---`  `---`\n</code></pre> <pre><code>&gt;&gt;&gt; vprint_tree(root, style=\"ascii\", border_style=\"ascii\", strip=True)\n        +---+\n        | a |\n        +-+-+\n     +----+-----+\n   +-+-+      +-+-+\n   | b |      | c |\n   +-+-+      +---+\n  +--+---+\n+-+-+  +-+-+\n| d |  | e |\n+---+  +---+\n</code></pre> <pre><code>&gt;&gt;&gt; vprint_tree(root, style=\"const\", border_style=\"const\", strip=True)\n        \u250c\u2500\u2500\u2500\u2510\n        \u2502 a \u2502\n        \u2514\u2500\u252c\u2500\u2518\n     \u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2510\n   \u250c\u2500\u2534\u2500\u2510      \u250c\u2500\u2534\u2500\u2510\n   \u2502 b \u2502      \u2502 c \u2502\n   \u2514\u2500\u252c\u2500\u2518      \u2514\u2500\u2500\u2500\u2518\n  \u250c\u2500\u2500\u2534\u2500\u2500\u2500\u2510\n\u250c\u2500\u2534\u2500\u2510  \u250c\u2500\u2534\u2500\u2510\n\u2502 d \u2502  \u2502 e \u2502\n\u2514\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>&gt;&gt;&gt; vprint_tree(root, style=\"const_bold\", border_style=\"const_bold\", strip=True)\n        \u250f\u2501\u2501\u2501\u2513\n        \u2503 a \u2503\n        \u2517\u2501\u2533\u2501\u251b\n     \u250f\u2501\u2501\u2501\u2501\u253b\u2501\u2501\u2501\u2501\u2501\u2513\n   \u250f\u2501\u253b\u2501\u2513      \u250f\u2501\u253b\u2501\u2513\n   \u2503 b \u2503      \u2503 c \u2503\n   \u2517\u2501\u2533\u2501\u251b      \u2517\u2501\u2501\u2501\u251b\n  \u250f\u2501\u2501\u253b\u2501\u2501\u2501\u2513\n\u250f\u2501\u253b\u2501\u2513  \u250f\u2501\u253b\u2501\u2513\n\u2503 d \u2503  \u2503 e \u2503\n\u2517\u2501\u2501\u2501\u251b  \u2517\u2501\u2501\u2501\u251b\n</code></pre> <pre><code>&gt;&gt;&gt; vprint_tree(root, style=\"rounded\", border_style=\"rounded\", strip=True)\n        \u256d\u2500\u2500\u2500\u256e\n        \u2502 a \u2502\n        \u2570\u2500\u252c\u2500\u256f\n     \u256d\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u256e\n   \u256d\u2500\u2534\u2500\u256e      \u256d\u2500\u2534\u2500\u256e\n   \u2502 b \u2502      \u2502 c \u2502\n   \u2570\u2500\u252c\u2500\u256f      \u2570\u2500\u2500\u2500\u256f\n  \u256d\u2500\u2500\u2534\u2500\u2500\u2500\u256e\n\u256d\u2500\u2534\u2500\u256e  \u256d\u2500\u2534\u2500\u256e\n\u2502 d \u2502  \u2502 e \u2502\n\u2570\u2500\u2500\u2500\u256f  \u2570\u2500\u2500\u2500\u256f\n</code></pre> <pre><code>&gt;&gt;&gt; vprint_tree(root, style=\"double\", border_style=\"double\", strip=True)\n        \u2554\u2550\u2550\u2550\u2557\n        \u2551 a \u2551\n        \u255a\u2550\u2566\u2550\u255d\n     \u2554\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2557\n   \u2554\u2550\u2569\u2550\u2557      \u2554\u2550\u2569\u2550\u2557\n   \u2551 b \u2551      \u2551 c \u2551\n   \u255a\u2550\u2566\u2550\u255d      \u255a\u2550\u2550\u2550\u255d\n  \u2554\u2550\u2550\u2569\u2550\u2550\u2550\u2557\n\u2554\u2550\u2569\u2550\u2557  \u2554\u2550\u2569\u2550\u2557\n\u2551 d \u2551  \u2551 e \u2551\n\u255a\u2550\u2550\u2550\u255d  \u255a\u2550\u2550\u2550\u255d\n</code></pre> <p>Custom Styles</p> <pre><code>&gt;&gt;&gt; from bigtree import RoundedVPrintStyle, RoundedBorderStyle\n&gt;&gt;&gt; vprint_tree(root, style=RoundedVPrintStyle, border_style=RoundedBorderStyle, strip=True)\n        \u256d\u2500\u2500\u2500\u256e\n        \u2502 a \u2502\n        \u2570\u2500\u252c\u2500\u256f\n     \u256d\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u256e\n   \u256d\u2500\u2534\u2500\u256e      \u256d\u2500\u2534\u2500\u256e\n   \u2502 b \u2502      \u2502 c \u2502\n   \u2570\u2500\u252c\u2500\u256f      \u2570\u2500\u2500\u2500\u256f\n  \u256d\u2500\u2500\u2534\u2500\u2500\u2500\u256e\n\u256d\u2500\u2534\u2500\u256e  \u256d\u2500\u2534\u2500\u256e\n\u2502 d \u2502  \u2502 e \u2502\n\u2570\u2500\u2500\u2500\u256f  \u2570\u2500\u2500\u2500\u256f\n</code></pre> <p>Printing to a file</p> <pre><code>&gt;&gt;&gt; import io\n&gt;&gt;&gt; output = io.StringIO()\n&gt;&gt;&gt; vprint_tree(root, file=output, strip=True)\n&gt;&gt;&gt; tree_string = output.getvalue()\n&gt;&gt;&gt; print(tree_string)\n        \u250c\u2500\u2500\u2500\u2510\n        \u2502 a \u2502\n        \u2514\u2500\u252c\u2500\u2518\n     \u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2510\n   \u250c\u2500\u2534\u2500\u2510      \u250c\u2500\u2534\u2500\u2510\n   \u2502 b \u2502      \u2502 c \u2502\n   \u2514\u2500\u252c\u2500\u2518      \u2514\u2500\u2500\u2500\u2518\n  \u250c\u2500\u2500\u2534\u2500\u2500\u2500\u2510\n\u250c\u2500\u2534\u2500\u2510  \u250c\u2500\u2534\u2500\u2510\n\u2502 d \u2502  \u2502 e \u2502\n\u2514\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2518\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>T</code> <p>tree to print</p> required <code>alias</code> <code>str</code> <p>node attribute to use for node name in tree as alias to <code>node_name</code></p> <code>'node_name'</code> <code>node_name_or_path</code> <code>str</code> <p>node to print from, becomes the root node of printing</p> <code>''</code> <code>max_depth</code> <code>int</code> <p>maximum depth of tree to print, based on <code>depth</code> attribute</p> <code>0</code> <code>intermediate_node_name</code> <code>bool</code> <p>indicator if intermediate nodes have node names</p> <code>True</code> <code>spacing</code> <code>int</code> <p>horizontal spacing between node displays</p> <code>2</code> <code>style</code> <code>Union[str, Iterable[str], BaseVPrintStyle]</code> <p>style of print</p> <code>'const'</code> <code>border_style</code> <code>Optional[Union[str, Iterable[str], BorderStyle]]</code> <p>style of border</p> <code>'const'</code> <code>strip</code> <code>bool</code> <p>whether to strip results</p> <code>False</code>"},{"location":"bigtree/tree/export/#bigtree.tree.export.vyield_tree","title":"vyield_tree","text":"<pre><code>vyield_tree(\n    tree,\n    alias=\"node_name\",\n    node_name_or_path=\"\",\n    max_depth=0,\n    intermediate_node_name=True,\n    spacing=2,\n    style=\"const\",\n    border_style=\"const\",\n    strip=False,\n)\n</code></pre> <p>Yield tree in vertical orientation to console, starting from <code>tree</code>.</p> <ul> <li>Able to have alias for node name if alias attribute is present, else it falls back to node_name, using <code>alias</code></li> <li>Able to select which node to print from, resulting in a subtree, using <code>node_name_or_path</code></li> <li>Able to customise for maximum depth to print, using <code>max_depth</code></li> <li>Able to hide names of intermediate nodes, using <code>intermediate_node_name</code></li> <li>Able to select horizontal spacing between nodes, using <code>spacing</code></li> <li>Able to customise style, to choose from str, Iterable[str], or inherit from constants.BaseVPrintStyle, using <code>style</code></li> <li>Able to toggle border, with border style to choose from str, Iterable[str], or inherit from constants.BorderStyle,     using <code>border_style</code></li> <li>Able to have constant width output string or to strip the trailing spaces, using <code>strip</code></li> </ul> <p>For style,</p> <ul> <li>(str): <code>ansi</code>, <code>ascii</code>, <code>const</code> (default), <code>const_bold</code>, <code>rounded</code>, <code>double</code> style</li> <li>(Iterable[str]): Choose own style icons, they must be 1 character long</li> <li>(constants.BaseVPrintStyle): <code>ANSIVPrintStyle</code>, <code>ASCIIVPrintStyle</code>, <code>ConstVPrintStyle</code>, <code>ConstBoldVPrintStyle</code>,     <code>RoundedVPrintStyle</code>, <code>DoubleVPrintStyle</code> style or inherit from constants.BaseVPrintStyle</li> </ul> <p>For border_style,</p> <ul> <li>(str): <code>ansi</code>, <code>ascii</code>, <code>const</code> (default), <code>const_bold</code>, <code>rounded</code>, <code>double</code> style</li> <li>(Iterable[str]): Choose own style icons, they must be 1 character long</li> <li>(constants.BorderStyle): <code>ANSIBorderStyle</code>, <code>ASCIIBorderStyle</code>, <code>ConstBorderStyle</code>, <code>ConstBoldBorderStyle</code>,     <code>RoundedBorderStyle</code>, <code>DoubleBorderStyle</code> style or inherit from constants.BorderStyle</li> </ul> <p>Examples:</p> <p>Printing tree</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, vyield_tree\n&gt;&gt;&gt; root = Node(\"a\")\n&gt;&gt;&gt; b = Node(\"b\", parent=root)\n&gt;&gt;&gt; c = Node(\"c\", parent=root)\n&gt;&gt;&gt; d = Node(\"d\", parent=b)\n&gt;&gt;&gt; e = Node(\"e\", parent=b)\n&gt;&gt;&gt; result = vyield_tree(root, strip=True)\n&gt;&gt;&gt; print(\"\\n\".join(result))\n        \u250c\u2500\u2500\u2500\u2510\n        \u2502 a \u2502\n        \u2514\u2500\u252c\u2500\u2518\n     \u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2510\n   \u250c\u2500\u2534\u2500\u2510      \u250c\u2500\u2534\u2500\u2510\n   \u2502 b \u2502      \u2502 c \u2502\n   \u2514\u2500\u252c\u2500\u2518      \u2514\u2500\u2500\u2500\u2518\n  \u250c\u2500\u2500\u2534\u2500\u2500\u2500\u2510\n\u250c\u2500\u2534\u2500\u2510  \u250c\u2500\u2534\u2500\u2510\n\u2502 d \u2502  \u2502 e \u2502\n\u2514\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2518\n</code></pre> <p>Printing Sub-tree</p> <pre><code>&gt;&gt;&gt; result = vyield_tree(root, node_name_or_path=\"b\", strip=True)\n&gt;&gt;&gt; print(\"\\n\".join(result))\n   \u250c\u2500\u2500\u2500\u2510\n   \u2502 b \u2502\n   \u2514\u2500\u252c\u2500\u2518\n  \u250c\u2500\u2500\u2534\u2500\u2500\u2500\u2510\n\u250c\u2500\u2534\u2500\u2510  \u250c\u2500\u2534\u2500\u2510\n\u2502 d \u2502  \u2502 e \u2502\n\u2514\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>&gt;&gt;&gt; result = vyield_tree(root, max_depth=2, strip=True)\n&gt;&gt;&gt; print(\"\\n\".join(result))\n   \u250c\u2500\u2500\u2500\u2510\n   \u2502 a \u2502\n   \u2514\u2500\u252c\u2500\u2518\n  \u250c\u2500\u2500\u2534\u2500\u2500\u2500\u2510\n\u250c\u2500\u2534\u2500\u2510  \u250c\u2500\u2534\u2500\u2510\n\u2502 b \u2502  \u2502 c \u2502\n\u2514\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2518\n</code></pre> <p>Available Styles</p> <pre><code>&gt;&gt;&gt; result = vyield_tree(root, style=\"ansi\", border_style=\"ansi\", strip=True)\n&gt;&gt;&gt; print(\"\\n\".join(result))\n        `---`\n        | a |\n        `-+-`\n     /----+-----\\\n   `-+-`      `-+-`\n   | b |      | c |\n   `-+-`      `---`\n  /--+---\\\n`-+-`  `-+-`\n| d |  | e |\n`---`  `---`\n</code></pre> <pre><code>&gt;&gt;&gt; result = vyield_tree(root, style=\"ascii\", border_style=\"ascii\", strip=True)\n&gt;&gt;&gt; print(\"\\n\".join(result))\n        +---+\n        | a |\n        +-+-+\n     +----+-----+\n   +-+-+      +-+-+\n   | b |      | c |\n   +-+-+      +---+\n  +--+---+\n+-+-+  +-+-+\n| d |  | e |\n+---+  +---+\n</code></pre> <pre><code>&gt;&gt;&gt; result = vyield_tree(root, style=\"const\", border_style=\"const\", strip=True)\n&gt;&gt;&gt; print(\"\\n\".join(result))\n        \u250c\u2500\u2500\u2500\u2510\n        \u2502 a \u2502\n        \u2514\u2500\u252c\u2500\u2518\n     \u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2510\n   \u250c\u2500\u2534\u2500\u2510      \u250c\u2500\u2534\u2500\u2510\n   \u2502 b \u2502      \u2502 c \u2502\n   \u2514\u2500\u252c\u2500\u2518      \u2514\u2500\u2500\u2500\u2518\n  \u250c\u2500\u2500\u2534\u2500\u2500\u2500\u2510\n\u250c\u2500\u2534\u2500\u2510  \u250c\u2500\u2534\u2500\u2510\n\u2502 d \u2502  \u2502 e \u2502\n\u2514\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>&gt;&gt;&gt; result = vyield_tree(root, style=\"const_bold\", border_style=\"const_bold\", strip=True)\n&gt;&gt;&gt; print(\"\\n\".join(result))\n        \u250f\u2501\u2501\u2501\u2513\n        \u2503 a \u2503\n        \u2517\u2501\u2533\u2501\u251b\n     \u250f\u2501\u2501\u2501\u2501\u253b\u2501\u2501\u2501\u2501\u2501\u2513\n   \u250f\u2501\u253b\u2501\u2513      \u250f\u2501\u253b\u2501\u2513\n   \u2503 b \u2503      \u2503 c \u2503\n   \u2517\u2501\u2533\u2501\u251b      \u2517\u2501\u2501\u2501\u251b\n  \u250f\u2501\u2501\u253b\u2501\u2501\u2501\u2513\n\u250f\u2501\u253b\u2501\u2513  \u250f\u2501\u253b\u2501\u2513\n\u2503 d \u2503  \u2503 e \u2503\n\u2517\u2501\u2501\u2501\u251b  \u2517\u2501\u2501\u2501\u251b\n</code></pre> <pre><code>&gt;&gt;&gt; result = vyield_tree(root, style=\"rounded\", border_style=\"rounded\", strip=True)\n&gt;&gt;&gt; print(\"\\n\".join(result))\n        \u256d\u2500\u2500\u2500\u256e\n        \u2502 a \u2502\n        \u2570\u2500\u252c\u2500\u256f\n     \u256d\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u256e\n   \u256d\u2500\u2534\u2500\u256e      \u256d\u2500\u2534\u2500\u256e\n   \u2502 b \u2502      \u2502 c \u2502\n   \u2570\u2500\u252c\u2500\u256f      \u2570\u2500\u2500\u2500\u256f\n  \u256d\u2500\u2500\u2534\u2500\u2500\u2500\u256e\n\u256d\u2500\u2534\u2500\u256e  \u256d\u2500\u2534\u2500\u256e\n\u2502 d \u2502  \u2502 e \u2502\n\u2570\u2500\u2500\u2500\u256f  \u2570\u2500\u2500\u2500\u256f\n</code></pre> <pre><code>&gt;&gt;&gt; result = vyield_tree(root, style=\"double\", border_style=\"double\", strip=True)\n&gt;&gt;&gt; print(\"\\n\".join(result))\n        \u2554\u2550\u2550\u2550\u2557\n        \u2551 a \u2551\n        \u255a\u2550\u2566\u2550\u255d\n     \u2554\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2557\n   \u2554\u2550\u2569\u2550\u2557      \u2554\u2550\u2569\u2550\u2557\n   \u2551 b \u2551      \u2551 c \u2551\n   \u255a\u2550\u2566\u2550\u255d      \u255a\u2550\u2550\u2550\u255d\n  \u2554\u2550\u2550\u2569\u2550\u2550\u2550\u2557\n\u2554\u2550\u2569\u2550\u2557  \u2554\u2550\u2569\u2550\u2557\n\u2551 d \u2551  \u2551 e \u2551\n\u255a\u2550\u2550\u2550\u255d  \u255a\u2550\u2550\u2550\u255d\n</code></pre> <p>Custom Styles</p> <pre><code>&gt;&gt;&gt; from bigtree import RoundedVPrintStyle, RoundedBorderStyle\n&gt;&gt;&gt; result = vyield_tree(root, style=RoundedVPrintStyle, border_style=RoundedBorderStyle, strip=True)\n&gt;&gt;&gt; print(\"\\n\".join(result))\n        \u256d\u2500\u2500\u2500\u256e\n        \u2502 a \u2502\n        \u2570\u2500\u252c\u2500\u256f\n     \u256d\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u256e\n   \u256d\u2500\u2534\u2500\u256e      \u256d\u2500\u2534\u2500\u256e\n   \u2502 b \u2502      \u2502 c \u2502\n   \u2570\u2500\u252c\u2500\u256f      \u2570\u2500\u2500\u2500\u256f\n  \u256d\u2500\u2500\u2534\u2500\u2500\u2500\u256e\n\u256d\u2500\u2534\u2500\u256e  \u256d\u2500\u2534\u2500\u256e\n\u2502 d \u2502  \u2502 e \u2502\n\u2570\u2500\u2500\u2500\u256f  \u2570\u2500\u2500\u2500\u256f\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>T</code> <p>tree to print</p> required <code>alias</code> <code>str</code> <p>node attribute to use for node name in tree as alias to <code>node_name</code></p> <code>'node_name'</code> <code>node_name_or_path</code> <code>str</code> <p>node to print from, becomes the root node of printing</p> <code>''</code> <code>max_depth</code> <code>int</code> <p>maximum depth of tree to print, based on <code>depth</code> attribute</p> <code>0</code> <code>intermediate_node_name</code> <code>bool</code> <p>indicator if intermediate nodes have node names</p> <code>True</code> <code>spacing</code> <code>int</code> <p>horizontal spacing between node displays</p> <code>2</code> <code>style</code> <code>Union[str, Iterable[str], BaseVPrintStyle]</code> <p>style of print</p> <code>'const'</code> <code>border_style</code> <code>Optional[Union[str, Iterable[str], BorderStyle]]</code> <p>style of border</p> <code>'const'</code> <code>strip</code> <code>bool</code> <p>whether to strip results</p> <code>False</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>Yield tree in vertical format</p>"},{"location":"bigtree/tree/export/#bigtree.tree.export.yield_tree","title":"yield_tree","text":"<pre><code>yield_tree(\n    tree, node_name_or_path=\"\", max_depth=0, style=\"const\"\n)\n</code></pre> <p>Generator method for customizing printing of tree, starting from <code>tree</code>.</p> <ul> <li>Able to select which node to print from, resulting in a subtree, using <code>node_name_or_path</code></li> <li>Able to customise for maximum depth to print, using <code>max_depth</code></li> <li>Able to customise style, to choose from str, List[str], or inherit from constants.BasePrintStyle, using <code>style</code></li> </ul> <p>For style,</p> <ul> <li>(str): <code>ansi</code>, <code>ascii</code>, <code>const</code> (default), <code>const_bold</code>, <code>rounded</code>, <code>double</code> style</li> <li>(List[str]): Choose own style for stem, branch, and final stem icons, they must have the same number of characters</li> <li>(constants.BasePrintStyle): <code>ANSIPrintStyle</code>, <code>ASCIIPrintStyle</code>, <code>ConstPrintStyle</code>, <code>ConstBoldPrintStyle</code>,     <code>RoundedPrintStyle</code>, <code>DoublePrintStyle</code> style or inherit from <code>constants.BasePrintStyle</code></li> </ul> <p>Examples:</p> <p>Yield tree</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, yield_tree\n&gt;&gt;&gt; root = Node(\"a\", age=90)\n&gt;&gt;&gt; b = Node(\"b\", age=65, parent=root)\n&gt;&gt;&gt; c = Node(\"c\", age=60, parent=root)\n&gt;&gt;&gt; d = Node(\"d\", age=40, parent=b)\n&gt;&gt;&gt; e = Node(\"e\", age=35, parent=b)\n&gt;&gt;&gt; for branch, stem, node in yield_tree(root):\n...     print(f\"{branch}{stem}{node.node_name}\")\na\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 d\n\u2502   \u2514\u2500\u2500 e\n\u2514\u2500\u2500 c\n</code></pre> <p>Yield Sub-tree</p> <pre><code>&gt;&gt;&gt; for branch, stem, node in yield_tree(root, node_name_or_path=\"b\"):\n...     print(f\"{branch}{stem}{node.node_name}\")\nb\n\u251c\u2500\u2500 d\n\u2514\u2500\u2500 e\n</code></pre> <pre><code>&gt;&gt;&gt; for branch, stem, node in yield_tree(root, max_depth=2):\n...     print(f\"{branch}{stem}{node.node_name}\")\na\n\u251c\u2500\u2500 b\n\u2514\u2500\u2500 c\n</code></pre> <p>Available Styles</p> <pre><code>&gt;&gt;&gt; for branch, stem, node in yield_tree(root, style=\"ansi\"):\n...     print(f\"{branch}{stem}{node.node_name}\")\na\n|-- b\n|   |-- d\n|   `-- e\n`-- c\n</code></pre> <pre><code>&gt;&gt;&gt; for branch, stem, node in yield_tree(root, style=\"ascii\"):\n...     print(f\"{branch}{stem}{node.node_name}\")\na\n|-- b\n|   |-- d\n|   +-- e\n+-- c\n</code></pre> <pre><code>&gt;&gt;&gt; for branch, stem, node in yield_tree(root, style=\"const\"):\n...     print(f\"{branch}{stem}{node.node_name}\")\na\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 d\n\u2502   \u2514\u2500\u2500 e\n\u2514\u2500\u2500 c\n</code></pre> <pre><code>&gt;&gt;&gt; for branch, stem, node in yield_tree(root, style=\"const_bold\"):\n...     print(f\"{branch}{stem}{node.node_name}\")\na\n\u2523\u2501\u2501 b\n\u2503   \u2523\u2501\u2501 d\n\u2503   \u2517\u2501\u2501 e\n\u2517\u2501\u2501 c\n</code></pre> <pre><code>&gt;&gt;&gt; for branch, stem, node in yield_tree(root, style=\"rounded\"):\n...     print(f\"{branch}{stem}{node.node_name}\")\na\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 d\n\u2502   \u2570\u2500\u2500 e\n\u2570\u2500\u2500 c\n</code></pre> <pre><code>&gt;&gt;&gt; for branch, stem, node in yield_tree(root, style=\"double\"):\n...     print(f\"{branch}{stem}{node.node_name}\")\na\n\u2560\u2550\u2550 b\n\u2551   \u2560\u2550\u2550 d\n\u2551   \u255a\u2550\u2550 e\n\u255a\u2550\u2550 c\n</code></pre> <p>Custom Styles</p> <pre><code>&gt;&gt;&gt; from bigtree import ANSIPrintStyle\n&gt;&gt;&gt; for branch, stem, node in yield_tree(root, style=ANSIPrintStyle):\n...     print(f\"{branch}{stem}{node.node_name}\")\na\n|-- b\n|   |-- d\n|   `-- e\n`-- c\n</code></pre> <p>Printing Attributes</p> <pre><code>&gt;&gt;&gt; for branch, stem, node in yield_tree(root, style=\"const\"):\n...     print(f\"{branch}{stem}{node.node_name} [age={node.age}]\")\na [age=90]\n\u251c\u2500\u2500 b [age=65]\n\u2502   \u251c\u2500\u2500 d [age=40]\n\u2502   \u2514\u2500\u2500 e [age=35]\n\u2514\u2500\u2500 c [age=60]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>T</code> <p>tree to print</p> required <code>node_name_or_path</code> <code>str</code> <p>node to print from, becomes the root node of printing</p> <code>''</code> <code>max_depth</code> <code>int</code> <p>maximum depth of tree to print, based on <code>depth</code> attribute</p> <code>0</code> <code>style</code> <code>Union[str, Iterable[str], BasePrintStyle]</code> <p>style of print</p> <code>'const'</code> <p>Returns:</p> Type Description <code>Iterable[Tuple[str, str, T]]</code> <p>Yields tree in format branch, stem, and node</p>"},{"location":"bigtree/tree/helper/","title":"\ud83d\udd27 Helper","text":"<p>Helper functions that can come in handy.</p>"},{"location":"bigtree/tree/helper/#bigtree.tree.helper","title":"bigtree.tree.helper","text":""},{"location":"bigtree/tree/helper/#bigtree.tree.helper.clone_tree","title":"clone_tree","text":"<pre><code>clone_tree(tree, node_type)\n</code></pre> <p>Clone tree to another <code>Node</code> type. If the same type is needed, simply do a tree.copy().</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import BaseNode, Node, clone_tree\n&gt;&gt;&gt; root = BaseNode(name=\"a\")\n&gt;&gt;&gt; b = BaseNode(name=\"b\", parent=root)\n&gt;&gt;&gt; clone_tree(root, Node)\nNode(/a, )\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>BaseNode</code> <p>tree to be cloned, must inherit from BaseNode</p> required <code>node_type</code> <code>Type[BaseNodeT]</code> <p>type of cloned tree</p> required <p>Returns:</p> Type Description <code>BaseNodeT</code> <p>Cloned tree of another Node type</p>"},{"location":"bigtree/tree/helper/#bigtree.tree.helper.get_subtree","title":"get_subtree","text":"<pre><code>get_subtree(tree, node_name_or_path='', max_depth=0)\n</code></pre> <p>Get subtree based on node name or node path, and/or maximum depth of tree. Subtrees are smaller trees with different root. Returns a copy of the tree; does not affect original tree.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, get_subtree\n&gt;&gt;&gt; root = Node(\"a\")\n&gt;&gt;&gt; b = Node(\"b\", parent=root)\n&gt;&gt;&gt; c = Node(\"c\", parent=b)\n&gt;&gt;&gt; d = Node(\"d\", parent=b)\n&gt;&gt;&gt; e = Node(\"e\", parent=root)\n&gt;&gt;&gt; root.show()\na\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 c\n\u2502   \u2514\u2500\u2500 d\n\u2514\u2500\u2500 e\n</code></pre> <p>Get subtree</p> <pre><code>&gt;&gt;&gt; root_subtree = get_subtree(root, \"b\")\n&gt;&gt;&gt; root_subtree.show()\nb\n\u251c\u2500\u2500 c\n\u2514\u2500\u2500 d\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>NodeT</code> <p>existing tree</p> required <code>node_name_or_path</code> <code>str</code> <p>node name or path to get subtree</p> <code>''</code> <code>max_depth</code> <code>int</code> <p>maximum depth of subtree, based on <code>depth</code> attribute</p> <code>0</code> <p>Returns:</p> Type Description <code>NodeT</code> <p>Subtree</p>"},{"location":"bigtree/tree/helper/#bigtree.tree.helper.prune_tree","title":"prune_tree","text":"<pre><code>prune_tree(\n    tree, prune_path=\"\", exact=False, sep=\"/\", max_depth=0\n)\n</code></pre> <p>Prune tree by path or depth. Pruned trees are smaller trees with same root. Returns a copy of the tree; does not affect original tree.</p> <p>For pruning by <code>prune_path</code>,</p> <ul> <li>All siblings along the prune path will be removed. All descendants will be kept by default</li> <li>If <code>exact=True</code>, all descendants of prune path will be removed</li> <li>Prune path can be string (only one path) or a list of strings (multiple paths)</li> <li>Prune path name should be unique, can be full path, partial path (trailing part of path), or node name</li> </ul> <p>For pruning by <code>max_depth</code>,</p> <ul> <li>All nodes that are beyond <code>max_depth</code> will be removed</li> </ul> <p>Path should contain <code>Node</code> name, separated by <code>sep</code>.</p> <ul> <li>For example: Path string \"a/b\" refers to Node(\"b\") with parent Node(\"a\")</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, prune_tree\n&gt;&gt;&gt; root = Node(\"a\")\n&gt;&gt;&gt; b = Node(\"b\", parent=root)\n&gt;&gt;&gt; c = Node(\"c\", parent=b)\n&gt;&gt;&gt; d = Node(\"d\", parent=b)\n&gt;&gt;&gt; e = Node(\"e\", parent=root)\n&gt;&gt;&gt; root.show()\na\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 c\n\u2502   \u2514\u2500\u2500 d\n\u2514\u2500\u2500 e\n</code></pre> <p>Prune tree</p> <pre><code>&gt;&gt;&gt; root_pruned = prune_tree(root, \"a/b\")\n&gt;&gt;&gt; root_pruned.show()\na\n\u2514\u2500\u2500 b\n    \u251c\u2500\u2500 c\n    \u2514\u2500\u2500 d\n</code></pre> <p>Prune by exact path</p> <pre><code>&gt;&gt;&gt; root_pruned = prune_tree(root, \"a/b\", exact=True)\n&gt;&gt;&gt; root_pruned.show()\na\n\u2514\u2500\u2500 b\n</code></pre> <p>Prune by multiple paths</p> <pre><code>&gt;&gt;&gt; root_pruned = prune_tree(root, [\"a/b/d\", \"a/e\"])\n&gt;&gt;&gt; root_pruned.show()\na\n\u251c\u2500\u2500 b\n\u2502   \u2514\u2500\u2500 d\n\u2514\u2500\u2500 e\n</code></pre> <p>Prune by depth</p> <pre><code>&gt;&gt;&gt; root_pruned = prune_tree(root, max_depth=2)\n&gt;&gt;&gt; root_pruned.show()\na\n\u251c\u2500\u2500 b\n\u2514\u2500\u2500 e\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>Union[BinaryNodeT, NodeT]</code> <p>existing tree</p> required <code>prune_path</code> <code>Union[List[str], str]</code> <p>prune path(s), all siblings along the prune path(s) will be removed</p> <code>''</code> <code>exact</code> <code>bool</code> <p>prune path(s) to be exactly the path and remove descendants</p> <code>False</code> <code>sep</code> <code>str</code> <p>path separator of <code>prune_path</code></p> <code>'/'</code> <code>max_depth</code> <code>int</code> <p>maximum depth of pruned tree, based on <code>depth</code> attribute</p> <code>0</code> <p>Returns:</p> Type Description <code>Union[BinaryNodeT, NodeT]</code> <p>Pruned tree</p>"},{"location":"bigtree/tree/helper/#bigtree.tree.helper.get_tree_diff_dataframe","title":"get_tree_diff_dataframe","text":"<pre><code>get_tree_diff_dataframe(\n    tree,\n    other_tree,\n    only_diff=True,\n    detail=False,\n    aggregate=False,\n    attr_list=[],\n    fallback_sep=\"/\",\n    name_col=\"name\",\n    path_col=\"path\",\n    parent_col=\"parent\",\n    indicator_col=\"Exists\",\n    old_suffix=\"_old\",\n    new_suffix=\"_new\",\n    suffix_col=\"suffix\",\n)\n</code></pre> <p>Get difference of <code>tree</code> to <code>other_tree</code>, changes are relative to <code>tree</code>. This function exports both trees to pandas DataFrame, merge them, and adds new suffix column to indicate the type of differences in both trees.</p>"},{"location":"bigtree/tree/helper/#bigtree.tree.helper.get_tree_diff_dataframe--comparing-tree-structure","title":"Comparing tree structure","text":"<p>By default, suffix will be '+' and '-' for the tree differences, and np.nan for the others.</p> <ul> <li>If <code>detail=True</code>, 'added' and 'moved to' will be used instead of '+', and 'removed' and 'moved from' will be used instead of '-'</li> <li>If <code>aggregate=True</code>, suffix will only be indicated at the parent-level. This is useful when a subtree is shifted and we want the differences shown only at the top node</li> </ul>"},{"location":"bigtree/tree/helper/#bigtree.tree.helper.get_tree_diff_dataframe--compare-tree-attribute","title":"Compare tree attribute","text":"<p>Attributes indicated in <code>attr_list</code> will be exported in the pandas DataFrame with suffixes representing attributes from <code>tree</code> and <code>other_tree</code> respectively.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Create original tree\n&gt;&gt;&gt; from bigtree import Node, get_tree_diff_dataframe, list_to_tree\n&gt;&gt;&gt; root = list_to_tree([\"Downloads/Pictures/photo1.jpg\", \"Downloads/file1.doc\", \"Downloads/Trip/photo2.jpg\"])\n&gt;&gt;&gt; root.show()\nDownloads\n\u251c\u2500\u2500 Pictures\n\u2502   \u2514\u2500\u2500 photo1.jpg\n\u251c\u2500\u2500 file1.doc\n\u2514\u2500\u2500 Trip\n    \u2514\u2500\u2500 photo2.jpg\n</code></pre> <pre><code>&gt;&gt;&gt; # Create other tree\n&gt;&gt;&gt; root_other = list_to_tree(\n...     [\"Downloads/Pictures/photo1.jpg\", \"Downloads/Pictures/Trip/photo2.jpg\", \"Downloads/file1.doc\", \"Downloads/file2.doc\"]\n... )\n&gt;&gt;&gt; root_other.show()\nDownloads\n\u251c\u2500\u2500 Pictures\n\u2502   \u251c\u2500\u2500 photo1.jpg\n\u2502   \u2514\u2500\u2500 Trip\n\u2502       \u2514\u2500\u2500 photo2.jpg\n\u251c\u2500\u2500 file1.doc\n\u2514\u2500\u2500 file2.doc\n</code></pre> <p>Comparing tree structure</p> <pre><code>&gt;&gt;&gt; get_tree_diff_dataframe(root, root_other, detail=True)\n                                  path        name     parent      Exists      suffix\n0                           /Downloads   Downloads       None        both         NaN\n1                  /Downloads/Pictures    Pictures  Downloads        both         NaN\n2             /Downloads/Pictures/Trip        Trip   Pictures  right_only    moved to\n3  /Downloads/Pictures/Trip/photo2.jpg  photo2.jpg       Trip  right_only    moved to\n4       /Downloads/Pictures/photo1.jpg  photo1.jpg   Pictures        both         NaN\n5                      /Downloads/Trip        Trip  Downloads   left_only  moved from\n6           /Downloads/Trip/photo2.jpg  photo2.jpg       Trip   left_only  moved from\n7                 /Downloads/file1.doc   file1.doc  Downloads        both         NaN\n8                 /Downloads/file2.doc   file2.doc  Downloads  right_only       added\n</code></pre> <p>Note</p> <ul> <li>tree and other_tree must have the same <code>sep</code> symbol, otherwise this will raise ValueError</li> <li>If the <code>sep</code> symbol contains one of <code>+</code> / <code>-</code> / <code>~</code> character, a fallback sep will be used</li> <li>Node names in tree and other_tree must not contain the <code>sep</code> (or fallback sep) symbol</li> </ul> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>Node</code> <p>tree to be compared against</p> required <code>other_tree</code> <code>Node</code> <p>tree to be compared with</p> required <code>only_diff</code> <code>bool</code> <p>if aggregate and only_diff are True, child nodes that are moved from tree will be removed</p> <code>True</code> <code>detail</code> <code>bool</code> <p>by default, suffix column will display \"+\" and \"-\". If detail is True, suffix column will be more detailed, displaying \"moved from\" / \"moved to\" / \"added\" / \"removed\" instead</p> <code>False</code> <code>aggregate</code> <code>bool</code> <p>by default, all nodes that are different will have suffix specified. If aggregate is True, only parent-level node have suffixes and nodes that have different paths but same parent will not have suffix</p> <code>False</code> <code>attr_list</code> <code>List[str]</code> <p>tree attributes to retrieve from tree and other_tree</p> <code>[]</code> <code>fallback_sep</code> <code>str</code> <p>sep to fall back to if tree and other_tree has sep that clashes with symbols \"+\" / \"-\" / \"~\". All node names in tree and other_tree should not contain this fallback_sep</p> <code>'/'</code> <code>name_col</code> <code>str</code> <p>name column of return dataframe, indicates the name of node</p> <code>'name'</code> <code>path_col</code> <code>str</code> <p>path column of return dataframe, indicates the full path of node</p> <code>'path'</code> <code>parent_col</code> <code>str</code> <p>parent column of return dataframe, indicates the parent name of node</p> <code>'parent'</code> <code>indicator_col</code> <code>str</code> <p>indicator column of return dataframe, indicates whether node appears in left_only, right_only or both tree</p> <code>'Exists'</code> <code>old_suffix</code> <code>str</code> <p>suffix given to attributes from tree of return dataframe, relevant if attr_list is specified</p> <code>'_old'</code> <code>new_suffix</code> <code>str</code> <p>suffix given to attributes from other_tree of return dataframe, relevant if attr_list is specified</p> <code>'_new'</code> <code>suffix_col</code> <code>str</code> <p>suffix column of return dataframe, indicates the type of diff whether it is added, removed, or moved</p> <code>'suffix'</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Dataframe of tree differences</p>"},{"location":"bigtree/tree/helper/#bigtree.tree.helper.get_tree_diff","title":"get_tree_diff","text":"<pre><code>get_tree_diff(\n    tree,\n    other_tree,\n    only_diff=True,\n    detail=False,\n    aggregate=False,\n    attr_list=[],\n    fallback_sep=\"/\",\n)\n</code></pre> <p>Get difference of <code>tree</code> to <code>other_tree</code>, changes are relative to <code>tree</code>.</p> <p>Compares the difference in tree structure (default), but can also compare tree attributes using <code>attr_list</code>. Function can return only the differences (default), or all original tree nodes and differences.</p>"},{"location":"bigtree/tree/helper/#bigtree.tree.helper.get_tree_diff--comparing-tree-structure","title":"Comparing tree structure","text":"<ul> <li>(+) and (-) will be added to node name relative to <code>tree</code></li> <li>For example: (+) refers to nodes that are in <code>other_tree</code> but not <code>tree</code></li> <li>For example: (-) refers to nodes that are in <code>tree</code> but not <code>other_tree</code></li> </ul> <p>If <code>detail=True</code>, (added) and (moved to) will be used instead of (+), (removed) and (moved from) will be used instead of (-).</p> <p>If <code>aggregate=True</code>, differences (+)/(added)/(moved to) and (-)/(removed)/(moved from) will only be indicated at the parent-level. This is useful when a subtree is shifted, and we want the differences shown only at the top node.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Create original tree\n&gt;&gt;&gt; from bigtree import Node, get_tree_diff, list_to_tree\n&gt;&gt;&gt; root = list_to_tree([\"Downloads/Pictures/photo1.jpg\", \"Downloads/file1.doc\", \"Downloads/Trip/photo2.jpg\"])\n&gt;&gt;&gt; root.show()\nDownloads\n\u251c\u2500\u2500 Pictures\n\u2502   \u2514\u2500\u2500 photo1.jpg\n\u251c\u2500\u2500 file1.doc\n\u2514\u2500\u2500 Trip\n    \u2514\u2500\u2500 photo2.jpg\n</code></pre> <pre><code>&gt;&gt;&gt; # Create other tree\n&gt;&gt;&gt; root_other = list_to_tree(\n...     [\"Downloads/Pictures/photo1.jpg\", \"Downloads/Pictures/Trip/photo2.jpg\", \"Downloads/file1.doc\", \"Downloads/file2.doc\"]\n... )\n&gt;&gt;&gt; root_other.show()\nDownloads\n\u251c\u2500\u2500 Pictures\n\u2502   \u251c\u2500\u2500 photo1.jpg\n\u2502   \u2514\u2500\u2500 Trip\n\u2502       \u2514\u2500\u2500 photo2.jpg\n\u251c\u2500\u2500 file1.doc\n\u2514\u2500\u2500 file2.doc\n</code></pre> <p>Comparing tree structure</p> <pre><code>&gt;&gt;&gt; tree_diff = get_tree_diff(root, root_other)\n&gt;&gt;&gt; tree_diff.show()\nDownloads\n\u251c\u2500\u2500 Pictures\n\u2502   \u2514\u2500\u2500 Trip (+)\n\u2502       \u2514\u2500\u2500 photo2.jpg (+)\n\u251c\u2500\u2500 Trip (-)\n\u2502   \u2514\u2500\u2500 photo2.jpg (-)\n\u2514\u2500\u2500 file2.doc (+)\n</code></pre> <p>All differences</p> <pre><code>&gt;&gt;&gt; tree_diff = get_tree_diff(root, root_other, only_diff=False)\n&gt;&gt;&gt; tree_diff.show()\nDownloads\n\u251c\u2500\u2500 Pictures\n\u2502   \u251c\u2500\u2500 Trip (+)\n\u2502   \u2502   \u2514\u2500\u2500 photo2.jpg (+)\n\u2502   \u2514\u2500\u2500 photo1.jpg\n\u251c\u2500\u2500 Trip (-)\n\u2502   \u2514\u2500\u2500 photo2.jpg (-)\n\u251c\u2500\u2500 file1.doc\n\u2514\u2500\u2500 file2.doc (+)\n</code></pre> <p>All differences with details</p> <pre><code>&gt;&gt;&gt; tree_diff = get_tree_diff(\n...     root, root_other, only_diff=False, detail=True\n... )\n&gt;&gt;&gt; tree_diff.show()\nDownloads\n\u251c\u2500\u2500 Pictures\n\u2502   \u251c\u2500\u2500 Trip (moved to)\n\u2502   \u2502   \u2514\u2500\u2500 photo2.jpg (moved to)\n\u2502   \u2514\u2500\u2500 photo1.jpg\n\u251c\u2500\u2500 Trip (moved from)\n\u2502   \u2514\u2500\u2500 photo2.jpg (moved from)\n\u251c\u2500\u2500 file1.doc\n\u2514\u2500\u2500 file2.doc (added)\n</code></pre> <p>All differences with details on aggregated level</p> <pre><code>&gt;&gt;&gt; tree_diff = get_tree_diff(\n...     root, root_other, only_diff=False, detail=True, aggregate=True\n... )\n&gt;&gt;&gt; tree_diff.show()\nDownloads\n\u251c\u2500\u2500 Pictures\n\u2502   \u251c\u2500\u2500 Trip (moved to)\n\u2502   \u2502   \u2514\u2500\u2500 photo2.jpg\n\u2502   \u2514\u2500\u2500 photo1.jpg\n\u251c\u2500\u2500 Trip (moved from)\n\u2502   \u2514\u2500\u2500 photo2.jpg\n\u251c\u2500\u2500 file1.doc\n\u2514\u2500\u2500 file2.doc (added)\n</code></pre> <p>Only differences with details on aggregated level</p> <pre><code>&gt;&gt;&gt; tree_diff = get_tree_diff(root, root_other, detail=True, aggregate=True)\n&gt;&gt;&gt; tree_diff.show()\nDownloads\n\u251c\u2500\u2500 Pictures\n\u2502   \u2514\u2500\u2500 Trip (moved to)\n\u2502       \u2514\u2500\u2500 photo2.jpg\n\u251c\u2500\u2500 Trip (moved from)\n\u2514\u2500\u2500 file2.doc (added)\n</code></pre>"},{"location":"bigtree/tree/helper/#bigtree.tree.helper.get_tree_diff--comparing-tree-attribute","title":"Comparing tree attribute","text":"<ul> <li>(~) will be added to node name if there are differences in tree attributes defined in <code>attr_list</code></li> <li>The node's attributes will be a list of [value in <code>tree</code>, value in <code>other_tree</code>]</li> </ul> <pre><code>&gt;&gt;&gt; # Create original tree\n&gt;&gt;&gt; root = Node(\"Downloads\")\n&gt;&gt;&gt; picture_folder = Node(\"Pictures\", parent=root)\n&gt;&gt;&gt; photo2 = Node(\"photo1.jpg\", tags=\"photo1\", parent=picture_folder)\n&gt;&gt;&gt; file1 = Node(\"file1.doc\", tags=\"file1\", parent=root)\n&gt;&gt;&gt; root.show(attr_list=[\"tags\"])\nDownloads\n\u251c\u2500\u2500 Pictures\n\u2502   \u2514\u2500\u2500 photo1.jpg [tags=photo1]\n\u2514\u2500\u2500 file1.doc [tags=file1]\n</code></pre> <pre><code>&gt;&gt;&gt; # Create other tree\n&gt;&gt;&gt; root_other = Node(\"Downloads\")\n&gt;&gt;&gt; picture_folder = Node(\"Pictures\", parent=root_other)\n&gt;&gt;&gt; photo1 = Node(\"photo1.jpg\", tags=\"photo1-edited\", parent=picture_folder)\n&gt;&gt;&gt; photo2 = Node(\"photo2.jpg\", tags=\"photo2-new\", parent=picture_folder)\n&gt;&gt;&gt; file1 = Node(\"file1.doc\", tags=\"file1\", parent=root_other)\n&gt;&gt;&gt; root_other.show(attr_list=[\"tags\"])\nDownloads\n\u251c\u2500\u2500 Pictures\n\u2502   \u251c\u2500\u2500 photo1.jpg [tags=photo1-edited]\n\u2502   \u2514\u2500\u2500 photo2.jpg [tags=photo2-new]\n\u2514\u2500\u2500 file1.doc [tags=file1]\n</code></pre> <pre><code>&gt;&gt;&gt; # Get tree attribute differences\n&gt;&gt;&gt; tree_diff = get_tree_diff(root, root_other, attr_list=[\"tags\"])\n&gt;&gt;&gt; tree_diff.show(attr_list=[\"tags\"])\nDownloads\n\u2514\u2500\u2500 Pictures\n    \u251c\u2500\u2500 photo1.jpg (~) [tags=('photo1', 'photo1-edited')]\n    \u2514\u2500\u2500 photo2.jpg (+)\n</code></pre> <p>Note</p> <ul> <li>tree and other_tree must have the same <code>sep</code> symbol, otherwise this will raise ValueError</li> <li>If the <code>sep</code> symbol contains one of <code>+</code> / <code>-</code> / <code>~</code> character, a fallback sep will be used</li> <li>Node names in tree and other_tree must not contain the <code>sep</code> (or fallback sep) symbol</li> </ul> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>Node</code> <p>tree to be compared against</p> required <code>other_tree</code> <code>Node</code> <p>tree to be compared with</p> required <code>only_diff</code> <code>bool</code> <p>indicator to show all nodes or only nodes that are different (+/-)</p> <code>True</code> <code>detail</code> <code>bool</code> <p>indicator to differentiate between different types of diff e.g., added or removed or moved</p> <code>False</code> <code>aggregate</code> <code>bool</code> <p>indicator to only add difference indicator to parent-level e.g., when shifting subtrees</p> <code>False</code> <code>attr_list</code> <code>List[str]</code> <p>tree attributes to check for difference</p> <code>[]</code> <code>fallback_sep</code> <code>str</code> <p>sep to fall back to if tree and other_tree has sep that clashes with symbols \"+\" / \"-\" / \"~\". All node names in tree and other_tree should not contain this fallback_sep</p> <code>'/'</code> <p>Returns:</p> Type Description <code>Node</code> <p>Tree highlighting the difference between tree and other_tree</p>"},{"location":"bigtree/tree/modify/","title":"\ud83d\udcdd Modify","text":"<p>There are two types of modification available</p> <ol> <li>Non-replacing scenario: Shift or copy nodes within same tree or between two trees using <code>from_paths</code> (list of paths) and <code>to_paths</code> (list of paths)</li> <li>Replacing scenario: Shift or copy nodes within same tree or between two trees while replacing the to-node using <code>from_paths</code> (list of paths) and <code>to_paths</code> (list of paths)</li> </ol>"},{"location":"bigtree/tree/modify/#available-configurations-for-customisation","title":"Available Configurations for Customisation","text":"<p>In non-replacing scenario, there are several configurations available for customisation.</p> Configuration Description Default Value <code>copy</code> Indicates whether it is to shift the nodes, or copy the nodes False (nodes are shifted, not copied) <code>to_tree</code> Indicates whether shifting/copying is within the same tree, or between different trees None (nodes are shifted/copied within the same tree) <code>skippable</code> Skip shifting/copying of nodes if from_path cannot be found False (from-node must be found) <code>overriding</code> Override existing node if it exists False (to-node must not exist) <code>merge_attribute</code> Merge attributes of existing node if it exists False (to-node must not exist, attributes are not merged) <code>merge_children</code> Shift/copy children of from-node and remove intermediate parent node False (children are not merged) <code>merge_leaves</code> Shift/copy leaves of from-node and remove all intermediate nodes False (leaves are not merged) <code>delete_children</code> Shift/copy node only and delete its children False (nodes are shifted/copied together with children) <p>In replacing scenario, all the configurations are also available except <code>overriding</code>, <code>merge_attribute</code>, <code>merge_children</code>, and <code>merge_leaves</code> as it is doing a one-to-one replacement. It is by default overriding, and there is nothing to merge.</p> <p>Note</p> <p><code>overriding</code> and <code>merge_attribute</code> cannot be simultaneously set to <code>True</code>. One deals with clashing nodes by overriding, another deals with it by merging attributes of both nodes.</p> <p>Note</p> <p><code>merge_children</code> and <code>merge_leaves</code> cannot be simultaneously set to <code>True</code>.</p> <p>Note</p> <p>Error will always be thrown if multiple from-nodes are found, paths in <code>from_paths</code> must be unique.</p>"},{"location":"bigtree/tree/modify/#tree-modification-permutations","title":"Tree Modification Permutations","text":"<p>There are several ways you can mix and match the tree modification methods. If you know all the parameters to choose, feel free to use <code>copy_or_shift_logic</code> or <code>replace_logic</code> methods as they are the most customizable. All other methods call these 2 methods directly.</p> Shift / Copy? Same tree / Between two trees? Replace destination node? Method to use Shift Same tree No <code>shift_nodes</code> Copy Same tree No <code>copy_nodes</code> Copy Between two trees No <code>copy_nodes_from_tree_to_tree</code> Any Any No <code>copy_or_shift_logic</code> Shift Same tree Yes <code>shift_and_replace_nodes</code> Copy Between two trees Yes <code>copy_and_replace_nodes_from_tree_to_tree</code> Any Any Yes <code>replace_logic</code>"},{"location":"bigtree/tree/modify/#tree-modification-illustration","title":"Tree Modification Illustration","text":""},{"location":"bigtree/tree/modify/#sample-tree-modification-shift-copy-delete","title":"Sample Tree Modification (Shift, Copy, Delete)","text":"Setting Sample path in <code>from_paths</code> Sample path in <code>to_paths</code> Description Default \"/a/c\" \"/a/b/c\" Shift/copy node <code>c</code> Default \"/c\" \"/a/b/c\" Shift/copy node <code>c</code> Default \"c\" \"/a/b/c\" Shift/copy node <code>c</code> Default \"/a/e\" None Delete node <code>e</code> skippable \"/a/c\" \"/a/b/c\" Shift/copy node <code>c</code>, skip if \"/a/c\" cannot be found"},{"location":"bigtree/tree/modify/#sample-tree-modification-advanced","title":"Sample Tree Modification (Advanced)","text":"Setting Sample path in <code>from_paths</code> Sample path in <code>to_paths</code> Description overriding \"a/b/c\" \"a/d/c\" Shift/copy node <code>c</code>, override if \"a/d/c\" exists merge_children \"a/b/c\" \"a/d/c\" If path not present: Shift/copy children of node <code>c</code> to be children of node <code>d</code>, removing node <code>c</code>If path present: Shift/copy children of node <code>c</code> to be merged with existing \"a/d/c\" children merge_children + overriding/merge_attribute \"a/b/c\" \"a/d/c\" If path not present: Behaves like merge_childrenIf path present: Behaves like overriding/merge_attribute merge_leaves \"a/b/c\" \"a/d/c\" If path not present: Shift/copy leaves of node <code>c</code> to be children of node <code>d</code>If path present: Shift/copy leaves of node <code>c</code> to be merged with existing \"a/d/c\" children merge_leaves + overriding/merge_attribute \"a/b/c\" \"a/d/c\" If path not present: Behaves like merge_leavesIf path present: Behaves like overriding/merge_attribute, but original node <code>c</code> remains delete_children \"a/b\" \"a/d/b\" Shift/copy node <code>b</code> only without any node <code>b</code> children"},{"location":"bigtree/tree/modify/#guideline","title":"Guideline","text":"<p>If you're still feeling lost over the parameters, here are some guiding questions to ask yourself.</p> <ul> <li>Do I want to retain the original node where they are?<ul> <li>Yes: Set <code>copy=True</code></li> <li>Default performs a shift instead of copy</li> </ul> </li> <li>Am I unsure of what nodes I am going to copy/shift, they may or may not exist and this is perfectly fine?<ul> <li>Yes: Set <code>skippable=True</code></li> <li>Default throws error if origin node is not found</li> </ul> </li> <li>The origin node (and its descendants) may clash with the destination node(s), how do I want to handle it?<ul> <li>Set <code>overriding=True</code> to overwrite origin node</li> <li>Set <code>merge_attribute=True</code> to combine both nodes' attributes</li> <li>Default throws error about the clash in node name</li> </ul> </li> <li>I want to copy/shift everything under the node, but not the node itself<ul> <li>Set <code>merge_children=True</code> or <code>merge_leaves=True</code> to shift the children and leaf nodes respectively</li> <li>Default shifts the node itself, and everything under it</li> </ul> </li> <li>I want to copy/shift the node and only the node, and not everything under it<ul> <li>Yes: Set <code>delete_children=True</code></li> <li>Default shifts the node itself, and everything under it</li> </ul> </li> <li>I want to copy/shift things from one tree to another tree<ul> <li>Specify <code>to_tree</code></li> <li>Default shifts nodes within the same tree</li> </ul> </li> </ul> <p>What about the permutations between the parameters?</p> <ul> <li>These parameters are standalone and do not produce any interaction effect<ul> <li><code>copy</code>, <code>skippable</code>, <code>delete_children</code></li> </ul> </li> <li>These parameters have some interaction:<ul> <li><code>overriding</code> and <code>merge_attribute</code> with <code>merge_children</code> and <code>merge_leaves</code></li> <li><code>overriding</code> + <code>merge_children</code>: Behaves like <code>merge_children</code> when there is no clash in node name, otherwise behaves like <code>overriding</code> Note that clashes will preserve origin node parent and destination nodes' children</li> <li><code>overriding</code> + <code>merge_leaves</code>: Behaves like <code>merge_leaves</code> when there is no clash in node name, otherwise behaves like <code>overriding</code> Note that clashes will preserve origin node parent and destination nodes' leaves</li> <li><code>merge_attribute</code> + <code>merge_children</code>: Behaves like <code>merge_children</code> when there is no clash in node name, otherwise behaves like <code>merge_attribute</code> Note that attributes will be merged for node and all descendants, and will preserve origin and destination nodes' children</li> <li><code>merge_attribute</code> + <code>merge_leaves</code>: Behaves like <code>merge_leaves</code> when there is no clash in node name, otherwise behaves like <code>merge_attribute</code> Note that attributes will be merged for node and all descendants, and will preserve origin nodes' children and destination nodes' leaves</li> </ul> </li> </ul>"},{"location":"bigtree/tree/modify/#bigtree.tree.modify","title":"bigtree.tree.modify","text":""},{"location":"bigtree/tree/modify/#bigtree.tree.modify.shift_nodes","title":"shift_nodes","text":"<pre><code>shift_nodes(\n    tree,\n    from_paths,\n    to_paths,\n    sep=\"/\",\n    skippable=False,\n    overriding=False,\n    merge_attribute=False,\n    merge_children=False,\n    merge_leaves=False,\n    delete_children=False,\n    with_full_path=False,\n)\n</code></pre> <p>Shift nodes from <code>from_paths</code> to <code>to_paths</code> in-place.</p> <ul> <li>Creates intermediate nodes if to-path is not present</li> <li>Able to skip nodes if from-path is not found, defaults to False (from-nodes must be found; not skippable)</li> <li>Able to override existing node if it exists, defaults to False (to-nodes must not exist; not overridden)</li> <li>Able to merge attributes of node if it exists, defaults to False (to-nodes must not exist; no attributes to merge)</li> <li>Able to merge children and remove intermediate parent node, defaults to False (nodes are shifted; not merged)</li> <li>Able to merge leaf nodes and remove all intermediate nodes, defaults to False (nodes are shifted; not merged)</li> <li>Able to shift node only and delete children, defaults to False (nodes are shifted together with children)</li> </ul> <p>For paths in <code>from_paths</code> and <code>to_paths</code>,</p> <ul> <li>Path name can be with or without leading tree path separator symbol</li> </ul> <p>For paths in <code>from_paths</code>,</p> <ul> <li>Path name can be partial path (trailing part of path) or node name</li> <li>If <code>with_full_path=True</code>, path name must be full path</li> <li>Path name must be unique to one node</li> </ul> <p>For paths in <code>to_paths</code>,</p> <ul> <li>Path name must be full path</li> <li>Can set to empty string or None to delete the path in <code>from_paths</code>, note that <code>copy</code> must be set to False</li> </ul> <p>If <code>merge_children=True</code>,</p> <ul> <li>If <code>to_path</code> is not present, it shifts children of <code>from_path</code></li> <li>If <code>to_path</code> is present, and <code>overriding=False</code>, original and new children are merged</li> <li>If <code>to_path</code> is present and <code>overriding=True</code>, it behaves like overriding and only new children are retained</li> </ul> <p>If <code>merge_leaves=True</code>,</p> <ul> <li>If <code>to_path</code> is not present, it shifts leaves of <code>from_path</code></li> <li>If <code>to_path</code> is present, and <code>overriding=False</code>, original children and leaves are merged</li> <li>If <code>to_path</code> is present and <code>overriding=True</code>, it behaves like overriding and only new leaves are retained,     original child nodes in <code>from_path</code> are retained</li> </ul> <p>Note:</p> <ul> <li><code>merge_children</code> and <code>merge_leaves</code> cannot be both True at the same time</li> <li><code>overriding</code> and <code>merge_attribute</code> cannot be both True at the same time</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import list_to_tree, str_to_tree, shift_nodes\n&gt;&gt;&gt; root = list_to_tree([\"Downloads/photo1.jpg\", \"Downloads/file1.doc\"])\n&gt;&gt;&gt; root.show()\nDownloads\n\u251c\u2500\u2500 photo1.jpg\n\u2514\u2500\u2500 file1.doc\n</code></pre> <pre><code>&gt;&gt;&gt; shift_nodes(\n...     tree=root,\n...     from_paths=[\"Downloads/photo1.jpg\", \"Downloads/file1.doc\"],\n...     to_paths=[\"Downloads/Pictures/photo1.jpg\", \"Downloads/Files/file1.doc\"],\n... )\n&gt;&gt;&gt; root.show()\nDownloads\n\u251c\u2500\u2500 Pictures\n\u2502   \u2514\u2500\u2500 photo1.jpg\n\u2514\u2500\u2500 Files\n    \u2514\u2500\u2500 file1.doc\n</code></pre> <p>To delete node,</p> <pre><code>&gt;&gt;&gt; root = list_to_tree([\"Downloads/photo1.jpg\", \"Downloads/file1.doc\"])\n&gt;&gt;&gt; root.show()\nDownloads\n\u251c\u2500\u2500 photo1.jpg\n\u2514\u2500\u2500 file1.doc\n</code></pre> <pre><code>&gt;&gt;&gt; shift_nodes(root, [\"Downloads/photo1.jpg\"], [None])\n&gt;&gt;&gt; root.show()\nDownloads\n\u2514\u2500\u2500 file1.doc\n</code></pre> <p>In overriding case,</p> <pre><code>&gt;&gt;&gt; root = str_to_tree(\n... \"Downloads\\n\"\n... \"\u251c\u2500\u2500 Misc\\n\"\n... \"\u2502   \u2514\u2500\u2500 Pictures\\n\"\n... \"\u2502       \u2514\u2500\u2500 photo1.jpg\\n\"\n... \"\u2514\u2500\u2500 Pictures\\n\"\n... \"    \u2514\u2500\u2500 photo2.jpg\"\n... )\n&gt;&gt;&gt; root.show()\nDownloads\n\u251c\u2500\u2500 Misc\n\u2502   \u2514\u2500\u2500 Pictures\n\u2502       \u2514\u2500\u2500 photo1.jpg\n\u2514\u2500\u2500 Pictures\n    \u2514\u2500\u2500 photo2.jpg\n</code></pre> <pre><code>&gt;&gt;&gt; shift_nodes(root, [\"Downloads/Misc/Pictures\"], [\"Downloads/Pictures\"], overriding=True)\n&gt;&gt;&gt; root.show()\nDownloads\n\u251c\u2500\u2500 Misc\n\u2514\u2500\u2500 Pictures\n    \u2514\u2500\u2500 photo1.jpg\n</code></pre> <p>In <code>merge_children=True</code> case, child nodes are shifted instead of the parent node.</p> <ul> <li>If the path already exists, child nodes are merged with existing children</li> <li>Otherwise, the child nodes of the node are merged with the node's parent</li> </ul> <pre><code>&gt;&gt;&gt; root = str_to_tree(\n... \"Downloads\\n\"\n... \"\u251c\u2500\u2500 Misc\\n\"\n... \"\u2502   \u251c\u2500\u2500 Pictures\\n\"\n... \"\u2502   \u2502   \u2514\u2500\u2500 photo2.jpg\\n\"\n... \"\u2502   \u2514\u2500\u2500 Applications\\n\"\n... \"\u2502       \u2514\u2500\u2500 Chrome.exe\\n\"\n... \"\u251c\u2500\u2500 Pictures\\n\"\n... \"\u2502   \u2514\u2500\u2500 photo1.jpg\\n\"\n... \"\u2514\u2500\u2500 dummy\\n\"\n... \"    \u2514\u2500\u2500 Files\\n\"\n... \"        \u2514\u2500\u2500 file1.doc\"\n... )\n&gt;&gt;&gt; root.show()\nDownloads\n\u251c\u2500\u2500 Misc\n\u2502   \u251c\u2500\u2500 Pictures\n\u2502   \u2502   \u2514\u2500\u2500 photo2.jpg\n\u2502   \u2514\u2500\u2500 Applications\n\u2502       \u2514\u2500\u2500 Chrome.exe\n\u251c\u2500\u2500 Pictures\n\u2502   \u2514\u2500\u2500 photo1.jpg\n\u2514\u2500\u2500 dummy\n    \u2514\u2500\u2500 Files\n        \u2514\u2500\u2500 file1.doc\n</code></pre> <pre><code>&gt;&gt;&gt; shift_nodes(\n...     root,\n...     [\"Downloads/Misc/Pictures\", \"Applications\", \"Downloads/dummy\"],\n...     [\"Downloads/Pictures\", \"Downloads/Applications\", \"Downloads/dummy\"],\n...     merge_children=True,\n... )\n&gt;&gt;&gt; root.show()\nDownloads\n\u251c\u2500\u2500 Misc\n\u251c\u2500\u2500 Pictures\n\u2502   \u251c\u2500\u2500 photo1.jpg\n\u2502   \u2514\u2500\u2500 photo2.jpg\n\u251c\u2500\u2500 Chrome.exe\n\u2514\u2500\u2500 Files\n    \u2514\u2500\u2500 file1.doc\n</code></pre> <p>In <code>merge_leaves=True</code> case, leaf nodes are shifted instead of the parent node.</p> <ul> <li>If the path already exists, leaf nodes are merged with existing children</li> <li>Otherwise, the leaf nodes of the node are merged with the node's parent</li> </ul> <pre><code>&gt;&gt;&gt; root = str_to_tree(\n... \"Downloads\\n\"\n... \"\u251c\u2500\u2500 Misc\\n\"\n... \"\u2502   \u251c\u2500\u2500 Pictures\\n\"\n... \"\u2502   \u2502   \u2514\u2500\u2500 photo2.jpg\\n\"\n... \"\u2502   \u2514\u2500\u2500 Applications\\n\"\n... \"\u2502       \u2514\u2500\u2500 Chrome.exe\\n\"\n... \"\u251c\u2500\u2500 Pictures\\n\"\n... \"\u2502   \u2514\u2500\u2500 photo1.jpg\\n\"\n... \"\u2514\u2500\u2500 dummy\\n\"\n... \"    \u2514\u2500\u2500 Files\\n\"\n... \"        \u2514\u2500\u2500 file1.doc\"\n... )\n&gt;&gt;&gt; root.show()\nDownloads\n\u251c\u2500\u2500 Misc\n\u2502   \u251c\u2500\u2500 Pictures\n\u2502   \u2502   \u2514\u2500\u2500 photo2.jpg\n\u2502   \u2514\u2500\u2500 Applications\n\u2502       \u2514\u2500\u2500 Chrome.exe\n\u251c\u2500\u2500 Pictures\n\u2502   \u2514\u2500\u2500 photo1.jpg\n\u2514\u2500\u2500 dummy\n    \u2514\u2500\u2500 Files\n        \u2514\u2500\u2500 file1.doc\n</code></pre> <pre><code>&gt;&gt;&gt; shift_nodes(\n...     root,\n...     [\"Downloads/Misc/Pictures\", \"Applications\", \"Downloads/dummy\"],\n...     [\"Downloads/Pictures\", \"Downloads/Applications\", \"Downloads/dummy\"],\n...     merge_leaves=True,\n... )\n&gt;&gt;&gt; root.show()\nDownloads\n\u251c\u2500\u2500 Misc\n\u2502   \u251c\u2500\u2500 Pictures\n\u2502   \u2514\u2500\u2500 Applications\n\u251c\u2500\u2500 Pictures\n\u2502   \u251c\u2500\u2500 photo1.jpg\n\u2502   \u2514\u2500\u2500 photo2.jpg\n\u251c\u2500\u2500 dummy\n\u2502   \u2514\u2500\u2500 Files\n\u251c\u2500\u2500 Chrome.exe\n\u2514\u2500\u2500 file1.doc\n</code></pre> <p>In <code>delete_children=True</code> case, only the node is shifted without its accompanying children/descendants.</p> <pre><code>&gt;&gt;&gt; root = str_to_tree(\n... \"Downloads\\n\"\n... \"\u251c\u2500\u2500 Misc\\n\"\n... \"\u2502   \u2514\u2500\u2500 Applications\\n\"\n... \"\u2502       \u2514\u2500\u2500 Chrome.exe\\n\"\n... \"\u2514\u2500\u2500 Pictures\\n\"\n... \"    \u2514\u2500\u2500 photo1.jpg\"\n... )\n&gt;&gt;&gt; root.show()\nDownloads\n\u251c\u2500\u2500 Misc\n\u2502   \u2514\u2500\u2500 Applications\n\u2502       \u2514\u2500\u2500 Chrome.exe\n\u2514\u2500\u2500 Pictures\n    \u2514\u2500\u2500 photo1.jpg\n</code></pre> <pre><code>&gt;&gt;&gt; shift_nodes(root, [\"Applications\"], [\"Downloads/Applications\"], delete_children=True)\n&gt;&gt;&gt; root.show()\nDownloads\n\u251c\u2500\u2500 Misc\n\u251c\u2500\u2500 Pictures\n\u2502   \u2514\u2500\u2500 photo1.jpg\n\u2514\u2500\u2500 Applications\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>T</code> <p>tree to modify</p> required <code>from_paths</code> <code>List[str]</code> <p>original paths to shift nodes from</p> required <code>to_paths</code> <code>List[Optional[str]]</code> <p>new paths to shift nodes to</p> required <code>sep</code> <code>str</code> <p>path separator for input paths, applies to <code>from_path</code> and <code>to_path</code></p> <code>'/'</code> <code>skippable</code> <code>bool</code> <p>indicator to skip if from-path is not found</p> <code>False</code> <code>overriding</code> <code>bool</code> <p>indicator to override existing to-path if there are clashes</p> <code>False</code> <code>merge_attribute</code> <code>bool</code> <p>indicator to merge attributes of from-path and to-path if there are clashes</p> <code>False</code> <code>merge_children</code> <code>bool</code> <p>indicator to merge from-path's children and remove intermediate parent node</p> <code>False</code> <code>merge_leaves</code> <code>bool</code> <p>indicator to merge from-path's leaf nodes and remove intermediate parent node(s)</p> <code>False</code> <code>delete_children</code> <code>bool</code> <p>indicator to shift node only without children</p> <code>False</code> <code>with_full_path</code> <code>bool</code> <p>indicator to shift node with full path in <code>from_paths</code>, results in faster search</p> <code>False</code>"},{"location":"bigtree/tree/modify/#bigtree.tree.modify.copy_nodes","title":"copy_nodes","text":"<pre><code>copy_nodes(\n    tree,\n    from_paths,\n    to_paths,\n    sep=\"/\",\n    skippable=False,\n    overriding=False,\n    merge_attribute=False,\n    merge_children=False,\n    merge_leaves=False,\n    delete_children=False,\n    with_full_path=False,\n)\n</code></pre> <p>Copy nodes from <code>from_paths</code> to <code>to_paths</code> in-place.</p> <ul> <li>Creates intermediate nodes if to-path is not present</li> <li>Able to skip nodes if from-path is not found, defaults to False (from-nodes must be found; not skippable)</li> <li>Able to override existing node if it exists, defaults to False (to-nodes must not exist; not overridden)</li> <li>Able to merge attributes of node if it exists, defaults to False (to-nodes must not exist; no attributes to merge)</li> <li>Able to merge children and remove intermediate parent node, defaults to False (nodes are copied; not merged)</li> <li>Able to merge only leaf nodes and remove all intermediate nodes, defaults to False (nodes are copied; not merged)</li> <li>Able to copy node only and delete children, defaults to False (nodes are copied together with children)</li> </ul> <p>For paths in <code>from_paths</code> and <code>to_paths</code>,</p> <ul> <li>Path name can be with or without leading tree path separator symbol</li> </ul> <p>For paths in <code>from_paths</code>,</p> <ul> <li>Path name can be partial path (trailing part of path) or node name</li> <li>If <code>with_full_path=True</code>, path name must be full path</li> <li>Path name must be unique to one node</li> </ul> <p>For paths in <code>to_paths</code>,</p> <ul> <li>Path name must be full path</li> </ul> <p>If <code>merge_children=True</code>,</p> <ul> <li>If <code>to_path</code> is not present, it copies children of <code>from_path</code></li> <li>If <code>to_path</code> is present, and <code>overriding=False</code>, original and new children are merged</li> <li>If <code>to_path</code> is present and <code>overriding=True</code>, it behaves like overriding and only new children are retained</li> </ul> <p>If <code>merge_leaves=True</code>,</p> <ul> <li>If <code>to_path</code> is not present, it copies leaves of <code>from_path</code></li> <li>If <code>to_path</code> is present, and <code>overriding=False</code>, original children and leaves are merged</li> <li>If <code>to_path</code> is present and <code>overriding=True</code>, it behaves like overriding and only new leaves are retained,     original child nodes in <code>from_path</code> are retained</li> </ul> <p>Note:</p> <ul> <li><code>merge_children</code> and <code>merge_leaves</code> cannot be both True at the same time</li> <li><code>overriding</code> and <code>merge_attribute</code> cannot be both True at the same time</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import list_to_tree, str_to_tree, copy_nodes\n&gt;&gt;&gt; root = list_to_tree([\"Downloads/Pictures\", \"Downloads/photo1.jpg\", \"Downloads/file1.doc\"])\n&gt;&gt;&gt; root.show()\nDownloads\n\u251c\u2500\u2500 Pictures\n\u251c\u2500\u2500 photo1.jpg\n\u2514\u2500\u2500 file1.doc\n</code></pre> <pre><code>&gt;&gt;&gt; copy_nodes(\n...     tree=root,\n...     from_paths=[\"Downloads/photo1.jpg\", \"Downloads/file1.doc\"],\n...     to_paths=[\"Downloads/Pictures/photo1.jpg\", \"Downloads/Files/file1.doc\"],\n... )\n&gt;&gt;&gt; root.show()\nDownloads\n\u251c\u2500\u2500 Pictures\n\u2502   \u2514\u2500\u2500 photo1.jpg\n\u251c\u2500\u2500 photo1.jpg\n\u251c\u2500\u2500 file1.doc\n\u2514\u2500\u2500 Files\n    \u2514\u2500\u2500 file1.doc\n</code></pre> <p>In overriding case,</p> <pre><code>&gt;&gt;&gt; root = str_to_tree(\n... \"Downloads\\n\"\n... \"\u251c\u2500\u2500 Misc\\n\"\n... \"\u2502   \u2514\u2500\u2500 Pictures\\n\"\n... \"\u2502       \u2514\u2500\u2500 photo1.jpg\\n\"\n... \"\u2514\u2500\u2500 Pictures\\n\"\n... \"    \u2514\u2500\u2500 photo2.jpg\"\n... )\n&gt;&gt;&gt; root.show()\nDownloads\n\u251c\u2500\u2500 Misc\n\u2502   \u2514\u2500\u2500 Pictures\n\u2502       \u2514\u2500\u2500 photo1.jpg\n\u2514\u2500\u2500 Pictures\n    \u2514\u2500\u2500 photo2.jpg\n</code></pre> <pre><code>&gt;&gt;&gt; copy_nodes(root, [\"Downloads/Misc/Pictures\"], [\"Downloads/Pictures\"], overriding=True)\n&gt;&gt;&gt; root.show()\nDownloads\n\u251c\u2500\u2500 Misc\n\u2502   \u2514\u2500\u2500 Pictures\n\u2502       \u2514\u2500\u2500 photo1.jpg\n\u2514\u2500\u2500 Pictures\n    \u2514\u2500\u2500 photo1.jpg\n</code></pre> <p>In <code>merge_children=True</code> case, child nodes are copied instead of the parent node.</p> <ul> <li>If the path already exists, child nodes are merged with existing children</li> <li>Otherwise, the child nodes of the node are merged with the node's parent</li> </ul> <pre><code>&gt;&gt;&gt; root = str_to_tree(\n... \"Downloads\\n\"\n... \"\u251c\u2500\u2500 Misc\\n\"\n... \"\u2502   \u251c\u2500\u2500 Pictures\\n\"\n... \"\u2502   \u2502   \u2514\u2500\u2500 photo2.jpg\\n\"\n... \"\u2502   \u2514\u2500\u2500 Applications\\n\"\n... \"\u2502       \u2514\u2500\u2500 Chrome.exe\\n\"\n... \"\u251c\u2500\u2500 Pictures\\n\"\n... \"\u2502   \u2514\u2500\u2500 photo1.jpg\\n\"\n... \"\u2514\u2500\u2500 dummy\\n\"\n... \"    \u2514\u2500\u2500 Files\\n\"\n... \"        \u2514\u2500\u2500 file1.doc\"\n... )\n&gt;&gt;&gt; root.show()\nDownloads\n\u251c\u2500\u2500 Misc\n\u2502   \u251c\u2500\u2500 Pictures\n\u2502   \u2502   \u2514\u2500\u2500 photo2.jpg\n\u2502   \u2514\u2500\u2500 Applications\n\u2502       \u2514\u2500\u2500 Chrome.exe\n\u251c\u2500\u2500 Pictures\n\u2502   \u2514\u2500\u2500 photo1.jpg\n\u2514\u2500\u2500 dummy\n    \u2514\u2500\u2500 Files\n        \u2514\u2500\u2500 file1.doc\n</code></pre> <pre><code>&gt;&gt;&gt; copy_nodes(\n...     root,\n...     [\"Downloads/Misc/Pictures\", \"Applications\", \"Downloads/dummy\"],\n...     [\"Downloads/Pictures\", \"Downloads/Applications\", \"Downloads/dummy\"],\n...     merge_children=True,\n... )\n&gt;&gt;&gt; root.show()\nDownloads\n\u251c\u2500\u2500 Misc\n\u2502   \u251c\u2500\u2500 Pictures\n\u2502   \u2502   \u2514\u2500\u2500 photo2.jpg\n\u2502   \u2514\u2500\u2500 Applications\n\u2502       \u2514\u2500\u2500 Chrome.exe\n\u251c\u2500\u2500 Pictures\n\u2502   \u251c\u2500\u2500 photo1.jpg\n\u2502   \u2514\u2500\u2500 photo2.jpg\n\u251c\u2500\u2500 Chrome.exe\n\u2514\u2500\u2500 Files\n    \u2514\u2500\u2500 file1.doc\n</code></pre> <p>In <code>merge_leaves=True</code> case, leaf nodes are copied instead of the parent node.</p> <ul> <li>If the path already exists, leaf nodes are merged with existing children</li> <li>Otherwise, the leaf nodes of the node are merged with the node's parent</li> </ul> <pre><code>&gt;&gt;&gt; root = str_to_tree(\n... \"Downloads\\n\"\n... \"\u251c\u2500\u2500 Misc\\n\"\n... \"\u2502   \u251c\u2500\u2500 Pictures\\n\"\n... \"\u2502   \u2502   \u2514\u2500\u2500 photo2.jpg\\n\"\n... \"\u2502   \u2514\u2500\u2500 Applications\\n\"\n... \"\u2502       \u2514\u2500\u2500 Chrome.exe\\n\"\n... \"\u251c\u2500\u2500 Pictures\\n\"\n... \"\u2502   \u2514\u2500\u2500 photo1.jpg\\n\"\n... \"\u2514\u2500\u2500 dummy\\n\"\n... \"    \u2514\u2500\u2500 Files\\n\"\n... \"        \u2514\u2500\u2500 file1.doc\"\n... )\n&gt;&gt;&gt; root.show()\nDownloads\n\u251c\u2500\u2500 Misc\n\u2502   \u251c\u2500\u2500 Pictures\n\u2502   \u2502   \u2514\u2500\u2500 photo2.jpg\n\u2502   \u2514\u2500\u2500 Applications\n\u2502       \u2514\u2500\u2500 Chrome.exe\n\u251c\u2500\u2500 Pictures\n\u2502   \u2514\u2500\u2500 photo1.jpg\n\u2514\u2500\u2500 dummy\n    \u2514\u2500\u2500 Files\n        \u2514\u2500\u2500 file1.doc\n</code></pre> <pre><code>&gt;&gt;&gt; copy_nodes(\n...     root,\n...     [\"Downloads/Misc/Pictures\", \"Applications\", \"Downloads/dummy\"],\n...     [\"Downloads/Pictures\", \"Downloads/Applications\", \"Downloads/dummy\"],\n...     merge_leaves=True,\n... )\n&gt;&gt;&gt; root.show()\nDownloads\n\u251c\u2500\u2500 Misc\n\u2502   \u251c\u2500\u2500 Pictures\n\u2502   \u2502   \u2514\u2500\u2500 photo2.jpg\n\u2502   \u2514\u2500\u2500 Applications\n\u2502       \u2514\u2500\u2500 Chrome.exe\n\u251c\u2500\u2500 Pictures\n\u2502   \u251c\u2500\u2500 photo1.jpg\n\u2502   \u2514\u2500\u2500 photo2.jpg\n\u251c\u2500\u2500 dummy\n\u2502   \u2514\u2500\u2500 Files\n\u2502       \u2514\u2500\u2500 file1.doc\n\u251c\u2500\u2500 Chrome.exe\n\u2514\u2500\u2500 file1.doc\n</code></pre> <p>In <code>delete_children=True</code> case, only the node is copied without its accompanying children/descendants.</p> <pre><code>&gt;&gt;&gt; root = str_to_tree(\n... \"Downloads\\n\"\n... \"\u251c\u2500\u2500 Misc\\n\"\n... \"\u2502   \u2514\u2500\u2500 Applications\\n\"\n... \"\u2502       \u2514\u2500\u2500 Chrome.exe\\n\"\n... \"\u2514\u2500\u2500 Pictures\\n\"\n... \"    \u2514\u2500\u2500 photo1.jpg\"\n... )\n&gt;&gt;&gt; root.show()\nDownloads\n\u251c\u2500\u2500 Misc\n\u2502   \u2514\u2500\u2500 Applications\n\u2502       \u2514\u2500\u2500 Chrome.exe\n\u2514\u2500\u2500 Pictures\n    \u2514\u2500\u2500 photo1.jpg\n</code></pre> <pre><code>&gt;&gt;&gt; copy_nodes(root, [\"Applications\"], [\"Downloads/Applications\"], delete_children=True)\n&gt;&gt;&gt; root.show()\nDownloads\n\u251c\u2500\u2500 Misc\n\u2502   \u2514\u2500\u2500 Applications\n\u2502       \u2514\u2500\u2500 Chrome.exe\n\u251c\u2500\u2500 Pictures\n\u2502   \u2514\u2500\u2500 photo1.jpg\n\u2514\u2500\u2500 Applications\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>T</code> <p>tree to modify</p> required <code>from_paths</code> <code>List[str]</code> <p>original paths to copy nodes from</p> required <code>to_paths</code> <code>List[Optional[str]]</code> <p>new paths to copy nodes to</p> required <code>sep</code> <code>str</code> <p>path separator for input paths, applies to <code>from_path</code> and <code>to_path</code></p> <code>'/'</code> <code>skippable</code> <code>bool</code> <p>indicator to skip if from-path is not found</p> <code>False</code> <code>overriding</code> <code>bool</code> <p>indicator to override existing to-path if there are clashes</p> <code>False</code> <code>merge_attribute</code> <code>bool</code> <p>indicator to merge attributes of from-path and to-path if there are clashes</p> <code>False</code> <code>merge_children</code> <code>bool</code> <p>indicator to merge from-path's children and remove intermediate parent node</p> <code>False</code> <code>merge_leaves</code> <code>bool</code> <p>indicator to merge from-path's leaf nodes and remove intermediate parent node(s)</p> <code>False</code> <code>delete_children</code> <code>bool</code> <p>indicator to copy node only without children</p> <code>False</code> <code>with_full_path</code> <code>bool</code> <p>indicator to copy node with full path in <code>from_paths</code>, results in faster search</p> <code>False</code>"},{"location":"bigtree/tree/modify/#bigtree.tree.modify.shift_and_replace_nodes","title":"shift_and_replace_nodes","text":"<pre><code>shift_and_replace_nodes(\n    tree,\n    from_paths,\n    to_paths,\n    sep=\"/\",\n    skippable=False,\n    delete_children=False,\n    with_full_path=False,\n)\n</code></pre> <p>Shift nodes from <code>from_paths</code> to replace <code>to_paths</code> in-place.</p> <ul> <li>Creates intermediate nodes if to-path is not present</li> <li>Able to skip nodes if from-path is not found, defaults to False (from-nodes must be found; not skippable)</li> <li>Able to shift node only and delete children, defaults to False (nodes are shifted together with children)</li> </ul> <p>For paths in <code>from_paths</code> and <code>to_paths</code>,</p> <ul> <li>Path name can be with or without leading tree path separator symbol</li> </ul> <p>For paths in <code>from_paths</code>,</p> <ul> <li>Path name can be partial path (trailing part of path) or node name</li> <li>If <code>with_full_path=True</code>, path name must be full path</li> <li>Path name must be unique to one node</li> </ul> <p>For paths in <code>to_paths</code>,</p> <ul> <li>Path name must be full path</li> <li>Path must exist, node-to-be-replaced must be present</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import str_to_tree, shift_and_replace_nodes\n&gt;&gt;&gt; root = str_to_tree(\n... \"Downloads\\n\"\n... \"\u251c\u2500\u2500 Pictures\\n\"\n... \"\u2502   \u2514\u2500\u2500 photo1.jpg\\n\"\n... \"\u2514\u2500\u2500 Misc\\n\"\n... \"    \u2514\u2500\u2500 dummy\"\n... )\n&gt;&gt;&gt; root.show()\nDownloads\n\u251c\u2500\u2500 Pictures\n\u2502   \u2514\u2500\u2500 photo1.jpg\n\u2514\u2500\u2500 Misc\n    \u2514\u2500\u2500 dummy\n</code></pre> <pre><code>&gt;&gt;&gt; shift_and_replace_nodes(root, [\"Downloads/Pictures\"], [\"Downloads/Misc/dummy\"])\n&gt;&gt;&gt; root.show()\nDownloads\n\u2514\u2500\u2500 Misc\n    \u2514\u2500\u2500 Pictures\n        \u2514\u2500\u2500 photo1.jpg\n</code></pre> <p>In <code>delete_children=True</code> case, only the node is shifted without its accompanying children/descendants.</p> <pre><code>&gt;&gt;&gt; root = str_to_tree(\n... \"Downloads\\n\"\n... \"\u251c\u2500\u2500 Pictures\\n\"\n... \"\u2502   \u2514\u2500\u2500 photo1.jpg\\n\"\n... \"\u2514\u2500\u2500 Misc\\n\"\n... \"    \u2514\u2500\u2500 dummy\"\n... )\n&gt;&gt;&gt; root.show()\nDownloads\n\u251c\u2500\u2500 Pictures\n\u2502   \u2514\u2500\u2500 photo1.jpg\n\u2514\u2500\u2500 Misc\n    \u2514\u2500\u2500 dummy\n</code></pre> <pre><code>&gt;&gt;&gt; shift_and_replace_nodes(root, [\"Downloads/Pictures\"], [\"Downloads/Misc/dummy\"], delete_children=True)\n&gt;&gt;&gt; root.show()\nDownloads\n\u2514\u2500\u2500 Misc\n    \u2514\u2500\u2500 Pictures\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>T</code> <p>tree to modify</p> required <code>from_paths</code> <code>List[str]</code> <p>original paths to shift nodes from</p> required <code>to_paths</code> <code>List[str]</code> <p>new paths to shift nodes to</p> required <code>sep</code> <code>str</code> <p>path separator for input paths, applies to <code>from_path</code> and <code>to_path</code></p> <code>'/'</code> <code>skippable</code> <code>bool</code> <p>indicator to skip if from-path is not found</p> <code>False</code> <code>delete_children</code> <code>bool</code> <p>indicator to shift node only without children</p> <code>False</code> <code>with_full_path</code> <code>bool</code> <p>indicator to shift node with full path in <code>from_paths</code>, results in faster search</p> <code>False</code>"},{"location":"bigtree/tree/modify/#bigtree.tree.modify.copy_nodes_from_tree_to_tree","title":"copy_nodes_from_tree_to_tree","text":"<pre><code>copy_nodes_from_tree_to_tree(\n    from_tree,\n    to_tree,\n    from_paths,\n    to_paths,\n    sep=\"/\",\n    skippable=False,\n    overriding=False,\n    merge_attribute=False,\n    merge_children=False,\n    merge_leaves=False,\n    delete_children=False,\n    with_full_path=False,\n)\n</code></pre> <p>Copy nodes from <code>from_paths</code> to <code>to_paths</code> in-place.</p> <ul> <li>Creates intermediate nodes if to-path is not present</li> <li>Able to skip nodes if from-path is not found, defaults to False (from-nodes must be found; not skippable)</li> <li>Able to override existing node if it exists, defaults to False (to-nodes must not exist; not overridden)</li> <li>Able to merge attributes of node if it exists, defaults to False (to-nodes must not exist; no attributes to merge)</li> <li>Able to merge children and remove intermediate parent node, defaults to False (nodes are shifted; not merged)</li> <li>Able to merge leaf nodes and remove all intermediate nodes, defaults to False (nodes are shifted; not merged)</li> <li>Able to copy node only and delete children, defaults to False (nodes are copied together with children)</li> </ul> <p>For paths in <code>from_paths</code> and <code>to_paths</code>,</p> <ul> <li>Path name can be with or without leading tree path separator symbol</li> </ul> <p>For paths in <code>from_paths</code>,</p> <ul> <li>Path name can be partial path (trailing part of path) or node name</li> <li>If <code>with_full_path=True</code>, path name must be full path</li> <li>Path name must be unique to one node</li> </ul> <p>For paths in <code>to_paths</code>,</p> <ul> <li>Path name must be full path</li> </ul> <p>If <code>merge_children=True</code>,</p> <ul> <li>If <code>to_path</code> is not present, it copies children of <code>from_path</code></li> <li>If <code>to_path</code> is present, and <code>overriding=False</code>, original and new children are merged</li> <li>If <code>to_path</code> is present and <code>overriding=True</code>, it behaves like overriding and only new children are retained</li> </ul> <p>If <code>merge_leaves=True</code>,</p> <ul> <li>If <code>to_path</code> is not present, it copies leaves of <code>from_path</code></li> <li>If <code>to_path</code> is present, and <code>overriding=False</code>, original children and leaves are merged</li> <li>If <code>to_path</code> is present and <code>overriding=True</code>, it behaves like overriding and only new leaves are retained,     original child nodes in <code>from_path</code> are retained</li> </ul> <p>Note:</p> <ul> <li><code>merge_children</code> and <code>merge_leaves</code> cannot be both True at the same time</li> <li><code>overriding</code> and <code>merge_attribute</code> cannot be both True at the same time</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, str_to_tree, copy_nodes_from_tree_to_tree\n&gt;&gt;&gt; root = str_to_tree(\n... \"Downloads\\n\"\n... \"\u251c\u2500\u2500 file1.doc\\n\"\n... \"\u251c\u2500\u2500 Pictures\\n\"\n... \"\u2502   \u2514\u2500\u2500 photo1.jpg\\n\"\n... \"\u2514\u2500\u2500 Misc\\n\"\n... \"    \u2514\u2500\u2500 dummy\\n\"\n... \"        \u2514\u2500\u2500 photo2.jpg\"\n... )\n&gt;&gt;&gt; root.show()\nDownloads\n\u251c\u2500\u2500 file1.doc\n\u251c\u2500\u2500 Pictures\n\u2502   \u2514\u2500\u2500 photo1.jpg\n\u2514\u2500\u2500 Misc\n    \u2514\u2500\u2500 dummy\n        \u2514\u2500\u2500 photo2.jpg\n</code></pre> <pre><code>&gt;&gt;&gt; root_other = Node(\"Documents\")\n&gt;&gt;&gt; copy_nodes_from_tree_to_tree(\n...     from_tree=root,\n...     to_tree=root_other,\n...     from_paths=[\"Downloads/Pictures\", \"Downloads/Misc\"],\n...     to_paths=[\"Documents/Pictures\", \"Documents/New Misc/Misc\"],\n... )\n&gt;&gt;&gt; root_other.show()\nDocuments\n\u251c\u2500\u2500 Pictures\n\u2502   \u2514\u2500\u2500 photo1.jpg\n\u2514\u2500\u2500 New Misc\n    \u2514\u2500\u2500 Misc\n        \u2514\u2500\u2500 dummy\n            \u2514\u2500\u2500 photo2.jpg\n</code></pre> <p>In overriding case,</p> <pre><code>&gt;&gt;&gt; root_other = str_to_tree(\n... \"Documents\\n\"\n... \"\u2514\u2500\u2500 Pictures\\n\"\n... \"    \u2514\u2500\u2500 photo3.jpg\"\n... )\n&gt;&gt;&gt; root_other.show()\nDocuments\n\u2514\u2500\u2500 Pictures\n    \u2514\u2500\u2500 photo3.jpg\n</code></pre> <pre><code>&gt;&gt;&gt; copy_nodes_from_tree_to_tree(\n...     root,\n...     root_other,\n...     [\"Downloads/Pictures\", \"Downloads/Misc\"],\n...     [\"Documents/Pictures\", \"Documents/Misc\"],\n...     overriding=True,\n... )\n&gt;&gt;&gt; root_other.show()\nDocuments\n\u251c\u2500\u2500 Pictures\n\u2502   \u2514\u2500\u2500 photo1.jpg\n\u2514\u2500\u2500 Misc\n    \u2514\u2500\u2500 dummy\n        \u2514\u2500\u2500 photo2.jpg\n</code></pre> <p>In <code>merge_children=True</code> case, child nodes are copied instead of the parent node.</p> <ul> <li>If the path already exists, child nodes are merged with existing children</li> <li>Otherwise, the child nodes of the node are merged with the node's parent</li> </ul> <pre><code>&gt;&gt;&gt; root_other = str_to_tree(\n... \"Documents\\n\"\n... \"\u2514\u2500\u2500 Pictures\\n\"\n... \"    \u2514\u2500\u2500 photo3.jpg\"\n... )\n&gt;&gt;&gt; root_other.show()\nDocuments\n\u2514\u2500\u2500 Pictures\n    \u2514\u2500\u2500 photo3.jpg\n</code></pre> <pre><code>&gt;&gt;&gt; copy_nodes_from_tree_to_tree(\n...     root,\n...     root_other,\n...     [\"Downloads/Pictures\", \"Downloads/Misc\"],\n...     [\"Documents/Pictures\", \"Documents/Misc\"],\n...     merge_children=True,\n... )\n&gt;&gt;&gt; root_other.show()\nDocuments\n\u251c\u2500\u2500 Pictures\n\u2502   \u251c\u2500\u2500 photo3.jpg\n\u2502   \u2514\u2500\u2500 photo1.jpg\n\u2514\u2500\u2500 dummy\n    \u2514\u2500\u2500 photo2.jpg\n</code></pre> <p>In <code>merge_leaves=True</code> case, leaf nodes are copied instead of the parent node.</p> <ul> <li>If the path already exists, leaf nodes are merged with existing children</li> <li>Otherwise, the leaf nodes of the node are merged with the node's parent</li> </ul> <pre><code>&gt;&gt;&gt; root_other = str_to_tree(\n... \"Documents\\n\"\n... \"\u2514\u2500\u2500 Pictures\\n\"\n... \"    \u2514\u2500\u2500 photo3.jpg\"\n... )\n&gt;&gt;&gt; root_other.show()\nDocuments\n\u2514\u2500\u2500 Pictures\n    \u2514\u2500\u2500 photo3.jpg\n</code></pre> <pre><code>&gt;&gt;&gt; copy_nodes_from_tree_to_tree(\n...     root,\n...     root_other,\n...     [\"Downloads/Pictures\", \"Downloads/Misc\"],\n...     [\"Documents/Pictures\", \"Documents/Misc\"],\n...     merge_leaves=True,\n... )\n&gt;&gt;&gt; root_other.show()\nDocuments\n\u251c\u2500\u2500 Pictures\n\u2502   \u251c\u2500\u2500 photo3.jpg\n\u2502   \u2514\u2500\u2500 photo1.jpg\n\u2514\u2500\u2500 photo2.jpg\n</code></pre> <p>In <code>delete_children=True</code> case, only the node is copied without its accompanying children/descendants.</p> <pre><code>&gt;&gt;&gt; root_other = Node(\"Documents\")\n&gt;&gt;&gt; root_other.show()\nDocuments\n</code></pre> <pre><code>&gt;&gt;&gt; copy_nodes_from_tree_to_tree(\n...     root,\n...     root_other,\n...     [\"Downloads/Pictures\", \"Downloads/Misc\"],\n...     [\"Documents/Pictures\", \"Documents/Misc\"],\n...     delete_children=True,\n... )\n&gt;&gt;&gt; root_other.show()\nDocuments\n\u251c\u2500\u2500 Pictures\n\u2514\u2500\u2500 Misc\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>from_tree</code> <code>T</code> <p>tree to copy nodes from</p> required <code>to_tree</code> <code>T</code> <p>tree to copy nodes to</p> required <code>from_paths</code> <code>List[str]</code> <p>original paths to copy nodes from</p> required <code>to_paths</code> <code>List[Optional[str]]</code> <p>new paths to copy nodes to</p> required <code>sep</code> <code>str</code> <p>path separator for input paths, applies to <code>from_path</code> and <code>to_path</code></p> <code>'/'</code> <code>skippable</code> <code>bool</code> <p>indicator to skip if from path is not found</p> <code>False</code> <code>overriding</code> <code>bool</code> <p>indicator to override existing to path if there is clashes</p> <code>False</code> <code>merge_attribute</code> <code>bool</code> <p>indicator to merge attributes of from-path and to-path if there are clashes</p> <code>False</code> <code>merge_children</code> <code>bool</code> <p>indicator to merge from-path's children and remove intermediate parent node</p> <code>False</code> <code>merge_leaves</code> <code>bool</code> <p>indicator to merge from-path's leaf nodes and remove intermediate parent node(s)</p> <code>False</code> <code>delete_children</code> <code>bool</code> <p>indicator to copy node only without children</p> <code>False</code> <code>with_full_path</code> <code>bool</code> <p>indicator to copy node with full path in <code>from_paths</code>, results in faster search</p> <code>False</code>"},{"location":"bigtree/tree/modify/#bigtree.tree.modify.copy_and_replace_nodes_from_tree_to_tree","title":"copy_and_replace_nodes_from_tree_to_tree","text":"<pre><code>copy_and_replace_nodes_from_tree_to_tree(\n    from_tree,\n    to_tree,\n    from_paths,\n    to_paths,\n    sep=\"/\",\n    skippable=False,\n    delete_children=False,\n    with_full_path=False,\n)\n</code></pre> <p>Copy nodes from <code>from_paths</code> to replace <code>to_paths</code> in-place.</p> <ul> <li>Creates intermediate nodes if to-path is not present</li> <li>Able to skip nodes if from-path is not found, defaults to False (from-nodes must be found; not skippable)</li> <li>Able to copy node only and delete children, defaults to False (nodes are copied together with children)</li> </ul> <p>For paths in <code>from_paths</code> and <code>to_paths</code>,</p> <ul> <li>Path name can be with or without leading tree path separator symbol</li> </ul> <p>For paths in <code>from_paths</code>,</p> <ul> <li>Path name can be partial path (trailing part of path) or node name</li> <li>If <code>with_full_path=True</code>, path name must be full path</li> <li>Path name must be unique to one node</li> </ul> <p>For paths in <code>to_paths</code>,</p> <ul> <li>Path name must be full path</li> <li>Path must exist, node-to-be-replaced must be present</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import str_to_tree, copy_and_replace_nodes_from_tree_to_tree\n&gt;&gt;&gt; root = str_to_tree(\n... \"Downloads\\n\"\n... \"\u251c\u2500\u2500 file1.doc\\n\"\n... \"\u251c\u2500\u2500 Pictures\\n\"\n... \"\u2502   \u2514\u2500\u2500 photo1.jpg\\n\"\n... \"\u2514\u2500\u2500 Misc\\n\"\n... \"    \u2514\u2500\u2500 dummy\\n\"\n... \"        \u2514\u2500\u2500 photo2.jpg\"\n... )\n&gt;&gt;&gt; root.show()\nDownloads\n\u251c\u2500\u2500 file1.doc\n\u251c\u2500\u2500 Pictures\n\u2502   \u2514\u2500\u2500 photo1.jpg\n\u2514\u2500\u2500 Misc\n    \u2514\u2500\u2500 dummy\n        \u2514\u2500\u2500 photo2.jpg\n</code></pre> <pre><code>&gt;&gt;&gt; root_other = str_to_tree(\n... \"Documents\\n\"\n... \"\u251c\u2500\u2500 Pictures2\\n\"\n... \"\u2502   \u2514\u2500\u2500 photo2.jpg\\n\"\n... \"\u2514\u2500\u2500 Misc2\"\n... )\n&gt;&gt;&gt; root_other.show()\nDocuments\n\u251c\u2500\u2500 Pictures2\n\u2502   \u2514\u2500\u2500 photo2.jpg\n\u2514\u2500\u2500 Misc2\n</code></pre> <pre><code>&gt;&gt;&gt; copy_and_replace_nodes_from_tree_to_tree(\n...     from_tree=root,\n...     to_tree=root_other,\n...     from_paths=[\"Downloads/Pictures\", \"Downloads/Misc\"],\n...     to_paths=[\"Documents/Pictures2/photo2.jpg\", \"Documents/Misc2\"],\n... )\n&gt;&gt;&gt; root_other.show()\nDocuments\n\u251c\u2500\u2500 Pictures2\n\u2502   \u2514\u2500\u2500 Pictures\n\u2502       \u2514\u2500\u2500 photo1.jpg\n\u2514\u2500\u2500 Misc\n    \u2514\u2500\u2500 dummy\n        \u2514\u2500\u2500 photo2.jpg\n</code></pre> <p>In <code>delete_children=True</code> case, only the node is copied without its accompanying children/descendants.</p> <pre><code>&gt;&gt;&gt; root_other = str_to_tree(\n... \"Documents\\n\"\n... \"\u251c\u2500\u2500 Pictures2\\n\"\n... \"\u2502   \u2514\u2500\u2500 photo2.jpg\\n\"\n... \"\u2514\u2500\u2500 Misc2\"\n... )\n&gt;&gt;&gt; root_other.show()\nDocuments\n\u251c\u2500\u2500 Pictures2\n\u2502   \u2514\u2500\u2500 photo2.jpg\n\u2514\u2500\u2500 Misc2\n</code></pre> <pre><code>&gt;&gt;&gt; copy_and_replace_nodes_from_tree_to_tree(\n...     from_tree=root,\n...     to_tree=root_other,\n...     from_paths=[\"Downloads/Pictures\", \"Downloads/Misc\"],\n...     to_paths=[\"Documents/Pictures2/photo2.jpg\", \"Documents/Misc2\"],\n...     delete_children=True,\n... )\n&gt;&gt;&gt; root_other.show()\nDocuments\n\u251c\u2500\u2500 Pictures2\n\u2502   \u2514\u2500\u2500 Pictures\n\u2514\u2500\u2500 Misc\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>from_tree</code> <code>T</code> <p>tree to copy nodes from</p> required <code>to_tree</code> <code>T</code> <p>tree to copy nodes to</p> required <code>from_paths</code> <code>List[str]</code> <p>original paths to copy nodes from</p> required <code>to_paths</code> <code>List[str]</code> <p>new paths to copy nodes to</p> required <code>sep</code> <code>str</code> <p>path separator for input paths, applies to <code>from_path</code> and <code>to_path</code></p> <code>'/'</code> <code>skippable</code> <code>bool</code> <p>indicator to skip if from path is not found</p> <code>False</code> <code>delete_children</code> <code>bool</code> <p>indicator to copy node only without children</p> <code>False</code> <code>with_full_path</code> <code>bool</code> <p>indicator to copy node with full path in <code>from_paths</code>, results in faster search</p> <code>False</code>"},{"location":"bigtree/tree/modify/#bigtree.tree.modify.copy_or_shift_logic","title":"copy_or_shift_logic","text":"<pre><code>copy_or_shift_logic(\n    tree,\n    from_paths,\n    to_paths,\n    sep=\"/\",\n    copy=False,\n    skippable=False,\n    overriding=False,\n    merge_attribute=False,\n    merge_children=False,\n    merge_leaves=False,\n    delete_children=False,\n    to_tree=None,\n    with_full_path=False,\n)\n</code></pre> <p>Shift or copy nodes from <code>from_paths</code> to <code>to_paths</code> in-place.</p> <ul> <li>Creates intermediate nodes if to-path is not present</li> <li>Able to copy node, defaults to False (nodes are shifted; not copied)</li> <li>Able to skip nodes if from-path is not found, defaults to False (from-nodes must be found; not skippable)</li> <li>Able to override existing node if it exists, defaults to False (to-nodes must not exist; not overridden)</li> <li>Able to merge attributes of node if it exists, defaults to False (to-nodes must not exist; no attributes to merge)</li> <li>Able to merge children and remove intermediate parent node, defaults to False (nodes are shifted; not merged)</li> <li>Able to merge only leaf nodes and remove all intermediate nodes, defaults to False (nodes are shifted; not merged)</li> <li>Able to shift/copy node only and delete children, defaults to False (nodes are shifted/copied together with children)</li> <li>Able to shift/copy nodes from one tree to another tree, defaults to None (shifting/copying happens within same tree)</li> </ul> <p>For paths in <code>from_paths</code> and <code>to_paths</code>,</p> <ul> <li>Path name can be with or without leading tree path separator symbol</li> </ul> <p>For paths in <code>from_paths</code>,</p> <ul> <li>Path name can be partial path (trailing part of path) or node name</li> <li>If <code>with_full_path=True</code>, path name must be full path</li> <li>Path name must be unique to one node</li> </ul> <p>For paths in <code>to_paths</code>,</p> <ul> <li>Path name must be full path</li> <li>Can set to empty string or None to delete the path in <code>from_paths</code>, note that <code>copy</code> must be set to False</li> </ul> <p>If <code>merge_children=True</code>,</p> <ul> <li>If <code>to_path</code> is not present, it shifts/copies children of <code>from_path</code></li> <li>If <code>to_path</code> is present, and <code>overriding=False</code>, original and new children are merged</li> <li>If <code>to_path</code> is present and <code>overriding=True</code>, it behaves like overriding and only new children are retained</li> </ul> <p>If <code>merge_leaves=True</code>,</p> <ul> <li>If <code>to_path</code> is not present, it shifts/copies leaves of <code>from_path</code></li> <li>If <code>to_path</code> is present, and <code>overriding=False</code>, original children and leaves are merged</li> <li>If <code>to_path</code> is present and <code>overriding=True</code>, it behaves like overriding and only new leaves are retained,     original child nodes in <code>from_path</code> are retained</li> </ul> <p>Note:</p> <ul> <li><code>merge_children</code> and <code>merge_leaves</code> cannot be both True at the same time</li> <li><code>overriding</code> and <code>merge_attribute</code> cannot be both True at the same time</li> </ul> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>T</code> <p>tree to modify</p> required <code>from_paths</code> <code>List[str]</code> <p>original paths to copy/shift nodes from</p> required <code>to_paths</code> <code>List[Optional[str]]</code> <p>new paths to copy/shift nodes to</p> required <code>sep</code> <code>str</code> <p>path separator for input paths, applies to <code>from_path</code> and <code>to_path</code></p> <code>'/'</code> <code>copy</code> <code>bool</code> <p>indicator to copy node,</p> <code>False</code> <code>skippable</code> <code>bool</code> <p>indicator to skip if from-path is not found</p> <code>False</code> <code>overriding</code> <code>bool</code> <p>indicator to override existing to-path if there are clashes</p> <code>False</code> <code>merge_attribute</code> <code>bool</code> <p>indicator to merge attributes of from-path and to-path if there are clashes</p> <code>False</code> <code>merge_children</code> <code>bool</code> <p>indicator to merge from-path's children and remove intermediate parent node</p> <code>False</code> <code>merge_leaves</code> <code>bool</code> <p>indicator to merge from-path's leaf nodes and remove intermediate parent node(s)</p> <code>False</code> <code>delete_children</code> <code>bool</code> <p>indicator to copy/shift node only without children</p> <code>False</code> <code>to_tree</code> <code>Optional[T]</code> <p>tree to copy to</p> <code>None</code> <code>with_full_path</code> <code>bool</code> <p>indicator to copy/shift node with full path in <code>from_paths</code>, results in faster search</p> <code>False</code>"},{"location":"bigtree/tree/modify/#bigtree.tree.modify.replace_logic","title":"replace_logic","text":"<pre><code>replace_logic(\n    tree,\n    from_paths,\n    to_paths,\n    sep=\"/\",\n    copy=False,\n    skippable=False,\n    delete_children=False,\n    to_tree=None,\n    with_full_path=False,\n)\n</code></pre> <p>Shift or copy nodes from <code>from_paths</code> to replace <code>to_paths</code> in-place.</p> <ul> <li>Creates intermediate nodes if to-path is not present</li> <li>Able to copy node, defaults to False (nodes are shifted; not copied)</li> <li>Able to skip nodes if from-path is not found, defaults to False (from-nodes must be found; not skippable)</li> <li>Able to replace node only and delete children, defaults to False (nodes are shifted/copied together with children)</li> <li>Able to shift/copy nodes from one tree to another tree, defaults to None (shifting/copying happens within same tree)</li> </ul> <p>For paths in <code>from_paths</code> and <code>to_paths</code>,</p> <ul> <li>Path name can be with or without leading tree path separator symbol</li> </ul> <p>For paths in <code>from_paths</code>,</p> <ul> <li>Path name can be partial path (trailing part of path) or node name</li> <li>If <code>with_full_path=True</code>, path name must be full path</li> <li>Path name must be unique to one node</li> </ul> <p>For paths in <code>to_paths</code>,</p> <ul> <li>Path name must be full path</li> <li>Path must exist, node-to-be-replaced must be present</li> </ul> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>T</code> <p>tree to modify</p> required <code>from_paths</code> <code>List[str]</code> <p>original paths to copy/shift nodes from</p> required <code>to_paths</code> <code>List[str]</code> <p>new paths to copy/shift nodes to</p> required <code>sep</code> <code>str</code> <p>path separator for input paths, applies to <code>from_path</code> and <code>to_path</code></p> <code>'/'</code> <code>copy</code> <code>bool</code> <p>indicator to copy node</p> <code>False</code> <code>skippable</code> <code>bool</code> <p>indicator to skip if from-path is not found</p> <code>False</code> <code>delete_children</code> <code>bool</code> <p>indicator to copy/shift node only without children</p> <code>False</code> <code>to_tree</code> <code>Optional[T]</code> <p>tree to copy to</p> <code>None</code> <code>with_full_path</code> <code>bool</code> <p>indicator to copy/shift node with full path in <code>from_paths</code>, results in faster search</p> <code>False</code>"},{"location":"bigtree/tree/search/","title":"\ud83d\udd0d Search","text":"<p>Search methods for Trees.</p> Search by One node One or more nodes General method <code>find</code>, <code>find_child</code> <code>findall</code>, <code>find_children</code> Node name <code>find_name</code>, <code>find_child_by_name</code> <code>find_names</code> Node path <code>find_path</code>, <code>find_full_path</code>, <code>find_relative_path</code> <code>find_paths</code>, <code>find_relative_paths</code> Node attributes <code>find_attr</code> <code>find_attrs</code>"},{"location":"bigtree/tree/search/#bigtree.tree.search","title":"bigtree.tree.search","text":""},{"location":"bigtree/tree/search/#bigtree.tree.search.findall","title":"findall","text":"<pre><code>findall(\n    tree, condition, max_depth=0, min_count=0, max_count=0\n)\n</code></pre> <p>Search tree for one or more nodes matching condition (callable function).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, findall\n&gt;&gt;&gt; root = Node(\"a\", age=90)\n&gt;&gt;&gt; b = Node(\"b\", age=65, parent=root)\n&gt;&gt;&gt; c = Node(\"c\", age=60, parent=root)\n&gt;&gt;&gt; d = Node(\"d\", age=40, parent=c)\n&gt;&gt;&gt; findall(root, lambda node: node.age &gt; 62)\n(Node(/a, age=90), Node(/a/b, age=65))\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>T</code> <p>tree to search</p> required <code>condition</code> <code>Callable[[T], bool]</code> <p>function that takes in node as argument, returns node if condition evaluates to <code>True</code></p> required <code>max_depth</code> <code>int</code> <p>maximum depth to search for, based on the <code>depth</code> attribute</p> <code>0</code> <code>min_count</code> <code>int</code> <p>checks for minimum number of occurrences, raise exceptions.SearchError if the number of results do not meet min_count</p> <code>0</code> <code>max_count</code> <code>int</code> <p>checks for maximum number of occurrences, raise exceptions.SearchError if the number of results do not meet min_count</p> <code>0</code> <p>Returns:</p> Type Description <code>Tuple[T, ...]</code> <p>Search results</p>"},{"location":"bigtree/tree/search/#bigtree.tree.search.find","title":"find","text":"<pre><code>find(tree, condition, max_depth=0)\n</code></pre> <p>Search tree for a single node matching condition (callable function).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, find\n&gt;&gt;&gt; root = Node(\"a\", age=90)\n&gt;&gt;&gt; b = Node(\"b\", age=65, parent=root)\n&gt;&gt;&gt; c = Node(\"c\", age=60, parent=root)\n&gt;&gt;&gt; d = Node(\"d\", age=40, parent=c)\n&gt;&gt;&gt; find(root, lambda node: node.age == 65)\nNode(/a/b, age=65)\n&gt;&gt;&gt; find(root, lambda node: node.age &gt; 5)\nTraceback (most recent call last):\n    ...\nbigtree.utils.exceptions.exceptions.SearchError: Expected less than or equal to 1 element(s), found 4 elements\n(Node(/a, age=90), Node(/a/b, age=65), Node(/a/c, age=60), Node(/a/c/d, age=40))\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>T</code> <p>tree to search</p> required <code>condition</code> <code>Callable[[T], bool]</code> <p>function that takes in node as argument, returns node if condition evaluates to <code>True</code></p> required <code>max_depth</code> <code>int</code> <p>maximum depth to search for, based on the <code>depth</code> attribute</p> <code>0</code> <p>Returns:</p> Type Description <code>T</code> <p>Search result</p>"},{"location":"bigtree/tree/search/#bigtree.tree.search.find_name","title":"find_name","text":"<pre><code>find_name(tree, name, max_depth=0)\n</code></pre> <p>Search tree for a single node matching name attribute.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, find_name\n&gt;&gt;&gt; root = Node(\"a\", age=90)\n&gt;&gt;&gt; b = Node(\"b\", age=65, parent=root)\n&gt;&gt;&gt; c = Node(\"c\", age=60, parent=root)\n&gt;&gt;&gt; d = Node(\"d\", age=40, parent=c)\n&gt;&gt;&gt; find_name(root, \"c\")\nNode(/a/c, age=60)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>NodeT</code> <p>tree to search</p> required <code>name</code> <code>str</code> <p>value to match for name attribute</p> required <code>max_depth</code> <code>int</code> <p>maximum depth to search for, based on the <code>depth</code> attribute</p> <code>0</code> <p>Returns:</p> Type Description <code>NodeT</code> <p>Search result</p>"},{"location":"bigtree/tree/search/#bigtree.tree.search.find_names","title":"find_names","text":"<pre><code>find_names(tree, name, max_depth=0)\n</code></pre> <p>Search tree for one or more nodes matching name attribute.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, find_names\n&gt;&gt;&gt; root = Node(\"a\", age=90)\n&gt;&gt;&gt; b = Node(\"b\", age=65, parent=root)\n&gt;&gt;&gt; c = Node(\"c\", age=60, parent=root)\n&gt;&gt;&gt; d = Node(\"b\", age=40, parent=c)\n&gt;&gt;&gt; find_names(root, \"c\")\n(Node(/a/c, age=60),)\n&gt;&gt;&gt; find_names(root, \"b\")\n(Node(/a/b, age=65), Node(/a/c/b, age=40))\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>NodeT</code> <p>tree to search</p> required <code>name</code> <code>str</code> <p>value to match for name attribute</p> required <code>max_depth</code> <code>int</code> <p>maximum depth to search for, based on the <code>depth</code> attribute</p> <code>0</code> <p>Returns:</p> Type Description <code>Iterable[NodeT]</code> <p>Search results</p>"},{"location":"bigtree/tree/search/#bigtree.tree.search.find_relative_path","title":"find_relative_path","text":"<pre><code>find_relative_path(tree, path_name)\n</code></pre> <p>Search tree for a single node matching relative path attribute.</p> <ul> <li>Supports unix folder expression for relative path, i.e., '../../node_name'</li> <li>Supports wildcards, i.e., '*/node_name'</li> <li>If path name starts with leading separator symbol, it will start at root node</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, find_relative_path\n&gt;&gt;&gt; root = Node(\"a\", age=90)\n&gt;&gt;&gt; b = Node(\"b\", age=65, parent=root)\n&gt;&gt;&gt; c = Node(\"c\", age=60, parent=root)\n&gt;&gt;&gt; d = Node(\"d\", age=40, parent=c)\n&gt;&gt;&gt; find_relative_path(d, \"..\")\nNode(/a/c, age=60)\n&gt;&gt;&gt; find_relative_path(d, \"../../b\")\nNode(/a/b, age=65)\n&gt;&gt;&gt; find_relative_path(d, \"../../*\")\nTraceback (most recent call last):\n    ...\nbigtree.utils.exceptions.exceptions.SearchError: Expected less than or equal to 1 element(s), found 2 elements\n(Node(/a/b, age=65), Node(/a/c, age=60))\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>NodeT</code> <p>tree to search</p> required <code>path_name</code> <code>str</code> <p>value to match (relative path) of path_name attribute</p> required <p>Returns:</p> Type Description <code>NodeT</code> <p>Search result</p>"},{"location":"bigtree/tree/search/#bigtree.tree.search.find_relative_paths","title":"find_relative_paths","text":"<pre><code>find_relative_paths(\n    tree, path_name, min_count=0, max_count=0\n)\n</code></pre> <p>Search tree for one or more nodes matching relative path attribute.</p> <ul> <li>Supports unix folder expression for relative path, i.e., '../../node_name'</li> <li>Supports wildcards, i.e., '*/node_name'</li> <li>If path name starts with leading separator symbol, it will start at root node</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, find_relative_paths\n&gt;&gt;&gt; root = Node(\"a\", age=90)\n&gt;&gt;&gt; b = Node(\"b\", age=65, parent=root)\n&gt;&gt;&gt; c = Node(\"c\", age=60, parent=root)\n&gt;&gt;&gt; d = Node(\"d\", age=40, parent=c)\n&gt;&gt;&gt; find_relative_paths(d, \"..\")\n(Node(/a/c, age=60),)\n&gt;&gt;&gt; find_relative_paths(d, \"../../b\")\n(Node(/a/b, age=65),)\n&gt;&gt;&gt; find_relative_paths(d, \"../../*\")\n(Node(/a/b, age=65), Node(/a/c, age=60))\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>NodeT</code> <p>tree to search</p> required <code>path_name</code> <code>str</code> <p>value to match (relative path) of path_name attribute</p> required <code>min_count</code> <code>int</code> <p>checks for minimum number of occurrences, raise exceptions.SearchError if the number of results do not meet min_count</p> <code>0</code> <code>max_count</code> <code>int</code> <p>checks for maximum number of occurrences, raise exceptions.SearchError if the number of results do not meet min_count</p> <code>0</code> <p>Returns:</p> Type Description <code>Tuple[NodeT, ...]</code> <p>Search results</p>"},{"location":"bigtree/tree/search/#bigtree.tree.search.find_full_path","title":"find_full_path","text":"<pre><code>find_full_path(tree, path_name)\n</code></pre> <p>Search tree for a single node matching path attribute.</p> <ul> <li>Path name can be with or without leading tree path separator symbol</li> <li>Path name must be full path, works similar to <code>find_path</code> but faster</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, find_full_path\n&gt;&gt;&gt; root = Node(\"a\", age=90)\n&gt;&gt;&gt; b = Node(\"b\", age=65, parent=root)\n&gt;&gt;&gt; c = Node(\"c\", age=60, parent=root)\n&gt;&gt;&gt; d = Node(\"d\", age=40, parent=c)\n&gt;&gt;&gt; find_full_path(root, \"/a/c/d\")\nNode(/a/c/d, age=40)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>NodeT</code> <p>tree to search</p> required <code>path_name</code> <code>str</code> <p>value to match (full path) of path_name attribute</p> required <p>Returns:</p> Type Description <code>NodeT</code> <p>Search result</p>"},{"location":"bigtree/tree/search/#bigtree.tree.search.find_path","title":"find_path","text":"<pre><code>find_path(tree, path_name)\n</code></pre> <p>Search tree for a single node matching path attribute.</p> <ul> <li>Path name can be with or without leading tree path separator symbol</li> <li>Path name can be full path or partial path (trailing part of path) or node name</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, find_path\n&gt;&gt;&gt; root = Node(\"a\", age=90)\n&gt;&gt;&gt; b = Node(\"b\", age=65, parent=root)\n&gt;&gt;&gt; c = Node(\"c\", age=60, parent=root)\n&gt;&gt;&gt; d = Node(\"d\", age=40, parent=c)\n&gt;&gt;&gt; find_path(root, \"c\")\nNode(/a/c, age=60)\n&gt;&gt;&gt; find_path(root, \"/c\")\nNode(/a/c, age=60)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>NodeT</code> <p>tree to search</p> required <code>path_name</code> <code>str</code> <p>value to match (full path) or trailing part (partial path) of path_name attribute</p> required <p>Returns:</p> Type Description <code>NodeT</code> <p>Search result</p>"},{"location":"bigtree/tree/search/#bigtree.tree.search.find_paths","title":"find_paths","text":"<pre><code>find_paths(tree, path_name)\n</code></pre> <p>Search tree for one or more nodes matching path attribute.</p> <ul> <li>Path name can be with or without leading tree path separator symbol</li> <li>Path name can be partial path (trailing part of path) or node name</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, find_paths\n&gt;&gt;&gt; root = Node(\"a\", age=90)\n&gt;&gt;&gt; b = Node(\"b\", age=65, parent=root)\n&gt;&gt;&gt; c = Node(\"c\", age=60, parent=root)\n&gt;&gt;&gt; d = Node(\"c\", age=40, parent=c)\n&gt;&gt;&gt; find_paths(root, \"/a/c\")\n(Node(/a/c, age=60),)\n&gt;&gt;&gt; find_paths(root, \"/c\")\n(Node(/a/c, age=60), Node(/a/c/c, age=40))\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>NodeT</code> <p>tree to search</p> required <code>path_name</code> <code>str</code> <p>value to match (full path) or trailing part (partial path) of path_name attribute</p> required <p>Returns:</p> Type Description <code>Iterable[NodeT]</code> <p>Search results</p>"},{"location":"bigtree/tree/search/#bigtree.tree.search.find_attr","title":"find_attr","text":"<pre><code>find_attr(tree, attr_name, attr_value, max_depth=0)\n</code></pre> <p>Search tree for a single node matching custom attribute.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, find_attr\n&gt;&gt;&gt; root = Node(\"a\", age=90)\n&gt;&gt;&gt; b = Node(\"b\", age=65, parent=root)\n&gt;&gt;&gt; c = Node(\"c\", age=60, parent=root)\n&gt;&gt;&gt; d = Node(\"d\", age=40, parent=c)\n&gt;&gt;&gt; find_attr(root, \"age\", 65)\nNode(/a/b, age=65)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>BaseNode</code> <p>tree to search</p> required <code>attr_name</code> <code>str</code> <p>attribute name to perform matching</p> required <code>attr_value</code> <code>Any</code> <p>value to match for attr_name attribute</p> required <code>max_depth</code> <code>int</code> <p>maximum depth to search for, based on the <code>depth</code> attribute</p> <code>0</code> <p>Returns:</p> Type Description <code>BaseNode</code> <p>Search result</p>"},{"location":"bigtree/tree/search/#bigtree.tree.search.find_attrs","title":"find_attrs","text":"<pre><code>find_attrs(tree, attr_name, attr_value, max_depth=0)\n</code></pre> <p>Search tree for one or more nodes matching custom attribute.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, find_attrs\n&gt;&gt;&gt; root = Node(\"a\", age=90)\n&gt;&gt;&gt; b = Node(\"b\", age=65, parent=root)\n&gt;&gt;&gt; c = Node(\"c\", age=65, parent=root)\n&gt;&gt;&gt; d = Node(\"d\", age=40, parent=c)\n&gt;&gt;&gt; find_attrs(root, \"age\", 65)\n(Node(/a/b, age=65), Node(/a/c, age=65))\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>BaseNode</code> <p>tree to search</p> required <code>attr_name</code> <code>str</code> <p>attribute name to perform matching</p> required <code>attr_value</code> <code>Any</code> <p>value to match for attr_name attribute</p> required <code>max_depth</code> <code>int</code> <p>maximum depth to search for, based on the <code>depth</code> attribute</p> <code>0</code> <p>Returns:</p> Type Description <code>Iterable[BaseNode]</code> <p>Search results</p>"},{"location":"bigtree/tree/search/#bigtree.tree.search.find_children","title":"find_children","text":"<pre><code>find_children(tree, condition, min_count=0, max_count=0)\n</code></pre> <p>Search children for one or more nodes matching condition (callable function).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, find_children\n&gt;&gt;&gt; root = Node(\"a\", age=90)\n&gt;&gt;&gt; b = Node(\"b\", age=65, parent=root)\n&gt;&gt;&gt; c = Node(\"c\", age=60, parent=root)\n&gt;&gt;&gt; d = Node(\"d\", age=40, parent=c)\n&gt;&gt;&gt; find_children(root, lambda node: node.age &gt; 30)\n(Node(/a/b, age=65), Node(/a/c, age=60))\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>Union[T, DAGNodeT]</code> <p>tree to search for its children</p> required <code>condition</code> <code>Callable[[Union[T, DAGNodeT]], bool]</code> <p>function that takes in node as argument, returns node if condition evaluates to <code>True</code></p> required <code>min_count</code> <code>int</code> <p>checks for minimum number of occurrences, raise exceptions.SearchError if the number of results do not meet min_count</p> <code>0</code> <code>max_count</code> <code>int</code> <p>checks for maximum number of occurrences, raise exceptions.SearchError if the number of results do not meet min_count</p> <code>0</code> <p>Returns:</p> Type Description <code>Tuple[Union[T, DAGNodeT], ...]</code> <p>Search results</p>"},{"location":"bigtree/tree/search/#bigtree.tree.search.find_child","title":"find_child","text":"<pre><code>find_child(tree, condition)\n</code></pre> <p>Search children for a single node matching condition (callable function).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, find_child\n&gt;&gt;&gt; root = Node(\"a\", age=90)\n&gt;&gt;&gt; b = Node(\"b\", age=65, parent=root)\n&gt;&gt;&gt; c = Node(\"c\", age=60, parent=root)\n&gt;&gt;&gt; d = Node(\"d\", age=40, parent=c)\n&gt;&gt;&gt; find_child(root, lambda node: node.age &gt; 62)\nNode(/a/b, age=65)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>Union[T, DAGNodeT]</code> <p>tree to search for its child</p> required <code>condition</code> <code>Callable[[Union[T, DAGNodeT]], bool]</code> <p>function that takes in node as argument, returns node if condition evaluates to <code>True</code></p> required <p>Returns:</p> Type Description <code>Union[T, DAGNodeT]</code> <p>Search result</p>"},{"location":"bigtree/tree/search/#bigtree.tree.search.find_child_by_name","title":"find_child_by_name","text":"<pre><code>find_child_by_name(tree, name)\n</code></pre> <p>Search tree for a single node matching name attribute.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, find_child_by_name\n&gt;&gt;&gt; root = Node(\"a\", age=90)\n&gt;&gt;&gt; b = Node(\"b\", age=65, parent=root)\n&gt;&gt;&gt; c = Node(\"c\", age=60, parent=root)\n&gt;&gt;&gt; d = Node(\"d\", age=40, parent=c)\n&gt;&gt;&gt; find_child_by_name(root, \"c\")\nNode(/a/c, age=60)\n&gt;&gt;&gt; find_child_by_name(c, \"d\")\nNode(/a/c/d, age=40)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>Union[NodeT, DAGNodeT]</code> <p>tree to search, parent node</p> required <code>name</code> <code>str</code> <p>value to match for name attribute, child node</p> required <p>Returns:</p> Type Description <code>Union[NodeT, DAGNodeT]</code> <p>Search result</p>"},{"location":"bigtree/utils/iterators/","title":"\u27b0 Iterators","text":"<p>Iterator methods for Trees and DAGs.</p>"},{"location":"bigtree/utils/iterators/#iterator-methods","title":"Iterator Methods","text":"Data Structure Algorithm Description Binary Tree In-order Traversal Depth-First Search, LNR Tree Pre-order Traversal Depth-First Search, NLR Tree Post-Order Traversal Depth-First Search, LRN Tree Level-Order Traversal Breadth-First Search Tree ZigZag Traversal Breadth-First Search Tree ZigZag Group Traversal Breadth-First Search DAG General Depth-First Search"},{"location":"bigtree/utils/iterators/#bigtree.utils.iterators","title":"bigtree.utils.iterators","text":""},{"location":"bigtree/utils/iterators/#bigtree.utils.iterators.inorder_iter","title":"inorder_iter","text":"<pre><code>inorder_iter(tree, filter_condition=None, max_depth=0)\n</code></pre> <p>Iterate through all children of a tree.</p> <p>In-Order Iteration Algorithm (LNR):     1. Recursively traverse the current node's left subtree     2. Visit the current node     3. Recursively traverse the current node's right subtree</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import BinaryNode, list_to_binarytree, inorder_iter\n&gt;&gt;&gt; num_list = [1, 2, 3, 4, 5, 6, 7, 8]\n&gt;&gt;&gt; root = list_to_binarytree(num_list)\n&gt;&gt;&gt; root.show()\n1\n\u251c\u2500\u2500 2\n\u2502   \u251c\u2500\u2500 4\n\u2502   \u2502   \u2514\u2500\u2500 8\n\u2502   \u2514\u2500\u2500 5\n\u2514\u2500\u2500 3\n    \u251c\u2500\u2500 6\n    \u2514\u2500\u2500 7\n</code></pre> <pre><code>&gt;&gt;&gt; [node.node_name for node in inorder_iter(root)]\n['8', '4', '2', '5', '1', '6', '3', '7']\n</code></pre> <pre><code>&gt;&gt;&gt; [node.node_name for node in inorder_iter(root, filter_condition=lambda x: x.node_name in [\"1\", \"4\", \"3\", \"6\", \"7\"])]\n['4', '1', '6', '3', '7']\n</code></pre> <pre><code>&gt;&gt;&gt; [node.node_name for node in inorder_iter(root, max_depth=3)]\n['4', '2', '5', '1', '6', '3', '7']\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>BinaryNodeT</code> <p>input tree</p> required <code>filter_condition</code> <code>Optional[Callable[[BinaryNodeT], bool]]</code> <p>function that takes in node as argument. Return node if condition evaluates to <code>True</code></p> <code>None</code> <code>max_depth</code> <code>int</code> <p>maximum depth of iteration, based on <code>depth</code> attribute</p> <code>0</code> <p>Returns:</p> Type Description <code>Iterable[BinaryNodeT]</code> <p>Iterable of nodes</p>"},{"location":"bigtree/utils/iterators/#bigtree.utils.iterators.preorder_iter","title":"preorder_iter","text":"<pre><code>preorder_iter(\n    tree,\n    filter_condition=None,\n    stop_condition=None,\n    max_depth=0,\n)\n</code></pre> <p>Iterate through all children of a tree.</p> <p>Pre-Order Iteration Algorithm (NLR):     1. Visit the current node     2. Recursively traverse the current node's left subtree     3. Recursively traverse the current node's right subtree</p> <p>It is topologically sorted because a parent node is processed before its child nodes.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, list_to_tree, preorder_iter\n&gt;&gt;&gt; path_list = [\"a/b/d\", \"a/b/e/g\", \"a/b/e/h\", \"a/c/f\"]\n&gt;&gt;&gt; root = list_to_tree(path_list)\n&gt;&gt;&gt; root.show()\na\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 d\n\u2502   \u2514\u2500\u2500 e\n\u2502       \u251c\u2500\u2500 g\n\u2502       \u2514\u2500\u2500 h\n\u2514\u2500\u2500 c\n    \u2514\u2500\u2500 f\n</code></pre> <pre><code>&gt;&gt;&gt; [node.node_name for node in preorder_iter(root)]\n['a', 'b', 'd', 'e', 'g', 'h', 'c', 'f']\n</code></pre> <pre><code>&gt;&gt;&gt; [node.node_name for node in preorder_iter(root, filter_condition=lambda x: x.node_name in [\"a\", \"d\", \"e\", \"f\", \"g\"])]\n['a', 'd', 'e', 'g', 'f']\n</code></pre> <pre><code>&gt;&gt;&gt; [node.node_name for node in preorder_iter(root, stop_condition=lambda x: x.node_name == \"e\")]\n['a', 'b', 'd', 'c', 'f']\n</code></pre> <pre><code>&gt;&gt;&gt; [node.node_name for node in preorder_iter(root, max_depth=3)]\n['a', 'b', 'd', 'e', 'c', 'f']\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>T</code> <p>input tree</p> required <code>filter_condition</code> <code>Optional[Callable[[T], bool]]</code> <p>function that takes in node as argument. Return node if condition evaluates to <code>True</code></p> <code>None</code> <code>stop_condition</code> <code>Optional[Callable[[T], bool]]</code> <p>function that takes in node as argument. Stops iteration if condition evaluates to <code>True</code></p> <code>None</code> <code>max_depth</code> <code>int</code> <p>maximum depth of iteration, based on <code>depth</code> attribute</p> <code>0</code> <p>Returns:</p> Type Description <code>Iterable[T]</code> <p>Iterable of nodes</p>"},{"location":"bigtree/utils/iterators/#bigtree.utils.iterators.postorder_iter","title":"postorder_iter","text":"<pre><code>postorder_iter(\n    tree,\n    filter_condition=None,\n    stop_condition=None,\n    max_depth=0,\n)\n</code></pre> <p>Iterate through all children of a tree.</p> <p>Post-Order Iteration Algorithm (LRN):     1. Recursively traverse the current node's left subtree     2. Recursively traverse the current node's right subtree     3. Visit the current node</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, list_to_tree, postorder_iter\n&gt;&gt;&gt; path_list = [\"a/b/d\", \"a/b/e/g\", \"a/b/e/h\", \"a/c/f\"]\n&gt;&gt;&gt; root = list_to_tree(path_list)\n&gt;&gt;&gt; root.show()\na\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 d\n\u2502   \u2514\u2500\u2500 e\n\u2502       \u251c\u2500\u2500 g\n\u2502       \u2514\u2500\u2500 h\n\u2514\u2500\u2500 c\n    \u2514\u2500\u2500 f\n</code></pre> <pre><code>&gt;&gt;&gt; [node.node_name for node in postorder_iter(root)]\n['d', 'g', 'h', 'e', 'b', 'f', 'c', 'a']\n</code></pre> <pre><code>&gt;&gt;&gt; [node.node_name for node in postorder_iter(root, filter_condition=lambda x: x.node_name in [\"a\", \"d\", \"e\", \"f\", \"g\"])]\n['d', 'g', 'e', 'f', 'a']\n</code></pre> <pre><code>&gt;&gt;&gt; [node.node_name for node in postorder_iter(root, stop_condition=lambda x: x.node_name == \"e\")]\n['d', 'b', 'f', 'c', 'a']\n</code></pre> <pre><code>&gt;&gt;&gt; [node.node_name for node in postorder_iter(root, max_depth=3)]\n['d', 'e', 'b', 'f', 'c', 'a']\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>BaseNodeT</code> <p>input tree</p> required <code>filter_condition</code> <code>Optional[Callable[[BaseNodeT], bool]]</code> <p>function that takes in node as argument. Return node if condition evaluates to <code>True</code></p> <code>None</code> <code>stop_condition</code> <code>Optional[Callable[[BaseNodeT], bool]]</code> <p>function that takes in node as argument. Stops iteration if condition evaluates to <code>True</code></p> <code>None</code> <code>max_depth</code> <code>int</code> <p>maximum depth of iteration, based on <code>depth</code> attribute</p> <code>0</code> <p>Returns:</p> Type Description <code>Iterable[BaseNodeT]</code> <p>Iterable of nodes</p>"},{"location":"bigtree/utils/iterators/#bigtree.utils.iterators.levelorder_iter","title":"levelorder_iter","text":"<pre><code>levelorder_iter(\n    tree,\n    filter_condition=None,\n    stop_condition=None,\n    max_depth=0,\n)\n</code></pre> <p>Iterate through all children of a tree.</p> Level-Order Iteration Algorithm <ol> <li>Recursively traverse the nodes on same level</li> </ol> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, list_to_tree, levelorder_iter\n&gt;&gt;&gt; path_list = [\"a/b/d\", \"a/b/e/g\", \"a/b/e/h\", \"a/c/f\"]\n&gt;&gt;&gt; root = list_to_tree(path_list)\n&gt;&gt;&gt; root.show()\na\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 d\n\u2502   \u2514\u2500\u2500 e\n\u2502       \u251c\u2500\u2500 g\n\u2502       \u2514\u2500\u2500 h\n\u2514\u2500\u2500 c\n    \u2514\u2500\u2500 f\n</code></pre> <pre><code>&gt;&gt;&gt; [node.node_name for node in levelorder_iter(root)]\n['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']\n</code></pre> <pre><code>&gt;&gt;&gt; [node.node_name for node in levelorder_iter(root, filter_condition=lambda x: x.node_name in [\"a\", \"d\", \"e\", \"f\", \"g\"])]\n['a', 'd', 'e', 'f', 'g']\n</code></pre> <pre><code>&gt;&gt;&gt; [node.node_name for node in levelorder_iter(root, stop_condition=lambda x: x.node_name == \"e\")]\n['a', 'b', 'c', 'd', 'f']\n</code></pre> <pre><code>&gt;&gt;&gt; [node.node_name for node in levelorder_iter(root, max_depth=3)]\n['a', 'b', 'c', 'd', 'e', 'f']\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>BaseNodeT</code> <p>input tree</p> required <code>filter_condition</code> <code>Optional[Callable[[BaseNodeT], bool]]</code> <p>function that takes in node as argument. Return node if condition evaluates to <code>True</code></p> <code>None</code> <code>stop_condition</code> <code>Optional[Callable[[BaseNodeT], bool]]</code> <p>function that takes in node as argument. Stops iteration if condition evaluates to <code>True</code></p> <code>None</code> <code>max_depth</code> <code>int</code> <p>maximum depth of iteration, based on <code>depth</code> attribute</p> <code>0</code> <p>Returns:</p> Type Description <code>Iterable[BaseNodeT]</code> <p>Iterable of nodes</p>"},{"location":"bigtree/utils/iterators/#bigtree.utils.iterators.levelordergroup_iter","title":"levelordergroup_iter","text":"<pre><code>levelordergroup_iter(\n    tree,\n    filter_condition=None,\n    stop_condition=None,\n    max_depth=0,\n)\n</code></pre> <p>Iterate through all children of a tree.</p> Level-Order Group Iteration Algorithm <ol> <li>Recursively traverse the nodes on same level, returns nodes level by level in a nested list</li> </ol> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, list_to_tree, levelordergroup_iter\n&gt;&gt;&gt; path_list = [\"a/b/d\", \"a/b/e/g\", \"a/b/e/h\", \"a/c/f\"]\n&gt;&gt;&gt; root = list_to_tree(path_list)\n&gt;&gt;&gt; root.show()\na\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 d\n\u2502   \u2514\u2500\u2500 e\n\u2502       \u251c\u2500\u2500 g\n\u2502       \u2514\u2500\u2500 h\n\u2514\u2500\u2500 c\n    \u2514\u2500\u2500 f\n</code></pre> <pre><code>&gt;&gt;&gt; [[node.node_name for node in group] for group in levelordergroup_iter(root)]\n[['a'], ['b', 'c'], ['d', 'e', 'f'], ['g', 'h']]\n</code></pre> <pre><code>&gt;&gt;&gt; [[node.node_name for node in group] for group in levelordergroup_iter(root, filter_condition=lambda x: x.node_name in [\"a\", \"d\", \"e\", \"f\", \"g\"])]\n[['a'], [], ['d', 'e', 'f'], ['g']]\n</code></pre> <pre><code>&gt;&gt;&gt; [[node.node_name for node in group] for group in levelordergroup_iter(root, stop_condition=lambda x: x.node_name == \"e\")]\n[['a'], ['b', 'c'], ['d', 'f']]\n</code></pre> <pre><code>&gt;&gt;&gt; [[node.node_name for node in group] for group in levelordergroup_iter(root, max_depth=3)]\n[['a'], ['b', 'c'], ['d', 'e', 'f']]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>BaseNodeT</code> <p>input tree</p> required <code>filter_condition</code> <code>Optional[Callable[[BaseNodeT], bool]]</code> <p>function that takes in node as argument. Return node if condition evaluates to <code>True</code></p> <code>None</code> <code>stop_condition</code> <code>Optional[Callable[[BaseNodeT], bool]]</code> <p>function that takes in node as argument. Stops iteration if condition evaluates to <code>True</code></p> <code>None</code> <code>max_depth</code> <code>int</code> <p>maximum depth of iteration, based on <code>depth</code> attribute</p> <code>0</code> <p>Returns:</p> Type Description <code>Iterable[Iterable[BaseNodeT]]</code> <p>List of iterable of nodes</p>"},{"location":"bigtree/utils/iterators/#bigtree.utils.iterators.zigzag_iter","title":"zigzag_iter","text":"<pre><code>zigzag_iter(\n    tree,\n    filter_condition=None,\n    stop_condition=None,\n    max_depth=0,\n)\n</code></pre> <p>\"Iterate through all children of a tree.</p> ZigZag Iteration Algorithm <ol> <li>Recursively traverse the nodes on same level, in a zigzag manner across different levels</li> </ol> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, list_to_tree, zigzag_iter\n&gt;&gt;&gt; path_list = [\"a/b/d\", \"a/b/e/g\", \"a/b/e/h\", \"a/c/f\"]\n&gt;&gt;&gt; root = list_to_tree(path_list)\n&gt;&gt;&gt; root.show()\na\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 d\n\u2502   \u2514\u2500\u2500 e\n\u2502       \u251c\u2500\u2500 g\n\u2502       \u2514\u2500\u2500 h\n\u2514\u2500\u2500 c\n    \u2514\u2500\u2500 f\n</code></pre> <pre><code>&gt;&gt;&gt; [node.node_name for node in zigzag_iter(root)]\n['a', 'c', 'b', 'd', 'e', 'f', 'h', 'g']\n</code></pre> <pre><code>&gt;&gt;&gt; [node.node_name for node in zigzag_iter(root, filter_condition=lambda x: x.node_name in [\"a\", \"d\", \"e\", \"f\", \"g\"])]\n['a', 'd', 'e', 'f', 'g']\n</code></pre> <pre><code>&gt;&gt;&gt; [node.node_name for node in zigzag_iter(root, stop_condition=lambda x: x.node_name == \"e\")]\n['a', 'c', 'b', 'd', 'f']\n</code></pre> <pre><code>&gt;&gt;&gt; [node.node_name for node in zigzag_iter(root, max_depth=3)]\n['a', 'c', 'b', 'd', 'e', 'f']\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>BaseNodeT</code> <p>input tree</p> required <code>filter_condition</code> <code>Optional[Callable[[BaseNodeT], bool]]</code> <p>function that takes in node as argument. Return node if condition evaluates to <code>True</code></p> <code>None</code> <code>stop_condition</code> <code>Optional[Callable[[BaseNodeT], bool]]</code> <p>function that takes in node as argument. Stops iteration if condition evaluates to <code>True</code></p> <code>None</code> <code>max_depth</code> <code>int</code> <p>maximum depth of iteration, based on <code>depth</code> attribute</p> <code>0</code> <p>Returns:</p> Type Description <code>Iterable[BaseNodeT]</code> <p>Iterable of nodes</p>"},{"location":"bigtree/utils/iterators/#bigtree.utils.iterators.zigzaggroup_iter","title":"zigzaggroup_iter","text":"<pre><code>zigzaggroup_iter(\n    tree,\n    filter_condition=None,\n    stop_condition=None,\n    max_depth=0,\n)\n</code></pre> <p>Iterate through all children of a tree.</p> ZigZag Group Iteration Algorithm <ol> <li>Recursively traverse the nodes on same level, in a zigzag manner across different levels, returns nodes level by level in a nested list</li> </ol> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, list_to_tree, zigzaggroup_iter\n&gt;&gt;&gt; path_list = [\"a/b/d\", \"a/b/e/g\", \"a/b/e/h\", \"a/c/f\"]\n&gt;&gt;&gt; root = list_to_tree(path_list)\n&gt;&gt;&gt; root.show()\na\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 d\n\u2502   \u2514\u2500\u2500 e\n\u2502       \u251c\u2500\u2500 g\n\u2502       \u2514\u2500\u2500 h\n\u2514\u2500\u2500 c\n    \u2514\u2500\u2500 f\n</code></pre> <pre><code>&gt;&gt;&gt; [[node.node_name for node in group] for group in zigzaggroup_iter(root)]\n[['a'], ['c', 'b'], ['d', 'e', 'f'], ['h', 'g']]\n</code></pre> <pre><code>&gt;&gt;&gt; [[node.node_name for node in group] for group in zigzaggroup_iter(root, filter_condition=lambda x: x.node_name in [\"a\", \"d\", \"e\", \"f\", \"g\"])]\n[['a'], [], ['d', 'e', 'f'], ['g']]\n</code></pre> <pre><code>&gt;&gt;&gt; [[node.node_name for node in group] for group in zigzaggroup_iter(root, stop_condition=lambda x: x.node_name == \"e\")]\n[['a'], ['c', 'b'], ['d', 'f']]\n</code></pre> <pre><code>&gt;&gt;&gt; [[node.node_name for node in group] for group in zigzaggroup_iter(root, max_depth=3)]\n[['a'], ['c', 'b'], ['d', 'e', 'f']]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>BaseNodeT</code> <p>input tree</p> required <code>filter_condition</code> <code>Optional[Callable[[BaseNodeT], bool]]</code> <p>function that takes in node as argument. Return node if condition evaluates to <code>True</code></p> <code>None</code> <code>stop_condition</code> <code>Optional[Callable[[BaseNodeT], bool]]</code> <p>function that takes in node as argument. Stops iteration if condition evaluates to <code>True</code></p> <code>None</code> <code>max_depth</code> <code>int</code> <p>maximum depth of iteration, based on <code>depth</code> attribute</p> <code>0</code> <p>Returns:</p> Type Description <code>Iterable[Iterable[BaseNodeT]]</code> <p>List of iterable of nodes</p>"},{"location":"bigtree/utils/iterators/#bigtree.utils.iterators.dag_iterator","title":"dag_iterator","text":"<pre><code>dag_iterator(dag)\n</code></pre> <p>Iterate through all nodes of a Directed Acyclic Graph (DAG). Note that node names must be unique. Note that DAG must at least have two nodes to be shown on graph.</p> DAG Iteration <ol> <li>Visit the current node</li> <li>Recursively traverse the current node's parents</li> <li>Recursively traverse the current node's children</li> </ol> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import DAGNode, dag_iterator\n&gt;&gt;&gt; a = DAGNode(\"a\", step=1)\n&gt;&gt;&gt; b = DAGNode(\"b\", step=1)\n&gt;&gt;&gt; c = DAGNode(\"c\", step=2, parents=[a, b])\n&gt;&gt;&gt; d = DAGNode(\"d\", step=2, parents=[a, c])\n&gt;&gt;&gt; e = DAGNode(\"e\", step=3, parents=[d])\n&gt;&gt;&gt; [(parent.node_name, child.node_name) for parent, child in dag_iterator(a)]\n[('a', 'c'), ('a', 'd'), ('b', 'c'), ('c', 'd'), ('d', 'e')]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>dag</code> <code>DAGNodeT</code> <p>input dag</p> required <p>Returns:</p> Type Description <code>Iterable[Tuple[DAGNodeT, DAGNodeT]]</code> <p>Iterable of parent-child pair</p>"},{"location":"bigtree/utils/plot/","title":"\ud83d\udcca Plot","text":"<p>Plotting methods for Trees.</p>"},{"location":"bigtree/utils/plot/#bigtree.utils.plot","title":"bigtree.utils.plot","text":""},{"location":"bigtree/utils/plot/#bigtree.utils.plot.reingold_tilford","title":"reingold_tilford","text":"<pre><code>reingold_tilford(\n    tree_node,\n    sibling_separation=1.0,\n    subtree_separation=1.0,\n    level_separation=1.0,\n    x_offset=0.0,\n    y_offset=0.0,\n    reverse=False,\n)\n</code></pre> <p>Algorithm for drawing tree structure, retrieves <code>(x, y)</code> coordinates for a tree structure. Adds <code>x</code> and <code>y</code> attributes to every node in the tree. Modifies tree in-place.</p> <p>This algorithm[1] is an improvement over Reingold Tilford algorithm[2].</p> <p>According to Reingold Tilford's paper, a tree diagram should satisfy the following aesthetic rules,</p> <ol> <li>Nodes at the same depth should lie along a straight line, and the straight lines defining the depths should be parallel.</li> <li>A left child should be positioned to the left of its parent node and a right child to the right.</li> <li>A parent should be centered over their children.</li> <li>A tree and its mirror image should produce drawings that are reflections of one another; a subtree should be drawn the same way regardless of where it occurs in the tree.</li> </ol> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import reingold_tilford, list_to_tree\n&gt;&gt;&gt; path_list = [\"a/b/d\", \"a/b/e/g\", \"a/b/e/h\", \"a/c/f\"]\n&gt;&gt;&gt; root = list_to_tree(path_list)\n&gt;&gt;&gt; root.show()\na\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 d\n\u2502   \u2514\u2500\u2500 e\n\u2502       \u251c\u2500\u2500 g\n\u2502       \u2514\u2500\u2500 h\n\u2514\u2500\u2500 c\n    \u2514\u2500\u2500 f\n</code></pre> <pre><code>&gt;&gt;&gt; reingold_tilford(root)\n&gt;&gt;&gt; root.show(attr_list=[\"x\", \"y\"])\na [x=1.25, y=3.0]\n\u251c\u2500\u2500 b [x=0.5, y=2.0]\n\u2502   \u251c\u2500\u2500 d [x=0.0, y=1.0]\n\u2502   \u2514\u2500\u2500 e [x=1.0, y=1.0]\n\u2502       \u251c\u2500\u2500 g [x=0.5, y=0.0]\n\u2502       \u2514\u2500\u2500 h [x=1.5, y=0.0]\n\u2514\u2500\u2500 c [x=2.0, y=2.0]\n    \u2514\u2500\u2500 f [x=2.0, y=1.0]\n</code></pre> <p>References</p> <ul> <li>[1] Walker, J. (1991). Positioning Nodes for General Trees. https://www.drdobbs.com/positioning-nodes-for-general-trees/184402320?pgno=4</li> <li>[2] Reingold, E., Tilford, J. (1981). Tidier Drawings of Trees. IEEE Transactions on Software Engineering. https://reingold.co/tidier-drawings.pdf</li> </ul> <p>Parameters:</p> Name Type Description Default <code>tree_node</code> <code>T</code> <p>tree to compute (x, y) coordinate</p> required <code>sibling_separation</code> <code>float</code> <p>minimum distance between adjacent siblings of the tree</p> <code>1.0</code> <code>subtree_separation</code> <code>float</code> <p>minimum distance between adjacent subtrees of the tree</p> <code>1.0</code> <code>level_separation</code> <code>float</code> <p>fixed distance between adjacent levels of the tree</p> <code>1.0</code> <code>x_offset</code> <code>float</code> <p>graph offset of x-coordinates</p> <code>0.0</code> <code>y_offset</code> <code>float</code> <p>graph offset of y-coordinates</p> <code>0.0</code> <code>reverse</code> <code>bool</code> <p>graph begins bottom to top by default, set to True for top to bottom y coordinates</p> <code>False</code>"},{"location":"bigtree/utils/plot/#bigtree.utils.plot.plot_tree","title":"plot_tree","text":"<pre><code>plot_tree(tree_node, *args, ax=None, **kwargs)\n</code></pre> <p>Plot tree in line form. Tree should have <code>x</code> and <code>y</code> attribute from Reingold Tilford. Accepts existing matplotlib Axes. Accepts args and kwargs for matplotlib.pyplot.plot() function.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; from bigtree import list_to_tree, plot_tree, reingold_tilford\n&gt;&gt;&gt; path_list = [\"a/b/d\", \"a/b/e/g\", \"a/b/e/h\", \"a/c/f\"]\n&gt;&gt;&gt; root = list_to_tree(path_list)\n&gt;&gt;&gt; reingold_tilford(root)\n&gt;&gt;&gt; plot_tree(root, \"-ok\")\n&lt;Figure size 1280x960 with 1 Axes&gt;\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree_node</code> <code>T</code> <p>tree to plot</p> required <code>ax</code> <code>Optional[Axes]</code> <p>axes to add Figure to</p> <code>None</code>"},{"location":"bigtree/workflows/app_calendar/","title":"\ud83d\udcc6 Calendar App","text":""},{"location":"bigtree/workflows/app_calendar/#bigtree.workflows.app_calendar","title":"bigtree.workflows.app_calendar","text":""},{"location":"bigtree/workflows/app_calendar/#bigtree.workflows.app_calendar.Calendar","title":"Calendar","text":"<pre><code>Calendar(name)\n</code></pre> <p>Calendar Implementation with Big Tree.   - Calendar has four levels - year, month, day, and event name (with event attributes)</p> <p>Examples:</p>"},{"location":"bigtree/workflows/app_calendar/#bigtree.workflows.app_calendar.Calendar--initializing-and-adding-events","title":"Initializing and Adding Events","text":"<pre><code>&gt;&gt;&gt; from bigtree import Calendar\n&gt;&gt;&gt; calendar = Calendar(\"My Calendar\")\n&gt;&gt;&gt; calendar.add_event(\"Gym\", \"2023-01-01 18:00\")\n&gt;&gt;&gt; calendar.add_event(\"Dinner\", \"2023-01-01\", date_format=\"%Y-%m-%d\", budget=20)\n&gt;&gt;&gt; calendar.add_event(\"Gym\", \"2023-01-02 18:00\")\n&gt;&gt;&gt; calendar.show()\nMy Calendar\n2023-01-01 00:00:00 - Dinner (budget: 20)\n2023-01-01 18:00:00 - Gym\n2023-01-02 18:00:00 - Gym\n</code></pre>"},{"location":"bigtree/workflows/app_calendar/#bigtree.workflows.app_calendar.Calendar--search-for-events","title":"Search for Events","text":"<pre><code>&gt;&gt;&gt; calendar.find_event(\"Gym\")\n2023-01-01 18:00:00 - Gym\n2023-01-02 18:00:00 - Gym\n</code></pre>"},{"location":"bigtree/workflows/app_calendar/#bigtree.workflows.app_calendar.Calendar--removing-events","title":"Removing Events","text":"<pre><code>&gt;&gt;&gt; import datetime as dt\n&gt;&gt;&gt; calendar.delete_event(\"Gym\", dt.date(2023, 1, 1))\n&gt;&gt;&gt; calendar.show()\nMy Calendar\n2023-01-01 00:00:00 - Dinner (budget: 20)\n2023-01-02 18:00:00 - Gym\n</code></pre>"},{"location":"bigtree/workflows/app_calendar/#bigtree.workflows.app_calendar.Calendar--export-calendar","title":"Export Calendar","text":"<pre><code>&gt;&gt;&gt; calendar.to_dataframe()\n                             path    name        date      time  budget\n0  /My Calendar/2023/01/01/Dinner  Dinner  2023-01-01  00:00:00    20.0\n1     /My Calendar/2023/01/02/Gym     Gym  2023-01-02  18:00:00     NaN\n</code></pre>"},{"location":"bigtree/workflows/app_calendar/#bigtree.workflows.app_calendar.Calendar.add_event","title":"add_event","text":"<pre><code>add_event(\n    event_name,\n    event_datetime,\n    date_format=\"%Y-%m-%d %H:%M\",\n    **kwargs\n)\n</code></pre> <p>Add event to calendar.</p> <p>Parameters:</p> Name Type Description Default <code>event_name</code> <code>str</code> <p>event name to be added</p> required <code>event_datetime</code> <code>Union[str, datetime]</code> <p>event date and time</p> required <code>date_format</code> <code>str</code> <p>specify datetime format if event_datetime is str</p> <code>'%Y-%m-%d %H:%M'</code>"},{"location":"bigtree/workflows/app_calendar/#bigtree.workflows.app_calendar.Calendar.delete_event","title":"delete_event","text":"<pre><code>delete_event(event_name, event_date=None)\n</code></pre> <p>Delete event from calendar.</p> <p>Parameters:</p> Name Type Description Default <code>event_name</code> <code>str</code> <p>event name to be deleted</p> required <code>event_date</code> <code>Optional[date]</code> <p>event date to be deleted</p> <code>None</code>"},{"location":"bigtree/workflows/app_calendar/#bigtree.workflows.app_calendar.Calendar.find_event","title":"find_event","text":"<pre><code>find_event(event_name)\n</code></pre> <p>Find event by name, prints result to console.</p> <p>Parameters:</p> Name Type Description Default <code>event_name</code> <code>str</code> <p>event name</p> required"},{"location":"bigtree/workflows/app_calendar/#bigtree.workflows.app_calendar.Calendar.show","title":"show","text":"<pre><code>show()\n</code></pre> <p>Show calendar, prints result to console.</p>"},{"location":"bigtree/workflows/app_calendar/#bigtree.workflows.app_calendar.Calendar.to_dataframe","title":"to_dataframe","text":"<pre><code>to_dataframe()\n</code></pre> <p>Export calendar to DataFrame.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pandas DataFrame of calendar</p>"},{"location":"bigtree/workflows/app_todo/","title":"\u2714\ufe0f To Do App","text":""},{"location":"bigtree/workflows/app_todo/#bigtree.workflows.app_todo","title":"bigtree.workflows.app_todo","text":""},{"location":"bigtree/workflows/app_todo/#bigtree.workflows.app_todo.AppToDo","title":"AppToDo","text":"<pre><code>AppToDo(app_name='')\n</code></pre> <p>To-Do List Implementation with Big Tree.   - To-Do List has three levels - app name, list name, and item name.   - If list name is not given, item will be assigned to a <code>General</code> list.</p> <p>Examples:</p>"},{"location":"bigtree/workflows/app_todo/#bigtree.workflows.app_todo.AppToDo--initializing-and-adding-items","title":"Initializing and Adding Items","text":"<pre><code>&gt;&gt;&gt; from bigtree import AppToDo\n&gt;&gt;&gt; app = AppToDo(\"To Do App\")\n&gt;&gt;&gt; app.add_item(item_name=\"Homework 1\", list_name=\"School\")\n&gt;&gt;&gt; app.add_item(item_name=[\"Milk\", \"Bread\"], list_name=\"Groceries\", description=\"Urgent\")\n&gt;&gt;&gt; app.add_item(item_name=\"Cook\")\n&gt;&gt;&gt; app.show()\nTo Do App\n\u251c\u2500\u2500 School\n\u2502   \u2514\u2500\u2500 Homework 1\n\u251c\u2500\u2500 Groceries\n\u2502   \u251c\u2500\u2500 Milk [description=Urgent]\n\u2502   \u2514\u2500\u2500 Bread [description=Urgent]\n\u2514\u2500\u2500 General\n    \u2514\u2500\u2500 Cook\n</code></pre>"},{"location":"bigtree/workflows/app_todo/#bigtree.workflows.app_todo.AppToDo--reorder-list-and-item","title":"Reorder List and Item","text":"<pre><code>&gt;&gt;&gt; app.prioritize_list(list_name=\"General\")\n&gt;&gt;&gt; app.show()\nTo Do App\n\u251c\u2500\u2500 General\n\u2502   \u2514\u2500\u2500 Cook\n\u251c\u2500\u2500 School\n\u2502   \u2514\u2500\u2500 Homework 1\n\u2514\u2500\u2500 Groceries\n    \u251c\u2500\u2500 Milk [description=Urgent]\n    \u2514\u2500\u2500 Bread [description=Urgent]\n</code></pre> <pre><code>&gt;&gt;&gt; app.prioritize_item(item_name=\"Bread\")\n&gt;&gt;&gt; app.show()\nTo Do App\n\u251c\u2500\u2500 General\n\u2502   \u2514\u2500\u2500 Cook\n\u251c\u2500\u2500 School\n\u2502   \u2514\u2500\u2500 Homework 1\n\u2514\u2500\u2500 Groceries\n    \u251c\u2500\u2500 Bread [description=Urgent]\n    \u2514\u2500\u2500 Milk [description=Urgent]\n</code></pre>"},{"location":"bigtree/workflows/app_todo/#bigtree.workflows.app_todo.AppToDo--removing-items","title":"Removing Items","text":"<pre><code>&gt;&gt;&gt; app.remove_item(\"Homework 1\")\n&gt;&gt;&gt; app.show()\nTo Do App\n\u251c\u2500\u2500 General\n\u2502   \u2514\u2500\u2500 Cook\n\u2514\u2500\u2500 Groceries\n    \u251c\u2500\u2500 Bread [description=Urgent]\n    \u2514\u2500\u2500 Milk [description=Urgent]\n</code></pre>"},{"location":"bigtree/workflows/app_todo/#bigtree.workflows.app_todo.AppToDo--exporting-and-importing-list","title":"Exporting and Importing List","text":"<pre><code>&gt;&gt;&gt; app.save(\"assets/docstr/list.json\")\n&gt;&gt;&gt; app2 = AppToDo.load(\"assets/docstr/list.json\")\n&gt;&gt;&gt; app2.show()\nTo Do App\n\u251c\u2500\u2500 General\n\u2502   \u2514\u2500\u2500 Cook\n\u2514\u2500\u2500 Groceries\n    \u251c\u2500\u2500 Bread [description=Urgent]\n    \u2514\u2500\u2500 Milk [description=Urgent]\n</code></pre> <p>Initialize To-Do app.</p> <p>Parameters:</p> Name Type Description Default <code>app_name</code> <code>str</code> <p>name of to-do app, optional</p> <code>''</code>"},{"location":"bigtree/workflows/app_todo/#bigtree.workflows.app_todo.AppToDo.add_list","title":"add_list","text":"<pre><code>add_list(list_name, **kwargs)\n</code></pre> <p>Add list to app.</p> <p>If list is present, return list node, else a new list will be created</p> <p>Parameters:</p> Name Type Description Default <code>list_name</code> <code>str</code> <p>name of list</p> required <p>Returns:</p> Type Description <code>Node</code> <p>List node</p>"},{"location":"bigtree/workflows/app_todo/#bigtree.workflows.app_todo.AppToDo.prioritize_list","title":"prioritize_list","text":"<pre><code>prioritize_list(list_name)\n</code></pre> <p>Prioritize list in app, shift it to be the first list.</p> <p>Parameters:</p> Name Type Description Default <code>list_name</code> <code>str</code> <p>name of list</p> required"},{"location":"bigtree/workflows/app_todo/#bigtree.workflows.app_todo.AppToDo.add_item","title":"add_item","text":"<pre><code>add_item(item_name, list_name='', **kwargs)\n</code></pre> <p>Add items to list.</p> <p>Parameters:</p> Name Type Description Default <code>item_name</code> <code>Union[str, List[str]]</code> <p>items to be added</p> required <code>list_name</code> <code>str</code> <p>list to add items to, optional</p> <code>''</code>"},{"location":"bigtree/workflows/app_todo/#bigtree.workflows.app_todo.AppToDo.remove_item","title":"remove_item","text":"<pre><code>remove_item(item_name, list_name='')\n</code></pre> <p>Remove items from list.</p> <p>Parameters:</p> Name Type Description Default <code>item_name</code> <code>Union[str, List[str]]</code> <p>items to be added</p> required <code>list_name</code> <code>str</code> <p>list to add items to, optional</p> <code>''</code>"},{"location":"bigtree/workflows/app_todo/#bigtree.workflows.app_todo.AppToDo.prioritize_item","title":"prioritize_item","text":"<pre><code>prioritize_item(item_name)\n</code></pre> <p>Prioritize item in list, shift it to be the first item in list.</p> <p>Parameters:</p> Name Type Description Default <code>item_name</code> <code>str</code> <p>name of item</p> required"},{"location":"bigtree/workflows/app_todo/#bigtree.workflows.app_todo.AppToDo.show","title":"show","text":"<pre><code>show(**kwargs)\n</code></pre> <p>Print tree to console.</p>"},{"location":"bigtree/workflows/app_todo/#bigtree.workflows.app_todo.AppToDo.load","title":"load  <code>staticmethod</code>","text":"<pre><code>load(json_path)\n</code></pre> <p>Load To-Do app from json.</p> <p>Parameters:</p> Name Type Description Default <code>json_path</code> <code>str</code> <p>json load path</p> required <p>Returns:</p> Type Description <code>AppToDo</code> <p>AppToDo loaded from path</p>"},{"location":"bigtree/workflows/app_todo/#bigtree.workflows.app_todo.AppToDo.save","title":"save","text":"<pre><code>save(json_path)\n</code></pre> <p>Save To-Do app as json.</p> <p>Parameters:</p> Name Type Description Default <code>json_path</code> <code>str</code> <p>json save path</p> required"},{"location":"gettingstarted/demo/Workflow%20Demonstration/","title":"Workflow Demonstration","text":"In\u00a0[1]: Copied! <pre>from bigtree import AppToDo\n\napp = AppToDo(\"To Do App\")\napp.add_item(item_name=\"Homework 1\", list_name=\"School\")\napp.add_item(\n    item_name=[\"Milk\", \"Bread\"],\n    list_name=\"Groceries\",\n    description=\"Urgent\",\n)\napp.add_item(item_name=\"Cook\")\napp.show()\n</pre> from bigtree import AppToDo  app = AppToDo(\"To Do App\") app.add_item(item_name=\"Homework 1\", list_name=\"School\") app.add_item(     item_name=[\"Milk\", \"Bread\"],     list_name=\"Groceries\",     description=\"Urgent\", ) app.add_item(item_name=\"Cook\") app.show() <pre>To Do App\n\u251c\u2500\u2500 School\n\u2502   \u2514\u2500\u2500 Homework 1\n\u251c\u2500\u2500 Groceries\n\u2502   \u251c\u2500\u2500 Milk [description=Urgent]\n\u2502   \u2514\u2500\u2500 Bread [description=Urgent]\n\u2514\u2500\u2500 General\n    \u2514\u2500\u2500 Cook\n</pre> In\u00a0[2]: Copied! <pre>app.save(\"list.json\")\napp2 = AppToDo.load(\"list.json\")\n</pre> app.save(\"list.json\") app2 = AppToDo.load(\"list.json\") In\u00a0[3]: Copied! <pre>import datetime as dt\nfrom bigtree import Calendar\n\ncalendar = Calendar(\"My Calendar\")\ncalendar.add_event(\"Gym\", \"2023-01-01 18:00\")\ncalendar.add_event(\n    \"Dinner\",\n    \"2023-01-01\",\n    date_format=\"%Y-%m-%d\",\n    budget=20,\n)\ncalendar.add_event(\"Gym\", \"2023-01-02 18:00\")\ncalendar.show()\n</pre> import datetime as dt from bigtree import Calendar  calendar = Calendar(\"My Calendar\") calendar.add_event(\"Gym\", \"2023-01-01 18:00\") calendar.add_event(     \"Dinner\",     \"2023-01-01\",     date_format=\"%Y-%m-%d\",     budget=20, ) calendar.add_event(\"Gym\", \"2023-01-02 18:00\") calendar.show() <pre>My Calendar\n2023-01-01 00:00:00 - Dinner (budget: 20)\n2023-01-01 18:00:00 - Gym\n2023-01-02 18:00:00 - Gym\n</pre> In\u00a0[4]: Copied! <pre>calendar.find_event(\"Gym\")\n</pre> calendar.find_event(\"Gym\") <pre>2023-01-01 18:00:00 - Gym\n2023-01-02 18:00:00 - Gym\n</pre> In\u00a0[5]: Copied! <pre>calendar.delete_event(\"Gym\", dt.date(2023, 1, 1))\ncalendar.show()\n</pre> calendar.delete_event(\"Gym\", dt.date(2023, 1, 1)) calendar.show() <pre>My Calendar\n2023-01-01 00:00:00 - Dinner (budget: 20)\n2023-01-02 18:00:00 - Gym\n</pre> In\u00a0[6]: Copied! <pre>data_calendar = calendar.to_dataframe()\ndata_calendar\n</pre> data_calendar = calendar.to_dataframe() data_calendar Out[6]: path name date time budget 0 /My Calendar/2023/01/01/Dinner Dinner 2023-01-01 00:00:00 20.0 1 /My Calendar/2023/01/02/Gym Gym 2023-01-02 18:00:00 NaN"},{"location":"gettingstarted/demo/Workflow%20Demonstration/#workflow-demonstration","title":"\ud83d\udccb Workflow Demonstration\u00b6","text":"<p>There are existing implementations of workflows to showcase how <code>bigtree</code> can be used!</p>"},{"location":"gettingstarted/demo/Workflow%20Demonstration/#to-do-application","title":"To Do Application\u00b6","text":"<p>There are functions to:</p> <ul> <li>Add or remove list to To-Do application</li> <li>Add or remove item to list, default list is the 'General' list</li> <li>Prioritize a list/item by reordering them as first list/item</li> <li>Save and import To-Do application to and from an external JSON file</li> <li>Show To-Do application, which prints tree to console</li> </ul>"},{"location":"gettingstarted/demo/Workflow%20Demonstration/#calendar-application","title":"Calendar Application\u00b6","text":"<p>There are functions to:</p> <ul> <li>Add or remove event from Calendar</li> <li>Find event by name, or name and date</li> <li>Display calendar, which prints events to console</li> <li>Export calendar to pandas DataFrame</li> </ul>"},{"location":"gettingstarted/demo/binarytree/","title":"\ud83d\udccb Binary Tree Demonstration","text":"<p>Compared to nodes in tree, nodes in Binary Tree are only allowed maximum of 2 children. Since BinaryNode extends from Node, construct, traverse, search, export methods from Node are applicable to Binary Tree as well.</p>"},{"location":"gettingstarted/demo/binarytree/#construct-binary-tree","title":"Construct Binary Tree","text":""},{"location":"gettingstarted/demo/binarytree/#1-from-binarynode","title":"1. From BinaryNode","text":"<p>BinaryNode can be linked to each other with <code>parent</code>, <code>children</code>, <code>left</code>, and <code>right</code> setter methods, or using bitshift operator with the convention <code>parent_node &gt;&gt; child_node</code> or <code>child_node &lt;&lt; parent_node</code>.</p> <pre><code>from bigtree import BinaryNode, tree_to_dot\n\ne = BinaryNode(5)\nd = BinaryNode(4)\nc = BinaryNode(3)\nb = BinaryNode(2, left=d, right=e)\na = BinaryNode(1, children=[b, c])\nf = BinaryNode(6, parent=c)\ng = BinaryNode(7, parent=c)\nh = BinaryNode(8, parent=d)\n\ngraph = tree_to_dot(a, node_colour=\"gold\")\ngraph.write_png(\"assets/demo/binarytree.png\")\n</code></pre> <p></p>"},{"location":"gettingstarted/demo/binarytree/#2-from-list","title":"2. From list","text":"<p>Construct nodes only, list has similar format as <code>heapq</code> list.</p> <pre><code>from bigtree import list_to_binarytree\n\nnums_list = [1, 2, 3, 4, 5, 6, 7, 8]\nroot = list_to_binarytree(nums_list)\nroot.show()\n# 1\n# \u251c\u2500\u2500 2\n# \u2502   \u251c\u2500\u2500 4\n# \u2502   \u2502   \u2514\u2500\u2500 8\n# \u2502   \u2514\u2500\u2500 5\n# \u2514\u2500\u2500 3\n#     \u251c\u2500\u2500 6\n#     \u2514\u2500\u2500 7\n</code></pre>"},{"location":"gettingstarted/demo/binarytree/#traverse-binary-tree","title":"Traverse Binary Tree","text":"<p>In addition to the traversal methods in the usual tree, binary tree includes in-order traversal method.</p> <pre><code>from bigtree import (\n    inorder_iter,\n    levelorder_iter,\n    levelordergroup_iter,\n    list_to_binarytree,\n    postorder_iter,\n    preorder_iter,\n    zigzag_iter,\n    zigzaggroup_iter,\n)\n\nnums_list = [1, 2, 3, 4, 5, 6, 7, 8]\nroot = list_to_binarytree(nums_list)\nroot.show()\n# 1\n# \u251c\u2500\u2500 2\n# \u2502   \u251c\u2500\u2500 4\n# \u2502   \u2502   \u2514\u2500\u2500 8\n# \u2502   \u2514\u2500\u2500 5\n# \u2514\u2500\u2500 3\n#     \u251c\u2500\u2500 6\n#     \u2514\u2500\u2500 7\n\n[node.node_name for node in inorder_iter(root)]\n# ['8', '4', '2', '5', '1', '6', '3', '7']\n\n[node.node_name for node in preorder_iter(root)]\n# ['1', '2', '4', '8', '5', '3', '6', '7']\n\n[node.node_name for node in postorder_iter(root)]\n# ['8', '4', '5', '2', '6', '7', '3', '1']\n\n[node.node_name for node in levelorder_iter(root)]\n# ['1', '2', '3', '4', '5', '6', '7', '8']\n\n[[node.node_name for node in node_group] for node_group in levelordergroup_iter(root)]\n# [['1'], ['2', '3'], ['4', '5', '6', '7'], ['8']]\n\n[node.node_name for node in zigzag_iter(root)]\n# ['1', '3', '2', '4', '5', '6', '7', '8']\n\n[[node.node_name for node in node_group] for node_group in zigzaggroup_iter(root)]\n# [['1'], ['3', '2'], ['4', '5', '6', '7'], ['8']]\n</code></pre>"},{"location":"gettingstarted/demo/dag/","title":"\ud83d\udccb DAG Demonstration","text":"<p>Compared to nodes in tree, nodes in DAG are able to have multiple parents.</p>"},{"location":"gettingstarted/demo/dag/#construct-dag","title":"Construct DAG","text":""},{"location":"gettingstarted/demo/dag/#1-from-dagnode","title":"1. From DAGNode","text":"<p>DAGNodes can be linked to each other in the following ways:</p> <ul> <li>Using <code>parents</code> and <code>children</code> setter methods</li> <li>Directly passing <code>parents</code> or <code>children</code> argument</li> <li>Using bitshift operator with the convention <code>parent_node &gt;&gt; child_node</code> or <code>child_node &lt;&lt; parent_node</code></li> </ul> <pre><code>from bigtree import DAGNode, dag_to_dot\n\na = DAGNode(\"a\")\nb = DAGNode(\"b\")\nc = DAGNode(\"c\", parents=[a, b])\nd = DAGNode(\"d\", parents=[a, c])\ne = DAGNode(\"e\", parents=[d])\nf = DAGNode(\"f\", parents=[c, d])\nh = DAGNode(\"h\")\ng = DAGNode(\"g\", parents=[c], children=[h])\n\ngraph = dag_to_dot(a, node_colour=\"gold\")\ngraph.write_png(\"assets/demo/dag.png\")\n</code></pre> <p></p>"},{"location":"gettingstarted/demo/dag/#2-from-list","title":"2. From list","text":"<p>Construct nodes only, list contains parent-child tuples.</p> <pre><code>from bigtree import list_to_dag, dag_iterator\n\nrelations_list = [(\"a\", \"c\"), (\"a\", \"d\"), (\"b\", \"c\"), (\"c\", \"d\"), (\"d\", \"e\")]\ndag = list_to_dag(relations_list)\n\nprint([(parent.node_name, child.node_name) for parent, child in dag_iterator(dag)])\n# [('a', 'd'), ('c', 'd'), ('d', 'e'), ('a', 'c'), ('b', 'c')]\n</code></pre>"},{"location":"gettingstarted/demo/dag/#3-from-nested-dictionary","title":"3. From nested dictionary","text":"<p>Construct nodes with attributes, <code>key</code>: child name, <code>value</code>: dict of parent name, child node attributes.</p> <pre><code>from bigtree import dict_to_dag, dag_iterator\n\nrelation_dict = {\n    \"a\": {\"step\": 1},\n    \"b\": {\"step\": 1},\n    \"c\": {\"parents\": [\"a\", \"b\"], \"step\": 2},\n    \"d\": {\"parents\": [\"a\", \"c\"], \"step\": 2},\n    \"e\": {\"parents\": [\"d\"], \"step\": 3},\n}\ndag = dict_to_dag(relation_dict, parent_key=\"parents\")\n\nprint([(parent.node_name, child.node_name) for parent, child in dag_iterator(dag)])\n# [('a', 'd'), ('c', 'd'), ('d', 'e'), ('a', 'c'), ('b', 'c')]\n</code></pre>"},{"location":"gettingstarted/demo/dag/#4-from-pandas-dataframe","title":"4. From pandas DataFrame","text":"<p>Construct nodes with attributes, pandas DataFrame contains child column, parent column, and attribute columns.</p> <pre><code>import pandas as pd\nfrom bigtree import dataframe_to_dag, dag_iterator\n\npath_data = pd.DataFrame(\n    [\n        [\"a\", None, 1],\n        [\"b\", None, 1],\n        [\"c\", \"a\", 2],\n        [\"c\", \"b\", 2],\n        [\"d\", \"a\", 2],\n        [\"d\", \"c\", 2],\n        [\"e\", \"d\", 3],\n    ],\n    columns=[\"child\", \"parent\", \"step\"],\n)\ndag = dataframe_to_dag(path_data)\n\nprint([(parent.node_name, child.node_name) for parent, child in dag_iterator(dag)])\n# [('a', 'd'), ('c', 'd'), ('d', 'e'), ('a', 'c'), ('b', 'c')]\n</code></pre>"},{"location":"gettingstarted/demo/dag/#dag-attributes-and-operations","title":"DAG Attributes and Operations","text":"<p>Note that using <code>DAGNode</code> as superclass inherits the default class attributes (properties) and operations (methods).</p> <pre><code>from bigtree import list_to_dag\n\nrelations_list = [(\"a\", \"c\"), (\"a\", \"d\"), (\"b\", \"c\"), (\"c\", \"d\"), (\"d\", \"e\")]\ndag = list_to_dag(relations_list)\ndag\n# DAGNode(d, )\n\n# Accessing children\nnode_e = dag[\"e\"]\nnode_a = dag.parents[0]\n</code></pre> <p>Below are the tables of attributes available to <code>DAGNode</code> class.</p> Attributes wrt self Code Returns Check if root <code>node_a.is_root</code> True Check if leaf node <code>dag.is_leaf</code> False Get node name (only for <code>Node</code>) <code>dag.node_name</code> 'd' Attributes wrt structure Code Returns Get child/children <code>node_a.children</code> (DAGNode(c, ), DAGNode(d, )) Get parents <code>dag.parents</code> (DAGNode(a, ), DAGNode(c, )) Get siblings <code>dag.siblings</code> (DAGNode(c, ),) Get ancestors <code>dag.ancestors</code> [DAGNode(a, ), DAGNode(b, ), DAGNode(c, )] Get descendants <code>dag.descendants</code> [DAGNode(e, )] <p>Below is the table of operations available to <code>DAGNode</code> class.</p> Operations Code Returns Get node information <code>dag.describe(exclude_prefix=\"_\")</code> [('name', 'd')] Find path(s) from one node to another <code>node_a.go_to(dag)</code> [[DAGNode(a, ), DAGNode(c, ), DAGNode(d, description=dag-tag)], [DAGNode(a, ), DAGNode(d, description=dag-tag)]] Set attribute(s) <code>dag.set_attrs({\"description\": \"dag-tag\"})</code> None Get attribute <code>dag.get_attr(\"description\")</code> 'dag-tag' Copy DAG <code>dag.copy()</code> None"},{"location":"gettingstarted/demo/tree/","title":"\ud83d\udccb Tree Demonstration","text":"<p>Here are some codes to get started.</p>"},{"location":"gettingstarted/demo/tree/#construct-tree","title":"Construct Tree","text":"<p>Nodes can have attributes if they are initialized from <code>Node</code>, dictionary, pandas DataFrame, or polars DataFrame.</p>"},{"location":"gettingstarted/demo/tree/#1-from-node","title":"1. From Node","text":"<p>Nodes can be linked to each other in the following ways:</p> <ul> <li>Using <code>parent</code> and <code>children</code> setter methods</li> <li>Directly passing <code>parent</code> or <code>children</code> argument</li> <li>Using bitshift operator with the convention <code>parent &gt;&gt; child</code> or <code>child &lt;&lt; parent</code></li> <li>Using <code>.append(child)</code> or <code>.extend([child1, child2])</code> methods</li> </ul> <code>parent</code> and <code>children</code> setter methods<code>parent</code> or <code>children</code> argumentBitshift operator<code>append</code> and <code>extend</code> <pre><code>from bigtree import Node, tree_to_dot\n\nroot = Node(\"a\")\nb = Node(\"b\")\nc = Node(\"c\")\nd = Node(\"d\")\n\nroot.children = [b, c]\nd.parent = b\n\nroot.show()\n# a\n# \u251c\u2500\u2500 b\n# \u2502   \u2514\u2500\u2500 d\n# \u2514\u2500\u2500 c\n\nroot.hshow()\n#      \u250c\u2500 b \u2500\u2500\u2500 d\n# \u2500 a \u2500\u2524\n#      \u2514\u2500 c\n\nroot.vshow()\n#    \u250c\u2500\u2500\u2500\u2510\n#    \u2502 a \u2502\n#    \u2514\u2500\u252c\u2500\u2518\n#   \u250c\u2500\u2500\u2534\u2500\u2500\u2500\u2510\n# \u250c\u2500\u2534\u2500\u2510  \u250c\u2500\u2534\u2500\u2510\n# \u2502 b \u2502  \u2502 c \u2502\n# \u2514\u2500\u252c\u2500\u2518  \u2514\u2500\u2500\u2500\u2518\n#   \u2502\n# \u250c\u2500\u2534\u2500\u2510\n# \u2502 d \u2502\n# \u2514\u2500\u2500\u2500\u2518\n\ngraph = tree_to_dot(root, node_colour=\"gold\")\ngraph.write_png(\"assets/demo/tree.png\")\n</code></pre> <pre><code>from bigtree import Node\n\nb = Node(\"b\")\nc = Node(\"c\")\nd = Node(\"d\", parent=b)\nroot = Node(\"a\", children=[b, c])\n</code></pre> <pre><code>from bigtree import Node\n\nroot = Node(\"a\")\nb = Node(\"b\")\nc = Node(\"c\")\nd = Node(\"d\")\n\nroot &gt;&gt; b\nroot &gt;&gt; c\nd &lt;&lt; b\n</code></pre> <pre><code>from bigtree import Node\n\nroot = Node(\"a\")\nb = Node(\"b\")\nc = Node(\"c\")\nd = Node(\"d\")\n\nroot.extend([b, c])\nb.append(d)\n</code></pre> <p></p>"},{"location":"gettingstarted/demo/tree/#2-from-str","title":"2. From str","text":"<p>Construct nodes only. Newick string notation supports parsing attributes.</p> Tree stringNewick string <pre><code>from bigtree import str_to_tree\n\ntree_str = \"\"\"\na\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 d\n\u2502   \u2514\u2500\u2500 e\n\u2502       \u251c\u2500\u2500 g\n\u2502       \u2514\u2500\u2500 h\n\u2514\u2500\u2500 c\n    \u2514\u2500\u2500 f\n\"\"\"\nroot = str_to_tree(tree_str)\n\nroot.show()\n# a\n# \u251c\u2500\u2500 b\n# \u2502   \u251c\u2500\u2500 d\n# \u2502   \u2514\u2500\u2500 e\n# \u2502       \u251c\u2500\u2500 g\n# \u2502       \u2514\u2500\u2500 h\n# \u2514\u2500\u2500 c\n#     \u2514\u2500\u2500 f\n</code></pre> <pre><code>from bigtree import newick_to_tree\n\nnewick_str = \"((d,(g,h)e)b,(f)c)a\"\nroot = newick_to_tree(newick_str)\n\nroot.show()\n# a\n# \u251c\u2500\u2500 b\n# \u2502   \u251c\u2500\u2500 d\n# \u2502   \u2514\u2500\u2500 e\n# \u2502       \u251c\u2500\u2500 g\n# \u2502       \u2514\u2500\u2500 h\n# \u2514\u2500\u2500 c\n#     \u2514\u2500\u2500 f\n</code></pre>"},{"location":"gettingstarted/demo/tree/#3-from-list","title":"3. From list","text":"<p>Construct nodes only. List can contain either full paths or tuples of parent-child names.</p> Full pathsParent-child names <pre><code>from bigtree import list_to_tree\n\nroot = list_to_tree([\"a/b/d\", \"a/c\"])\n\nroot.show()\n# a\n# \u251c\u2500\u2500 b\n# \u2502   \u2514\u2500\u2500 d\n# \u2514\u2500\u2500 c\n</code></pre> <pre><code>from bigtree import list_to_tree_by_relation\n\nroot = list_to_tree_by_relation([(\"a\", \"b\"), (\"a\", \"c\"), (\"b\", \"d\")])\n\nroot.show()\n# a\n# \u251c\u2500\u2500 b\n# \u2502   \u2514\u2500\u2500 d\n# \u2514\u2500\u2500 c\n</code></pre>"},{"location":"gettingstarted/demo/tree/#4-from-nested-dictionary","title":"4. From nested dictionary","text":"<p>Construct nodes with attributes. Dictionary can be in a flat structure where <code>key</code> is path and <code>value</code> is dictionary of node attribute names and values, or in a recursive structure where <code>key</code> is node attribute names and <code>value</code> is node attribute values, and list of children (recursive).</p> Flat structureRecursive structure <pre><code>from bigtree import dict_to_tree\n\npath_dict = {\n   \"a\": {\"age\": 90},\n   \"a/b\": {\"age\": 65},\n   \"a/c\": {\"age\": 60},\n   \"a/b/d\": {\"age\": 40},\n}\nroot = dict_to_tree(path_dict)\n\nroot.show(attr_list=[\"age\"])\n# a [age=90]\n# \u251c\u2500\u2500 b [age=65]\n# \u2502   \u2514\u2500\u2500 d [age=40]\n# \u2514\u2500\u2500 c [age=60]\n</code></pre> <pre><code>from bigtree import nested_dict_to_tree\n\npath_dict = {\n   \"name\": \"a\",\n   \"age\": 90,\n   \"children\": [\n      {\n         \"name\": \"b\",\n         \"age\": 65,\n         \"children\": [\n            {\"name\": \"d\", \"age\": 40},\n         ],\n      },\n      {\"name\": \"c\", \"age\": 60},\n   ],\n}\nroot = nested_dict_to_tree(path_dict)\n\nroot.show(attr_list=[\"age\"])\n# a [age=90]\n# \u251c\u2500\u2500 b [age=65]\n# \u2502   \u2514\u2500\u2500 d [age=40]\n# \u2514\u2500\u2500 c [age=60]\n</code></pre>"},{"location":"gettingstarted/demo/tree/#5-from-pandaspolars-dataframe","title":"5. From pandas/polars DataFrame","text":"<p>Construct nodes with attributes. DataFrame can contain either path column or parent-child columns. Other columns can be used to specify attributes.</p> pandas - Path columnpandas - Parent-child columnspolars - Path columnpolars - Parent-child columns <pre><code>import pandas as pd\n\nfrom bigtree import dataframe_to_tree\n\ndata = pd.DataFrame(\n   [\n      [\"a\", 90],\n      [\"a/b\", 65],\n      [\"a/c\", 60],\n      [\"a/b/d\", 40],\n   ],\n   columns=[\"path\", \"age\"],\n)\nroot = dataframe_to_tree(data)\n\nroot.show(attr_list=[\"age\"])\n# a [age=90]\n# \u251c\u2500\u2500 b [age=65]\n# \u2502   \u2514\u2500\u2500 d [age=40]\n# \u2514\u2500\u2500 c [age=60]\n</code></pre> <pre><code>import pandas as pd\n\nfrom bigtree import dataframe_to_tree_by_relation\n\ndata = pd.DataFrame(\n   [\n      [\"a\", None, 90],\n      [\"b\", \"a\", 65],\n      [\"c\", \"a\", 60],\n      [\"d\", \"b\", 40],\n   ],\n   columns=[\"child\", \"parent\", \"age\"],\n)\nroot = dataframe_to_tree_by_relation(data)\n\nroot.show(attr_list=[\"age\"])\n# a [age=90]\n# \u251c\u2500\u2500 b [age=65]\n# \u2502   \u2514\u2500\u2500 d [age=40]\n# \u2514\u2500\u2500 c [age=60]\n</code></pre> <pre><code>import polars as pl\n\nfrom bigtree import polars_to_tree\n\ndata = pl.DataFrame(\n   [\n      [\"a\", 90],\n      [\"a/b\", 65],\n      [\"a/c\", 60],\n      [\"a/b/d\", 40],\n   ],\n   schema=[\"path\", \"age\"],\n)\nroot = polars_to_tree(data)\n\nroot.show(attr_list=[\"age\"])\n# a [age=90]\n# \u251c\u2500\u2500 b [age=65]\n# \u2502   \u2514\u2500\u2500 d [age=40]\n# \u2514\u2500\u2500 c [age=60]\n</code></pre> <pre><code>import polars as pl\n\nfrom bigtree import polars_to_tree_by_relation\n\ndata = pl.DataFrame(\n   [\n      [\"a\", None, 90],\n      [\"b\", \"a\", 65],\n      [\"c\", \"a\", 60],\n      [\"d\", \"b\", 40],\n   ],\n   schema=[\"child\", \"parent\", \"age\"],\n)\nroot = polars_to_tree_by_relation(data)\n\nroot.show(attr_list=[\"age\"])\n# a [age=90]\n# \u251c\u2500\u2500 b [age=65]\n# \u2502   \u2514\u2500\u2500 d [age=40]\n# \u2514\u2500\u2500 c [age=60]\n</code></pre> <p>Note</p> <p>If tree is already created, nodes can still be added using path string, dictionary, and pandas/polars DataFrame! Attributes can be added to existing nodes using a dictionary or pandas/polars DataFrame.</p>"},{"location":"gettingstarted/demo/tree/#view-tree","title":"View Tree","text":""},{"location":"gettingstarted/demo/tree/#1-print-tree","title":"1. Print Tree","text":"<p>After tree is constructed, it can be viewed by printing to console using <code>show</code>, <code>hshow</code>, or <code>vshow</code> method directly, for compact, horizontal, and vertical orientation respectively. Alternatively, the <code>print_tree</code>, <code>hprint_tree</code>, or <code>vprint_tree</code> method can be used.</p> <pre><code>from bigtree import Node, print_tree, hprint_tree, vprint_tree\n\nroot = Node(\"a\", alias=\"alias-a\", age=90, gender=\"F\")\nb = Node(\"b\", age=65, gender=\"M\", parent=root)\nc = Node(\"c\", alias=\"alias-c\", age=60, gender=\"M\", parent=root)\nd = Node(\"d\", age=40, gender=\"F\", parent=b)\ne = Node(\"e\", age=35, gender=\"M\", parent=b)\nprint_tree(root) # (1)!\n# a\n# \u251c\u2500\u2500 b\n# \u2502   \u251c\u2500\u2500 d\n# \u2502   \u2514\u2500\u2500 e\n# \u2514\u2500\u2500 c\n\nhprint_tree(root) # (2)!\n#            \u250c\u2500 d\n#      \u250c\u2500 b \u2500\u2524\n# \u2500 a \u2500\u2524     \u2514\u2500 e\n#      \u2514\u2500 c\n\nvprint_tree(root) # (3)!\n#         \u250c\u2500\u2500\u2500\u2510\n#         \u2502 a \u2502\n#         \u2514\u2500\u252c\u2500\u2518\n#      \u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2510\n#    \u250c\u2500\u2534\u2500\u2510      \u250c\u2500\u2534\u2500\u2510\n#    \u2502 b \u2502      \u2502 c \u2502\n#    \u2514\u2500\u252c\u2500\u2518      \u2514\u2500\u2500\u2500\u2518\n#   \u250c\u2500\u2500\u2534\u2500\u2500\u2500\u2510\n# \u250c\u2500\u2534\u2500\u2510  \u250c\u2500\u2534\u2500\u2510\n# \u2502 d \u2502  \u2502 e \u2502\n# \u2514\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2518\n</code></pre> <ol> <li>Alternatively, <code>root.show()</code> can be used</li> <li>Alternatively, <code>root.hshow()</code> can be used</li> <li>Alternatively, <code>root.vshow()</code> can be used</li> </ol> <p>Other customisations for printing are also available, such as:</p> <ul> <li>Printing alias instead of node name, if present</li> <li>Printing subtree</li> <li>Printing tree with attributes</li> <li>Different built-in or custom style and border style</li> </ul> AliasSubtreeTree with attributesStyle - ansiStyle - asciiStyle - constStyle - const_boldStyle - roundedStyle - doubleStyle - custom style <pre><code>root.show(alias=\"alias\")\n# alias-a\n# \u251c\u2500\u2500 b\n# \u2502   \u251c\u2500\u2500 d\n# \u2502   \u2514\u2500\u2500 e\n# \u2514\u2500\u2500 alias-c\n</code></pre> <pre><code>root.show(node_name_or_path=\"b\")\n# b\n# \u251c\u2500\u2500 d\n# \u2514\u2500\u2500 e\n\nroot.show(max_depth=2)\n# a\n# \u251c\u2500\u2500 b\n# \u2514\u2500\u2500 c\n</code></pre> <pre><code>root.show(attr_list=[\"age\"])\n# a [age=90]\n# \u251c\u2500\u2500 b [age=65]\n# \u2502   \u251c\u2500\u2500 d [age=40]\n# \u2502   \u2514\u2500\u2500 e [age=35]\n# \u2514\u2500\u2500 c [age=60]\n\nroot.show(attr_list=[\"age\"], attr_bracket=[\"*(\", \")\"])\n# a *(age=90)\n# \u251c\u2500\u2500 b *(age=65)\n# \u2502   \u251c\u2500\u2500 d *(age=40)\n# \u2502   \u2514\u2500\u2500 e *(age=35)\n# \u2514\u2500\u2500 c *(age=60)\n\nroot.show(all_attrs=True)\n# a [age=90, gender=F]\n# \u251c\u2500\u2500 b [age=65, gender=M]\n# \u2502   \u251c\u2500\u2500 d [age=40, gender=F]\n# \u2502   \u2514\u2500\u2500 e [age=35, gender=M]\n# \u2514\u2500\u2500 c [age=60, gender=M]\n</code></pre> <pre><code>root.show(style=\"ansi\")\n# a\n# |-- b\n# |   |-- d\n# |   `-- e\n# `-- c\n</code></pre> <pre><code>root.show(style=\"ascii\")\n# a\n# |-- b\n# |   |-- d\n# |   +-- e\n# +-- c\n</code></pre> <pre><code>root.show(style=\"const\")\n# a\n# \u251c\u2500\u2500 b\n# \u2502   \u251c\u2500\u2500 d\n# \u2502   \u2514\u2500\u2500 e\n# \u2514\u2500\u2500 c\n</code></pre> <pre><code>root.show(style=\"const_bold\")\n# a\n# \u2523\u2501\u2501 b\n# \u2503   \u2523\u2501\u2501 d\n# \u2503   \u2517\u2501\u2501 e\n# \u2517\u2501\u2501 c\n</code></pre> <pre><code>root.show(style=\"rounded\")\n# a\n# \u251c\u2500\u2500 b\n# \u2502   \u251c\u2500\u2500 d\n# \u2502   \u2570\u2500\u2500 e\n# \u2570\u2500\u2500 c\n</code></pre> <pre><code>root.show(style=\"double\")\n# a\n# \u2560\u2550\u2550 b\n# \u2551   \u2560\u2550\u2550 d\n# \u2551   \u255a\u2550\u2550 e\n# \u255a\u2550\u2550 c\n</code></pre> <pre><code>root.show(style=(\"\u2502  \", \"\u251c\u2192 \", \"\u2570\u2192 \"))\n# a\n# \u251c\u2192 b\n# \u2502  \u251c\u2192 d\n# \u2502  \u2570\u2192 e\n# \u2570\u2192 c\n</code></pre>"},{"location":"gettingstarted/demo/tree/#2-plot-tree","title":"2. Plot Tree","text":"<p>Tree can also be plotted using <code>plot</code> method directly with the help of <code>matplotlib</code> library. Alternatively, the <code>plot_tree</code> method can be used, but remember to run the <code>reingold_tilford</code> algorithm first to retrieve the x and y coordinates.</p> <p>Arguments and keyword arguments can be passed in as long as they are compatible with the <code>plt.plot()</code> function. A plt.Figure object is returned if you want to do further customisations such as add title or save the figure to image.</p> <pre><code>from bigtree import Node, reingold_tilford, plot_tree\n\nroot = Node(\"a\", age=90, gender=\"F\")\nb = Node(\"b\", age=65, gender=\"M\", parent=root)\nc = Node(\"c\", age=60, gender=\"M\", parent=root)\nd = Node(\"d\", age=40, gender=\"F\", parent=b)\ne = Node(\"e\", age=35, gender=\"M\", parent=b)\n\nreingold_tilford(root)\nfig = plot_tree(root, \"-ok\") # (1)!\nfig.axes[0].set_title(\"Tree Plot Demonstration\")\n\nfig.show()  # Show figure\nfig.savefig(\"assets/demo/tree_plot.png\")  # Save figure\n</code></pre> <ol> <li>Alternatively, <code>root.plot(\"-ok\")</code> can be used</li> </ol> <p></p>"},{"location":"gettingstarted/demo/tree/#tree-attributes-and-operations","title":"Tree Attributes and Operations","text":"<p>Note that using <code>BaseNode</code> or <code>Node</code> as superclass inherits the default class attributes (properties) and operations (methods).</p> <pre><code>from bigtree import str_to_tree\n\n# Initialize tree\ntree_str = \"\"\"\na\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 d\n\u2502   \u251c\u2500\u2500 e\n\u2502   \u2514\u2500\u2500 f\n\u2502       \u251c\u2500\u2500 h\n\u2502       \u2514\u2500\u2500 i\n\u2514\u2500\u2500 c\n    \u2514\u2500\u2500 g\n\"\"\"\nroot = str_to_tree(tree_str)\n\n# Accessing children\nnode_b = root[\"b\"]\nnode_e = root[\"b\"][\"e\"]\n</code></pre> <p>Below are the tables of attributes available to <code>BaseNode</code> and <code>Node</code> classes.</p> Attributes wrt self Code Returns Check if root <code>root.is_root</code> True Check if leaf node <code>root.is_leaf</code> False Check diameter of tree <code>node_b.diameter</code> 3 Check depth of node <code>node_b.depth</code> 2 Check depth of tree <code>node_b.max_depth</code> 4 Get root of tree <code>node_b.root</code> Node(/a, ) Get node path <code>node_b.node_path</code> (Node(/a, ), Node(/a/b, )) Get node name (only for <code>Node</code>) <code>node_b.node_name</code> 'b' Get node path name (only for <code>Node</code>) <code>node_b.path_name</code> '/a/b' Attributes wrt structure Code Returns Get child/children <code>root.children</code> (Node(/a/b, ), Node(/a/c, )) Get parent <code>node_e.parent</code> Node(/a/b, ) Get siblings <code>node_e.siblings</code> (Node(/a/b/d, ), Node(/a/b/f, )) Get left sibling <code>node_e.left_sibling</code> Node(/a/b/d, ) Get right sibling <code>node_e.right_sibling</code> Node(/a/b/f, ) Get ancestors (lazy evaluation) <code>list(node_e.ancestors)</code> [Node(/a/b, ), Node(/a, )] Get descendants (lazy evaluation) <code>list(node_b.descendants)</code> [Node(/a/b/d, ), Node(/a/b/e, ), Node(/a/b/f, ), Node(/a/b/f/h, ), Node(/a/b/f/i, )] Get leaves (lazy evaluation) <code>list(node_b.leaves)</code> [Node(/a/b/d, ), Node(/a/b/e, ), Node(/a/b/f/h, ), Node(/a/b/f/i, )] <p>Below is the table of operations available to <code>BaseNode</code> and <code>Node</code> classes.</p> Operations Code Returns Visualize tree (only for <code>Node</code>) <code>root.show()</code> None Visualize tree (horizontally) (only for <code>Node</code>) <code>root.hshow()</code> None Visualize tree (vertically) (only for <code>Node</code>) <code>root.vshow()</code> None Get node information <code>root.describe(exclude_prefix=\"_\")</code> [('name', 'a')] Find path from one node to another <code>root.go_to(node_e)</code> [Node(/a, ), Node(/a/b, ), Node(/a/b/e, )] Add child to node <code>root.append(Node(\"j\"))</code> None Add multiple children to node <code>root.extend([Node(\"k\"), Node(\"l\")])</code> None Set attribute(s) <code>root.set_attrs({\"description\": \"root-tag\"})</code> None Get attribute <code>root.get_attr(\"description\")</code> 'root-tag' Copy tree <code>root.copy()</code> None Sort children <code>root.sort(key=lambda node: node.node_name, reverse=True)</code> None Plot tree <code>root.plot(\"-ok\")</code> plt.Figure()"},{"location":"gettingstarted/demo/tree/#traverse-tree","title":"Traverse Tree","text":"<p>Tree can be traversed using the following traversal methods.</p> <pre><code>from bigtree import (\n    levelorder_iter,\n    levelordergroup_iter,\n    postorder_iter,\n    preorder_iter,\n    str_to_tree,\n    zigzag_iter,\n    zigzaggroup_iter,\n)\n\nroot = str_to_tree(\"\"\"\na\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 d\n\u2502   \u2514\u2500\u2500 e\n\u2514\u2500\u2500 c\n\"\"\")\n\n[node.node_name for node in preorder_iter(root)]\n# ['a', 'b', 'd', 'e', 'c']\n\n[node.node_name for node in postorder_iter(root)]\n# ['d', 'e', 'b', 'c', 'a']\n\n[node.node_name for node in levelorder_iter(root)]\n# ['a', 'b', 'c', 'd', 'e']\n\n[[node.node_name for node in node_group] for node_group in levelordergroup_iter(root)]\n# [['a'], ['b', 'c'], ['d', 'e']]\n\n[node.node_name for node in zigzag_iter(root)]\n# ['a', 'c', 'b', 'd', 'e']\n\n[[node.node_name for node in node_group] for node_group in zigzaggroup_iter(root)]\n# [['a'], ['c', 'b'], ['d', 'e']]\n</code></pre>"},{"location":"gettingstarted/demo/tree/#modify-tree","title":"Modify Tree","text":"<p>Nodes can be shifted (with or without replacement) or copied (without replacement) from one path to another, this changes the tree in-place. Nodes can also be copied (with or without replacement) between two different trees.</p> <p>There are various other configurations for performing copying/shifting, refer to code documentation for more examples.</p> Shift nodes <pre><code>from bigtree import list_to_tree, shift_nodes, shift_and_replace_nodes\n\nroot = list_to_tree(\n    [\"Downloads/Pictures\", \"Downloads/photo1.jpg\", \"Downloads/file1.doc\"]\n)\nroot.show()\n# Downloads\n# \u251c\u2500\u2500 Pictures\n# \u251c\u2500\u2500 photo1.jpg\n# \u2514\u2500\u2500 file1.doc\n\nshift_nodes(\n   tree=root,\n   from_paths=[\"photo1.jpg\", \"Downloads/file1.doc\"],\n   to_paths=[\"Downloads/Pictures/photo1.jpg\", \"Downloads/Files/file1.doc\"],\n)\nroot.show()\n# Downloads\n# \u251c\u2500\u2500 Pictures\n# \u2502   \u2514\u2500\u2500 photo1.jpg (1)\n# \u2514\u2500\u2500 Files\n#     \u2514\u2500\u2500 file1.doc (2)\n\nshift_and_replace_nodes(\n   tree=root,\n   from_paths=[\"Downloads/Files\"],\n   to_paths=[\"Downloads/Pictures/photo1.jpg\"],\n)\nroot.show()\n# Downloads\n# \u2514\u2500\u2500 Pictures\n#     \u2514\u2500\u2500 Files (3)\n#         \u2514\u2500\u2500 file1.doc\n</code></pre> <ol> <li>The first shift to destination <code>Downloads/Pictures/photo1.jpg</code></li> <li>The second shift to destination <code>Downloads/Files/file1.doc</code>, this creates intermediate Node <code>Files</code> as well</li> <li>Shift and replace <code>photo1.jpg</code> with <code>Files</code> folder</li> </ol> Copy nodes <pre><code>from bigtree import list_to_tree, copy_nodes\n\nroot = list_to_tree(\n    [\"Downloads/Pictures\", \"Downloads/photo1.jpg\", \"Downloads/file1.doc\"]\n)\nroot.show()\n# Downloads\n# \u251c\u2500\u2500 Pictures\n# \u251c\u2500\u2500 photo1.jpg\n# \u2514\u2500\u2500 file1.doc\n\ncopy_nodes(\n   tree=root,\n   from_paths=[\"photo1.jpg\", \"Downloads/file1.doc\"],\n   to_paths=[\"Downloads/Pictures/photo1.jpg\", \"Downloads/Files/file1.doc\"],\n)\nroot.show()\n# Downloads\n# \u251c\u2500\u2500 Pictures\n# \u2502   \u2514\u2500\u2500 photo1.jpg (1)\n# \u251c\u2500\u2500 photo1.jpg (2)\n# \u251c\u2500\u2500 file1.doc (4)\n# \u2514\u2500\u2500 Files\n#     \u2514\u2500\u2500 file1.doc (3)\n</code></pre> <ol> <li>The first copy to destination <code>Downloads/Pictures/photo1.jpg</code></li> <li>Original <code>photo1.jpg</code> still remains</li> <li>The second copy to destination <code>Downloads/Files/file1.doc</code>, this creates intermediate Node <code>Files</code> as well</li> <li>Original <code>file1.doc</code> still remains</li> </ol> Copy nodes between two trees <pre><code>from bigtree import (\n    Node,\n    copy_nodes_from_tree_to_tree,\n    copy_and_replace_nodes_from_tree_to_tree,\n    list_to_tree,\n    str_to_tree,\n)\n\nroot = list_to_tree(\n    [\"Downloads/Pictures\", \"Downloads/photo1.jpg\", \"Downloads/file1.doc\"]\n)\nroot.show()\n# Downloads\n# \u251c\u2500\u2500 Pictures\n# \u251c\u2500\u2500 photo1.jpg\n# \u2514\u2500\u2500 file1.doc\n\nroot_other = Node(\"Documents\")\ncopy_nodes_from_tree_to_tree(\n    from_tree=root,\n    to_tree=root_other,\n    from_paths=[\"Downloads/Pictures\", \"photo1.jpg\", \"file1.doc\"],\n    to_paths=[\n        \"Documents/Pictures\",\n        \"Documents/Pictures/photo1.jpg\",\n        \"Documents/Files/file1.doc\",\n    ],\n)\nroot_other.show()\n# Documents\n# \u251c\u2500\u2500 Pictures (1)\n# \u2502   \u2514\u2500\u2500 photo1.jpg (2)\n# \u2514\u2500\u2500 Files\n#     \u2514\u2500\u2500 file1.doc (3)\n\nroot_other = str_to_tree(\"\"\"\nDocuments\n\u251c\u2500\u2500 Pictures\n\u2502   \u2514\u2500\u2500 photo2.jpg\n\u2514\u2500\u2500 file2.doc\n\"\"\")\n\ncopy_and_replace_nodes_from_tree_to_tree(\n    from_tree=root,\n    to_tree=root_other,\n    from_paths=[\"Downloads/photo1.jpg\", \"Downloads/file1.doc\"],\n    to_paths=[\"Documents/Pictures/photo2.jpg\", \"Documents/file2.doc\"],\n)\nroot_other.show()\n# Documents\n# \u251c\u2500\u2500 Pictures\n# \u2502   \u2514\u2500\u2500 photo1.jpg (4)\n# \u2514\u2500\u2500 file1.doc (5)\n</code></pre> <ol> <li>The first copy to destination <code>Documents/Pictures</code></li> <li>The second copy to destination <code>Documents/Pictures/photo1.jpg</code></li> <li>The third copy to destination <code>Documents/Files/file1.doc</code>, this creates intermediate Node <code>Files</code> as well</li> <li>The first copy and replace of <code>Documents/Pictures/photo2.jpg</code> with <code>photo1.jpg</code></li> <li>The second copy and replace of <code>Documents/file2.doc</code> with <code>file1.doc</code></li> </ol>"},{"location":"gettingstarted/demo/tree/#tree-search","title":"Tree Search","text":"<p>One or multiple nodes can be searched based on name, path, attribute value, or user-defined condition. It is also possible to search for one or more child node(s) based on attributes, this search will be faster as it does not require traversing the whole tree to find the node(s).</p> Find single nodeFind multiple nodesFind child nodes <pre><code>from bigtree import Node, find, find_name, find_path, find_relative_path, find_full_path, find_attr\nroot = Node(\"a\", age=90)\nb = Node(\"b\", age=65, parent=root)\nc = Node(\"c\", age=60, parent=root)\nd = Node(\"d\", age=40, parent=c)\nroot.show(attr_list=[\"age\"])\n# a [age=90]\n# \u251c\u2500\u2500 b [age=65]\n# \u2514\u2500\u2500 c [age=60]\n#     \u2514\u2500\u2500 d [age=40]\n\nfind(root, lambda node: node.age == 60)\n# Node(/a/c, age=60)\n\nfind_name(root, \"d\")\n# Node(/a/c/d, age=40)\n\nfind_relative_path(c, \"../b\")  # relative path\n# Node(/a/b, age=65)\n\nfind_path(root, \"/c/d\")  # partial path\n# Node(/a/c/d, age=40)\n\nfind_full_path(root, \"a/c/d\")  # full path\n# Node(/a/c/d, age=40)\n\nfind_attr(root, \"age\", 40)\n# Node(/a/c/d, age=40)\n</code></pre> <pre><code>from bigtree import Node, findall, find_names, find_relative_paths, find_paths, find_attrs\nroot = Node(\"a\", age=90)\nb = Node(\"b\", age=65, parent=root)\nc = Node(\"c\", age=60, parent=root)\nd = Node(\"c\", age=40, parent=c)\nroot.show(attr_list=[\"age\"])\n# a [age=90]\n# \u251c\u2500\u2500 b [age=65]\n# \u2514\u2500\u2500 c [age=60]\n#     \u2514\u2500\u2500 c [age=40]\n\nfindall(root, lambda node: node.age &gt;= 65)\n# (Node(/a, age=90), Node(/a/b, age=65))\n\nfind_names(root, \"c\")\n# (Node(/a/c, age=60), Node(/a/c/c, age=40))\n\nfind_relative_paths(c, \"../*\")  # relative path\n# (Node(/a/b, age=65), Node(/a/c, age=60))\n\nfind_paths(root, \"/c\")  # partial path\n# (Node(/a/c, age=60), Node(/a/c/c, age=40))\n\nfind_attrs(root, \"age\", 40)\n# (Node(/a/c/c, age=40),)\n</code></pre> <pre><code>from bigtree import Node, find_children, find_child, find_child_by_name\nroot = Node(\"a\", age=90)\nb = Node(\"b\", age=65, parent=root)\nc = Node(\"c\", age=60, parent=root)\nd = Node(\"c\", age=40, parent=c)\nroot.show(attr_list=[\"age\"])\n# a [age=90]\n# \u251c\u2500\u2500 b [age=65]\n# \u2514\u2500\u2500 c [age=60]\n#     \u2514\u2500\u2500 c [age=40]\n\nfind_children(root, lambda node: node.age &gt;= 60)\n# (Node(/a/b, age=65), Node(/a/c, age=60))\n\nfind_child(root, lambda node: node.node_name == \"c\")\n# Node(/a/c, age=60)\n\nfind_child_by_name(root, \"c\")\n# Node(/a/c, age=60)\n\nfind_child_by_name(c, \"c\")\n# Node(/a/c/c, age=40)\n</code></pre>"},{"location":"gettingstarted/demo/tree/#helper-utility","title":"Helper Utility","text":""},{"location":"gettingstarted/demo/tree/#1-clone-tree","title":"1. Clone tree","text":"<p>Trees can be cloned to another Node type. If the same type is desired, use <code>tree.copy()</code> instead.</p> <pre><code>from bigtree import BaseNode, Node, clone_tree\n\nroot = BaseNode(name=\"a\")\nb = BaseNode(name=\"b\", parent=root)\n\nclone_tree(root, Node)  # clone from `BaseNode` to `Node` type\n# Node(/a, )\n</code></pre>"},{"location":"gettingstarted/demo/tree/#2-get-subtree","title":"2. Get subtree","text":"<p>Subtree refers to a smaller tree with a different tree root.</p> <pre><code>from bigtree import str_to_tree, get_subtree\n\nroot = str_to_tree(\"\"\"\na\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 d\n\u2502   \u2514\u2500\u2500 e\n\u2514\u2500\u2500 c\n    \u2514\u2500\u2500 f\n\"\"\")\n\nroot_subtree = get_subtree(root, \"b\")\nroot_subtree.show()\n# b\n# \u251c\u2500\u2500 d\n# \u2514\u2500\u2500 e\n</code></pre>"},{"location":"gettingstarted/demo/tree/#3-prune-tree","title":"3. Prune tree","text":"<p>Pruned tree refers to a smaller tree with the same tree root. Trees can be pruned by one or more of the following filters:</p> <ul> <li>Path: keep all descendants by default, set <code>exact=True</code> to prune the path exactly</li> <li>Depth: prune tree by depth</li> </ul> Prune by pathPrune by exact pathPrune by depth <pre><code>from bigtree import str_to_tree, prune_tree\n\nroot = str_to_tree(\"\"\"\na\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 d\n\u2502   \u2514\u2500\u2500 e\n\u2514\u2500\u2500 c\n    \u2514\u2500\u2500 f\n\"\"\")\n\nroot_pruned = prune_tree(root, \"a/b\")\nroot_pruned.show()\n# a\n# \u2514\u2500\u2500 b\n#     \u251c\u2500\u2500 d\n#     \u2514\u2500\u2500 e\n</code></pre> <pre><code>from bigtree import str_to_tree, prune_tree\n\nroot = str_to_tree(\"\"\"\na\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 d\n\u2502   \u2514\u2500\u2500 e\n\u2514\u2500\u2500 c\n    \u2514\u2500\u2500 f\n\"\"\")\n\nroot_pruned = prune_tree(root, \"a/b\", exact=True)\nroot_pruned.show()\n# a\n# \u2514\u2500\u2500 b\n</code></pre> <pre><code>from bigtree import str_to_tree, prune_tree\n\nroot = str_to_tree(\"\"\"\na\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 d\n\u2502   \u2514\u2500\u2500 e\n\u2514\u2500\u2500 c\n    \u2514\u2500\u2500 f\n\"\"\")\n\nroot_pruned = prune_tree(root, \"c\", max_depth=2)\nroot_pruned.show()\n# a\n# \u2514\u2500\u2500 c\n</code></pre>"},{"location":"gettingstarted/demo/tree/#4-get-tree-differences","title":"4. Get tree differences","text":"<p>View the differences in structure and/or attributes between two trees. The changes reflected are relative to the first tree. By default, only the differences are shown. It is possible to view the full original tree with the differences.</p> <p>To compare tree attributes:</p> <ul> <li><code>(+)</code>: Node is added in second tree</li> <li><code>(-)</code>: Node is removed in second tree</li> <li><code>(~)</code>: Node has different attributes, only available when comparing attributes</li> </ul> <p>For more details, <code>(moved from)</code>, <code>(moved to)</code>, <code>(added)</code>, and <code>(removed)</code> can be indicated instead if <code>(+)</code> and <code>(-)</code> by passing <code>detail=True</code>.</p> <p>For aggregating the differences at the parent-level instead of having <code>(+)</code> and <code>(-)</code> at every child node, pass in <code>aggregate=True</code>. This is useful if subtrees are shifted, and if you want to view the shifting at the parent-level.</p> <p>Note</p> <p>For more custom processing and handling of the tree differences, the interim dataframe of the tree differences can be retrieved with <code>get_tree_diff_dataframe</code>.</p> Only differencesFull original treeWith detailsWith aggregated differencesAttribute difference <pre><code>from bigtree import str_to_tree, get_tree_diff\n\nroot = str_to_tree(\"\"\"\na\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 d\n\u2502   \u2514\u2500\u2500 e\n\u2514\u2500\u2500 c\n    \u2514\u2500\u2500 f\n\"\"\")\n\nroot_other = str_to_tree(\"\"\"\na\n\u251c\u2500\u2500 b\n\u2502   \u2514\u2500\u2500 d\n\u2514\u2500\u2500 c\n    \u2514\u2500\u2500 g\n\"\"\")\n\ntree_diff = get_tree_diff(root, root_other)\ntree_diff.show()\n# a\n# \u251c\u2500\u2500 b\n# \u2502   \u2514\u2500\u2500 e (-)\n# \u2514\u2500\u2500 c\n#     \u251c\u2500\u2500 f (-)\n#     \u2514\u2500\u2500 g (+)\n</code></pre> <pre><code>from bigtree import str_to_tree, get_tree_diff\n\nroot = str_to_tree(\"\"\"\na\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 d\n\u2502   \u2514\u2500\u2500 e\n\u2514\u2500\u2500 c\n    \u2514\u2500\u2500 f\n\"\"\")\n\nroot_other = str_to_tree(\"\"\"\na\n\u251c\u2500\u2500 b\n\u2502   \u2514\u2500\u2500 d\n\u2514\u2500\u2500 c\n    \u2514\u2500\u2500 g\n\"\"\")\n\ntree_diff = get_tree_diff(root, root_other, only_diff=False)\ntree_diff.show()\n# a\n# \u251c\u2500\u2500 b\n# \u2502   \u251c\u2500\u2500 d\n# \u2502   \u2514\u2500\u2500 e (-)\n# \u2514\u2500\u2500 c\n#     \u251c\u2500\u2500 f (-)\n#     \u2514\u2500\u2500 g (+)\n</code></pre> <pre><code>from bigtree import str_to_tree, get_tree_diff\n\nroot = str_to_tree(\"\"\"\na\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 d\n\u2502   \u2502   \u2514\u2500\u2500 g\n\u2502   \u2514\u2500\u2500 e\n\u2514\u2500\u2500 c\n    \u2514\u2500\u2500 f\n\"\"\")\n\nroot_other = str_to_tree(\"\"\"\na\n\u251c\u2500\u2500 b\n\u2502   \u2514\u2500\u2500 h\n\u2514\u2500\u2500 c\n    \u251c\u2500\u2500 d\n    \u2502   \u2514\u2500\u2500 g\n    \u2514\u2500\u2500 f\n\"\"\")\n\ntree_diff = get_tree_diff(root, root_other, detail=True)\ntree_diff.show()\n# a\n# \u251c\u2500\u2500 b\n# \u2502   \u251c\u2500\u2500 d (moved from)\n# \u2502   \u2502   \u2514\u2500\u2500 g (moved from)\n# \u2502   \u251c\u2500\u2500 e (removed)\n# \u2502   \u2514\u2500\u2500 h (added)\n# \u2514\u2500\u2500 c\n#     \u2514\u2500\u2500 d (moved to)\n#         \u2514\u2500\u2500 g (moved to)\n</code></pre> <pre><code>from bigtree import str_to_tree, get_tree_diff\n\nroot = str_to_tree(\"\"\"\na\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 d\n\u2502   \u2502   \u2514\u2500\u2500 g\n\u2502   \u2514\u2500\u2500 e\n\u2514\u2500\u2500 c\n    \u2514\u2500\u2500 f\n\"\"\")\n\nroot_other = str_to_tree(\"\"\"\na\n\u251c\u2500\u2500 b\n\u2502   \u2514\u2500\u2500 h\n\u2514\u2500\u2500 c\n    \u251c\u2500\u2500 d\n    \u2502   \u2514\u2500\u2500 g\n    \u2514\u2500\u2500 f\n\"\"\")\n\ntree_diff = get_tree_diff(root, root_other, detail=True, aggregate=True)\ntree_diff.show()\n# a\n# \u251c\u2500\u2500 b\n# \u2502   \u251c\u2500\u2500 d (moved from)\n# \u2502   \u2502   \u2514\u2500\u2500 g\n# \u2502   \u251c\u2500\u2500 e (removed)\n# \u2502   \u2514\u2500\u2500 h (added)\n# \u2514\u2500\u2500 c\n#     \u2514\u2500\u2500 d (moved to)\n#         \u2514\u2500\u2500 g\n</code></pre> <pre><code>from bigtree import Node, get_tree_diff\n\nroot = Node(\"a\")\nb = Node(\"b\", parent=root)\nc = Node(\"c\", tags=\"original c\", parent=b)\nd = Node(\"d\", tags=\"original d\", parent=root)\nroot.show(attr_list=[\"tags\"])\n# a\n# \u251c\u2500\u2500 b\n# \u2502   \u2514\u2500\u2500 c [tags=original c]\n# \u2514\u2500\u2500 d [tags=original d]\n\nroot_other = Node(\"a\")\nb = Node(\"b\", parent=root_other)\nc = Node(\"c\", tags=\"new c\", parent=b)\ne = Node(\"e\", tags=\"new e\", parent=b)\nd = Node(\"d\", tags=\"new d\", parent=root_other)\nroot_other.show(attr_list=[\"tags\"])\n# a\n# \u251c\u2500\u2500 b\n# \u2502   \u251c\u2500\u2500 c [tags=new c]\n# \u2502   \u2514\u2500\u2500 e [tags=new e]\n# \u2514\u2500\u2500 d [tags=new d]\n\ntree_diff = get_tree_diff(root, root_other, attr_list=[\"tags\"])\ntree_diff.show(attr_list=[\"tags\"])\n# a\n# \u251c\u2500\u2500 b\n# \u2502   \u251c\u2500\u2500 c (~) [tags=('original c', 'new c')]\n# \u2502   \u2514\u2500\u2500 e (+)\n# \u2514\u2500\u2500 d (~) [tags=('original d', 'new d')]\n</code></pre>"},{"location":"gettingstarted/demo/tree/#export-tree","title":"Export Tree","text":"<p>Tree can be exported to other data types:</p> <ol> <li>Newick string notation</li> <li>Nested dictionary (flat structure and recursive structure)</li> <li>pandas DataFrame</li> <li>polars DataFrame</li> <li>Dot (can save to .dot, .png, .svg, .jpeg files)</li> <li>Pillow (can save to .png, .jpg)</li> <li>Mermaid Flowchart (can display on .md)</li> </ol> <pre><code>from bigtree import Node\n\nroot = Node(\"a\", age=90)\nb = Node(\"b\", age=65, parent=root)\nc = Node(\"c\", age=60, parent=root)\nd = Node(\"d\", age=40, parent=b)\ne = Node(\"e\", age=35, parent=b)\nroot.show()\n# a\n# \u251c\u2500\u2500 b\n# \u2502   \u251c\u2500\u2500 d\n# \u2502   \u2514\u2500\u2500 e\n# \u2514\u2500\u2500 c\n</code></pre> Newick string notationDictionary (flat structure)Dictionary (recursive structure)pandas DataFramepolars DataFrameDotPillow GraphPillowMermaid Flowchart <pre><code>from bigtree import tree_to_newick\n\ntree_to_newick(root)\n# '((d,e)b,c)a'\n\ntree_to_newick(root, attr_list=[\"age\"])\n# '((d[&amp;&amp;NHX:age=40],e[&amp;&amp;NHX:age=35])b[&amp;&amp;NHX:age=65],c[&amp;&amp;NHX:age=60])a[&amp;&amp;NHX:age=90]'\n</code></pre> <pre><code>from bigtree import tree_to_dict\n\ntree_to_dict(\n   root,\n   name_key=\"name\",\n   parent_key=\"parent\",\n   attr_dict={\"age\": \"person age\"}\n)\n# {\n#    '/a': {'name': 'a', 'parent': None, 'person age': 90},\n#    '/a/b': {'name': 'b', 'parent': 'a', 'person age': 65},\n#    '/a/b/d': {'name': 'd', 'parent': 'b', 'person age': 40},\n#    '/a/b/e': {'name': 'e', 'parent': 'b', 'person age': 35},\n#    '/a/c': {'name': 'c', 'parent': 'a', 'person age': 60}\n# }\n</code></pre> <pre><code>from bigtree import tree_to_nested_dict\n\ntree_to_nested_dict(root, all_attrs=True)\n# {\n#    'name': 'a',\n#    'age': 90,\n#    'children': [\n#       {\n#          'name': 'b',\n#          'age': 65,\n#          'children': [\n#             {\n#                'name': 'd',\n#                'age': 40\n#             },\n#             {\n#                'name': 'e',\n#                'age': 35\n#             }\n#          ]\n#       },\n#       {\n#          'name': 'c',\n#          'age': 60\n#       }\n#    ]\n# }\n</code></pre> <pre><code>from bigtree import tree_to_dataframe\n\ntree_to_dataframe(\n   root,\n   name_col=\"name\",\n   parent_col=\"parent\",\n   path_col=\"path\",\n   attr_dict={\"age\": \"person age\"}\n)\n#      path name parent  person age\n# 0      /a    a   None          90\n# 1    /a/b    b      a          65\n# 2  /a/b/d    d      b          40\n# 3  /a/b/e    e      b          35\n# 4    /a/c    c      a          60\n</code></pre> <pre><code>from bigtree import tree_to_polars\n\ntree_to_polars(\n   root,\n   name_col=\"name\",\n   parent_col=\"parent\",\n   path_col=\"path\",\n   attr_dict={\"age\": \"person age\"}\n)\n# shape: (5, 4)\n# \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n# \u2502 path   \u2506 name \u2506 parent \u2506 person age \u2502\n# \u2502 ---    \u2506 ---  \u2506 ---    \u2506 ---        \u2502\n# \u2502 str    \u2506 str  \u2506 str    \u2506 i64        \u2502\n# \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n# \u2502 /a     \u2506 a    \u2506 null   \u2506 90         \u2502\n# \u2502 /a/b   \u2506 b    \u2506 a      \u2506 65         \u2502\n# \u2502 /a/b/d \u2506 d    \u2506 b      \u2506 40         \u2502\n# \u2502 /a/b/e \u2506 e    \u2506 b      \u2506 35         \u2502\n# \u2502 /a/c   \u2506 c    \u2506 a      \u2506 60         \u2502\n# \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>from bigtree import tree_to_dot\n\ngraph = tree_to_dot(root, node_colour=\"gold\")\ngraph.write_png(\"assets/demo/dot.png\")\n</code></pre> <pre><code>from bigtree import tree_to_pillow_graph\n\npillow_image = tree_to_pillow_graph(root, node_content=\"{node_name}\\nAge {age}\")\npillow_image.save(\"assets/demo/pillow_graph.png\")\n</code></pre> <pre><code>from bigtree import tree_to_pillow\n\npillow_image = tree_to_pillow(root)\npillow_image.save(\"assets/demo/pillow.png\")\n</code></pre> <pre><code>from bigtree import tree_to_mermaid\n\nmermaid_md = tree_to_mermaid(root)\nprint(mermaid_md)\n</code></pre> <ul> <li>dot.png</li> </ul> <p></p> <ul> <li>pillow_graph.png</li> </ul> <p></p> <ul> <li>pillow.png</li> </ul> <p></p> <ul> <li>Mermaid flowchart <pre><code>%%{ init: { 'flowchart': { 'curve': 'basis' } } }%%\nflowchart TB\n0(\"a\") --&gt; 0-0(\"b\")\n0-0 --&gt; 0-0-0(\"d\")\n0-0 --&gt; 0-0-1(\"e\")\n0(\"a\") --&gt; 0-1(\"c\")\nclassDef default stroke-width:1</code></pre></li> </ul>"},{"location":"gettingstarted/demo/workflow/","title":"\ud83d\udccb Workflow Demonstration","text":"<p>There are existing implementations of workflows to showcase how <code>bigtree</code> can be used!</p>"},{"location":"gettingstarted/demo/workflow/#to-do-application","title":"To Do Application","text":"<p>There are functions to:</p> <ul> <li>Add or remove list to To-Do application</li> <li>Add or remove item to list, default list is the 'General' list</li> <li>Prioritize a list/item by reordering them as first list/item</li> <li>Save and import To-Do application to and from an external JSON file</li> <li>Show To-Do application, which prints tree to console</li> </ul> <pre><code>from bigtree import AppToDo\n\napp = AppToDo(\"To Do App\")\napp.add_item(item_name=\"Homework 1\", list_name=\"School\")\napp.add_item(item_name=[\"Milk\", \"Bread\"], list_name=\"Groceries\", description=\"Urgent\")\napp.add_item(item_name=\"Cook\")\napp.show()\n# To Do App\n# \u251c\u2500\u2500 School\n# \u2502   \u2514\u2500\u2500 Homework 1\n# \u251c\u2500\u2500 Groceries\n# \u2502   \u251c\u2500\u2500 Milk [description=Urgent]\n# \u2502   \u2514\u2500\u2500 Bread [description=Urgent]\n# \u2514\u2500\u2500 General\n#     \u2514\u2500\u2500 Cook\n\napp.save(\"list.json\")\napp2 = AppToDo.load(\"list.json\")\n</code></pre>"},{"location":"gettingstarted/demo/workflow/#calendar-application","title":"Calendar Application","text":"<p>There are functions to:</p> <ul> <li>Add or remove event from Calendar</li> <li>Find event by name, or name and date</li> <li>Display calendar, which prints events to console</li> <li>Export calendar to pandas DataFrame</li> </ul> <pre><code>import datetime as dt\nfrom bigtree import Calendar\n\ncalendar = Calendar(\"My Calendar\")\ncalendar.add_event(\"Gym\", \"2023-01-01 18:00\")\ncalendar.add_event(\"Dinner\", \"2023-01-01\", date_format=\"%Y-%m-%d\", budget=20)\ncalendar.add_event(\"Gym\", \"2023-01-02 18:00\")\ncalendar.show()\n# My Calendar\n# 2023-01-01 00:00:00 - Dinner (budget: 20)\n# 2023-01-01 18:00:00 - Gym\n# 2023-01-02 18:00:00 - Gym\n\ncalendar.find_event(\"Gym\")\n# 2023-01-01 18:00:00 - Gym\n# 2023-01-02 18:00:00 - Gym\n\ncalendar.delete_event(\"Gym\", dt.date(2023, 1, 1))\ncalendar.show()\n# My Calendar\n# 2023-01-01 00:00:00 - Dinner (budget: 20)\n# 2023-01-02 18:00:00 - Gym\n\ndata_calendar = calendar.to_dataframe()\ndata_calendar\n#                              path    name        date      time  budget\n# 0  /My Calendar/2023/01/01/Dinner  Dinner  2023-01-01  00:00:00    20.0\n# 1     /My Calendar/2023/01/02/Gym     Gym  2023-01-02  18:00:00     NaN\n</code></pre>"},{"location":"gettingstarted/resources/articles/","title":"\ud83d\udcf0 Articles","text":"<ul> <li> Python Tree Implementation with BigTree <p>Integrating trees with Python lists, dictionaries, and pandas DataFrames</p> <p> Read article</p> </li> </ul> <ul> <li> The Reingold Tilford Algorithm Explained, with Walkthrough <p>Algorithm to Plot Tree Nodes with Numerical Examples and Python Code</p> <p> Read article</p> </li> </ul>"},{"location":"gettingstarted/resources/glossary/","title":"\u260e\ufe0f Glossary","text":"<p>Trees are non-linear data structures that store data hierarchically and are made up of nodes connected by edges. For example in a family tree, a node would represent a person and an edge would represent the relationship between two nodes.</p>"},{"location":"gettingstarted/resources/glossary/#terminology","title":"Terminology","text":"<p>After knowing the components that make up a tree, there are a few terminologies that extend to these components:</p>"},{"location":"gettingstarted/resources/glossary/#tree-structure","title":"Tree structure","text":"<ul> <li>Root: Node that does not have any parent and the entire tree originates from it, each tree only has one root!</li> <li>Leaf: Node(s) that do not have any child</li> <li>Height/Max Depth: Maximum depth of root to a leaf node</li> </ul> <p>In the diagram above, the root node is <code>a</code> and the leaf nodes are <code>c</code>, <code>d</code>, and <code>e</code>. The height of the tree is 3.</p>"},{"location":"gettingstarted/resources/glossary/#relative-tree-structure","title":"Relative tree structure","text":"<ul> <li>Parent Node: Immediate predecessor of a node</li> <li>Child Node(s): Immediate successor(s) of a node</li> <li>Ancestors: All predecessors of a node, excluding itself</li> <li>Descendants: All successors of a node, excluding itself</li> <li>Siblings: Nodes that have the same parent</li> <li>Left Sibling: Sibling to the left of the node</li> <li>Right Sibling: Sibling to the right of the node</li> <li>Depth: Length of the path from Node to root</li> </ul>"},{"location":"gettingstarted/resources/glossary/#tree-traversal-algorithms","title":"Tree Traversal Algorithms","text":"<p>There are two types of tree traversal, Depth-First Search (DFS) and Breadth-First Search (BFS).</p> <ul> <li>Depth-First Search starts at the root and explores each branch to its leaf node before moving to the next branch</li> <li>Breadth-First Search starts at the root and explores every child node, and recursively does so for every node</li> </ul>"},{"location":"gettingstarted/resources/glossary/#pre-order-traversal","title":"Pre-Order Traversal","text":"<p>Pre-Order Traversal is a Depth-First Search (DFS) method that performs 3 steps recursively,</p> <ol> <li>Visit the current node (N)</li> <li>Recursively traversal the current node\u2019s left subtree (L)</li> <li>Recursively traverse the current node\u2019s right subtree (R)</li> </ol>"},{"location":"gettingstarted/resources/glossary/#post-order-traversal","title":"Post-Order Traversal","text":"<p>Post-Order Traversal is a Depth-First Search (DFS) method that performs 3 steps recursively,</p> <ol> <li>Recursively traverse the current node\u2019s left subtree (L)</li> <li>Recursively traverse the current node\u2019s right subtree (R)</li> <li>Visit the current node (N)</li> </ol>"},{"location":"gettingstarted/resources/glossary/#in-order-traversal","title":"In-Order Traversal","text":"<p>In-Order Traversal is a Depth-First Search (DFS) method that is only applicable to binary trees.</p> <ol> <li>Recursively traverse the current node\u2019s left subtree (L)</li> <li>Visit the current node (N)</li> <li>Recursively traverse the current node\u2019s right subtree (R)</li> </ol>"},{"location":"gettingstarted/resources/glossary/#level-order-traversal","title":"Level-Order Traversal","text":"<p>Level-Order Traversal is a Breadth-First Search method. In <code>bigtree</code>, we have level-order traversal and level-order group traversal methods.</p>"},{"location":"gettingstarted/resources/glossary/#zig-zag-traversal","title":"Zig Zag Traversal","text":"<p>Zig Zag Traversal is similar to level-order traversal, but in a zigzag manner across different levels. In <code>bigtree</code>, we have zig zag traversal and zig zag group traversal methods.</p>"},{"location":"home/benchmarks/","title":"\u23f0 Benchmarks","text":""},{"location":"home/binarytree/","title":"\ud83c\udf35 Binary Tree","text":"<p>For Binary Tree implementation, there are 3 main components. Binary Node inherits from Node, so the components in Tree implementation are also available in Binary Tree.</p>"},{"location":"home/binarytree/#node","title":"\ud83c\udf3f Node","text":"<ul> <li><code>BinaryNode</code>, Node with binary tree rules</li> </ul>"},{"location":"home/binarytree/#constructing-binary-tree","title":"\u2728 Constructing Binary Tree","text":"<ul> <li>From list, using flattened list structure</li> </ul>"},{"location":"home/binarytree/#traversing-binary-tree","title":"\u27b0 Traversing Binary Tree","text":"<ul> <li>In-Order Traversal</li> </ul>"},{"location":"home/changelog/","title":"\ud83c\udf42 Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"home/changelog/#unreleased","title":"Unreleased","text":"<ul> <li>Docs: Clean up docstring where possible and relevant.</li> </ul>"},{"location":"home/changelog/#0253-2025-03-30","title":"0.25.3 - 2025-03-30","text":""},{"location":"home/changelog/#changed","title":"Changed:","text":"<ul> <li>Docs: Deduplicate type hint and default value in docstrings.</li> <li>Misc: Clean up repository by abstracting functions into inheritable classes.</li> </ul>"},{"location":"home/changelog/#0252-2025-03-14","title":"0.25.2 - 2025-03-14","text":""},{"location":"home/changelog/#added","title":"Added:","text":"<ul> <li>Tree Exporter: <code>hprint_tree</code> and <code>hyield_tree</code> to support spacing parameter.</li> </ul>"},{"location":"home/changelog/#fixed","title":"Fixed:","text":"<ul> <li>Tree Exporter: Case when parent is longer than child in <code>vprint_tree</code> and <code>vyield_tree</code>.</li> </ul>"},{"location":"home/changelog/#0251-2025-02-28","title":"0.25.1 - 2025-02-28","text":""},{"location":"home/changelog/#added_1","title":"Added:","text":"<ul> <li>Tree Exporter: <code>vprint_tree</code> to have same arguments as <code>vyield_tree</code>, add more test cases.</li> <li>Tree Exporter: <code>hprint_tree</code> to support multiline node name, alias, and border style.</li> </ul>"},{"location":"home/changelog/#0250-2025-02-25","title":"0.25.0 - 2025-02-25","text":""},{"location":"home/changelog/#added_2","title":"Added:","text":"<ul> <li>Tree Exporter: <code>tree_to_pillow_graph</code> method to allow cmap for node background and generic kwargs for yield_tree.</li> <li>Tree Exporter: <code>vprint_tree</code> method to print trees vertically, able to use <code>.vshow()</code> as well.</li> </ul>"},{"location":"home/changelog/#changed_1","title":"Changed:","text":"<ul> <li>Tree Exporter: Minor refactoring to deduplicate code in export module.</li> </ul>"},{"location":"home/changelog/#0240-2025-02-09","title":"0.24.0 - 2025-02-09","text":""},{"location":"home/changelog/#added_3","title":"Added:","text":"<ul> <li>Docs: Tips for setting custom coordinates for plots.</li> <li>Tree Exporter: <code>tree_to_pillow_graph</code> method to export tree to pillow image in graph format.</li> </ul>"},{"location":"home/changelog/#changed_2","title":"Changed:","text":"<ul> <li>Plot: Allow <code>reverse</code> argument to allow top-bottom y coordinates in Reingold Tilford algorithm.</li> <li>Docs: Add more elaboration for exporting to image for tree and dag.</li> <li>Misc: Split tree/construct and tree/export into multiple files.</li> </ul>"},{"location":"home/changelog/#0231-2025-01-22","title":"0.23.1 - 2025-01-22","text":""},{"location":"home/changelog/#changed_3","title":"Changed:","text":"<ul> <li>Tree Search: Search relative path allows unix folder expression for leading sep symbol.</li> <li>Node: Updated Node signature to reflect that name is mandatory.</li> </ul>"},{"location":"home/changelog/#0230-2024-12-26","title":"0.23.0 - 2024-12-26","text":""},{"location":"home/changelog/#changed_4","title":"Changed:","text":"<ul> <li>Tree Modify: Update documentation and docstring with some rephrasing.</li> <li>Tree Modify: Clean up test cases.</li> </ul>"},{"location":"home/changelog/#added_4","title":"Added:","text":"<ul> <li>Tree Modify: Add parameter <code>merge_attribute</code> to allow from-node and to-node attributes to be merged if there are clashes.</li> </ul>"},{"location":"home/changelog/#fixed_1","title":"Fixed:","text":"<ul> <li>Tree Modify: Fixed bug when <code>merge_children</code> is used with <code>overriding</code> as the <code>merge_children</code> value is changed in for-loop (bad move, literally). Modified the logic such that if there are clashes for <code>merge_children=True, overriding=True</code>, the origin node parent and destination node children are preserved. The origin node's children are overridden. This might not be backwards-compatible!</li> </ul>"},{"location":"home/changelog/#0223-2024-11-14","title":"0.22.3 - 2024-11-14","text":""},{"location":"home/changelog/#added_5","title":"Added:","text":"<ul> <li>Tree Helper: <code>get_tree_diff_dataframe</code> to get tree differences in pd.DataFrame for customised processing and handling.</li> </ul>"},{"location":"home/changelog/#changed_5","title":"Changed:","text":"<ul> <li>Tree Helper: Get tree diff logic to be faster to compare all attribute list and data at once (for attr diff).</li> <li>Tree Helper: Get tree diff logic to be faster to add suffix at the end (for path diff).</li> <li>Tree Helper: Get tree diff logic to be faster to detect moved indicator using dataframe operations (for detail).</li> </ul>"},{"location":"home/changelog/#0222-2024-11-11","title":"0.22.2 - 2024-11-11","text":""},{"location":"home/changelog/#added_6","title":"Added:","text":"<ul> <li>Tree Export: Print tree to allow alias.</li> <li>Tree Export: Mermaid diagram to include theme.</li> <li>Tree Helper: Get tree diff to take in <code>aggregate</code> parameter to indicate differences at the top-level node.</li> <li>Misc: Documentation to include tips and tricks on working with custom classes.</li> </ul>"},{"location":"home/changelog/#changed_6","title":"Changed:","text":"<ul> <li>Misc: Docstring to indicate usage prefers <code>node_name</code> to <code>name</code>.</li> <li>Misc: Standardise testing fixtures.</li> </ul>"},{"location":"home/changelog/#fixed_2","title":"Fixed:","text":"<ul> <li>Misc: Polars set up to work on laptop with M1 chip.</li> <li>Misc: Indentation in documentation.</li> <li>Tree Export: Mermaid diagram title to add newline.</li> <li>Tree Export: Polars unit test to work with old (&lt;=1.9.0) and new polars version.</li> <li>Tree Helper: Get tree diff string replacement bug when the path change is substring of another path.</li> </ul>"},{"location":"home/changelog/#0221-2024-11-03","title":"0.22.1 - 2024-11-03","text":""},{"location":"home/changelog/#added_7","title":"Added:","text":"<ul> <li>Misc: Documentation to rely on jupyter notebook.</li> </ul>"},{"location":"home/changelog/#changed_7","title":"Changed:","text":"<ul> <li>Tree Export: Exporting to dot allow node_attr and edge_attr to modify node before retrieving node name.</li> <li>Misc: All code reference to node_name (immutable) instead of name (mutable).</li> </ul>"},{"location":"home/changelog/#0220-2024-11-03","title":"0.22.0 - 2024-11-03","text":""},{"location":"home/changelog/#added_8","title":"Added:","text":"<ul> <li>Tree Helper: Accept parameter <code>detail</code> to show the different types of shift e.g., moved / added / removed. By default it is false.</li> </ul>"},{"location":"home/changelog/#0213-2024-10-16","title":"0.21.3 - 2024-10-16","text":""},{"location":"home/changelog/#added_9","title":"Added:","text":"<ul> <li>Tree Node: Docstring indentation and additional information for Node creation.</li> <li>Misc: GitHub star diagram to README file.</li> </ul>"},{"location":"home/changelog/#changed_8","title":"Changed:","text":"<ul> <li>Tree Helper: Get tree diff to handle <code>sep</code> that are different for tree and other_tree, this will throw error now.</li> <li>Tree Helper: Get tree diff to handle <code>sep</code> that contains forbidden symbols, this will change the <code>sep</code> to a fallback sep.</li> <li>Tree Helper: Get tree diff to sort tree before returning the tree diff.</li> </ul>"},{"location":"home/changelog/#fixed_3","title":"Fixed:","text":"<ul> <li>[#306] Tree Helper: Get tree diff to handle <code>sep</code> that is different from default.</li> </ul>"},{"location":"home/changelog/#0212-2024-10-14","title":"0.21.2 - 2024-10-14","text":""},{"location":"home/changelog/#added_10","title":"Added:","text":"<ul> <li>Misc: Pull request template.</li> </ul>"},{"location":"home/changelog/#fixed_4","title":"Fixed:","text":"<ul> <li>Tree Helper: Subtree to inherit <code>sep</code> property from root node.</li> </ul>"},{"location":"home/changelog/#0211-2024-08-29","title":"0.21.1 - 2024-08-29","text":""},{"location":"home/changelog/#changed_9","title":"Changed:","text":"<ul> <li>Misc: Import module instead of functions, following Google Python Style Guide.</li> <li>Docs: Documentation of <code>plot_tree</code> in tree demonstration and installation instructions.</li> </ul>"},{"location":"home/changelog/#0210-2024-08-26","title":"0.21.0 - 2024-08-26","text":""},{"location":"home/changelog/#added_11","title":"Added:","text":"<ul> <li>Tree Plot: Plot tree using matplotlib library, added matplotlib as optional dependency.</li> <li>BaseNode: Add plot method.</li> </ul>"},{"location":"home/changelog/#changed_10","title":"Changed:","text":"<ul> <li>Misc: Rename assertion function.</li> <li>Misc: Optional dependencies imported as MagicMock</li> </ul>"},{"location":"home/changelog/#0201-2024-08-24","title":"0.20.1 - 2024-08-24","text":""},{"location":"home/changelog/#changed_11","title":"Changed:","text":"<ul> <li>Misc: Documentation update contributing instructions.</li> </ul>"},{"location":"home/changelog/#0200-2024-08-24","title":"0.20.0 - 2024-08-24","text":""},{"location":"home/changelog/#added_12","title":"Added:","text":"<ul> <li>[#285] Tree Exporter: <code>print_tree</code> and <code>hprint_tree</code> to accept keyword arguments for printing.</li> <li>Misc: Template for release notes.</li> </ul>"},{"location":"home/changelog/#changed_12","title":"Changed:","text":"<ul> <li>Misc: Enhanced template for issues (bugfix/feature release).</li> </ul>"},{"location":"home/changelog/#fixed_5","title":"Fixed:","text":"<ul> <li>Tree Exporter: <code>tree_to_mermaid</code> fix for root node to have node attribute.</li> </ul>"},{"location":"home/changelog/#0194-2024-08-15","title":"0.19.4 - 2024-08-15","text":""},{"location":"home/changelog/#changed_13","title":"Changed:","text":"<ul> <li>Docs: Clean CSS for playground.</li> <li>Misc: Refactor tests for <code>tree_to_mermaid</code>.</li> <li>Misc: Allow untyped calls in mypy type checking due to ImageFont.truetype call.</li> </ul>"},{"location":"home/changelog/#fixed_6","title":"Fixed:","text":"<ul> <li>Tree Exporter: <code>tree_to_mermaid</code> fix where the node attribute is added wrongly to the wrong node.</li> <li>Misc: Fix and update code examples in docstring.</li> <li>Misc: Fix test cases for pydot due to code upgrade.</li> </ul>"},{"location":"home/changelog/#0193-2024-07-09","title":"0.19.3 - 2024-07-09","text":""},{"location":"home/changelog/#fixed_7","title":"Fixed:","text":"<ul> <li>Docs: Update links in README and rtd docs.</li> </ul>"},{"location":"home/changelog/#0192-2024-06-28","title":"0.19.2 - 2024-06-28","text":""},{"location":"home/changelog/#added_13","title":"Added:","text":"<ul> <li>Docs: Add description and credits to playground.</li> <li>Misc: Add template for asking question in Discussions.</li> </ul>"},{"location":"home/changelog/#changed_14","title":"Changed:","text":"<ul> <li>Docs: Homepage to include links to playground, modify emoji location.</li> <li>Docs: Playground modify code and code snippet layout.</li> </ul>"},{"location":"home/changelog/#fixed_8","title":"Fixed:","text":"<ul> <li>Misc: Skip codecov github action for PR from other users.</li> </ul>"},{"location":"home/changelog/#0191-2024-06-26","title":"0.19.1 - 2024-06-26","text":""},{"location":"home/changelog/#changed_15","title":"Changed:","text":"<ul> <li>Docs: Add playground and glossary section to documentation.</li> </ul>"},{"location":"home/changelog/#0190-2024-06-15","title":"0.19.0 - 2024-06-15","text":""},{"location":"home/changelog/#changed_16","title":"Changed:","text":"<ul> <li>Tree Exporter: Print functions to accept custom style that is implemented as dataclass, this is a more  object-oriented way of parsing arguments. This affects functions <code>print_tree</code>, <code>yield_tree</code>, <code>hprint_tree</code>, and <code>hyield_tree</code>. The argument <code>custom_style</code> is deprecated, and argument <code>style</code> is used instead. This might not be backwards-compatible!</li> <li>Misc: Update docstrings to be more comprehensive for tree constructor and tree exporter.</li> <li>Misc: Update documentation badges and conda information.</li> </ul>"},{"location":"home/changelog/#0183-2024-06-05","title":"0.18.3 - 2024-06-05","text":""},{"location":"home/changelog/#changed_17","title":"Changed:","text":"<ul> <li>Binary Tree Constructor: Type hints to return more generic TypeVar for use with subclasses.</li> <li>DAG Constructor: Type hints to return more generic TypeVar for use with subclasses.</li> <li>[#247] Tree Construct: Type hints to return more generic TypeVar for use with subclasses.</li> <li>Tree Modifier: Type hints to return more generic TypeVar for use with subclasses.</li> <li>Misc: Documentation to include more contribution information and guidelines.</li> </ul>"},{"location":"home/changelog/#0182-2024-06-01","title":"0.18.2 - 2024-06-01","text":""},{"location":"home/changelog/#changed_18","title":"Changed:","text":"<ul> <li>Tree Search: Standardize handling of singular and plural search.</li> <li>Tree Search: Add <code>find_relative_path</code> that return a single node from search and rename existing <code>find_relative_path</code> to <code>find_relative_paths</code>. This might not be backwards-compatible!</li> </ul>"},{"location":"home/changelog/#0181-2024-05-30","title":"0.18.1 - 2024-05-30","text":""},{"location":"home/changelog/#changed_19","title":"Changed:","text":"<ul> <li>Misc: Remove support of Python 3.7 due to incompatibility with polars.</li> </ul>"},{"location":"home/changelog/#fixed_9","title":"Fixed:","text":"<ul> <li>Tree Constructor and Exporter: Error handling when user only partially download optional dependencies of pandas/polars.</li> </ul>"},{"location":"home/changelog/#0180-2024-05-28","title":"0.18.0 - 2024-05-28","text":""},{"location":"home/changelog/#added_14","title":"Added:","text":"<ul> <li>Tree Constructor: Polars method <code>polars_to_tree</code>, <code>polars_to_tree_by_relation</code>, <code>add_polars_to_tree_by_path</code>, and <code>add_polars_to_tree_by_name</code>.</li> <li>Tree Exporter: Polars method <code>tree_to_polars</code>.</li> </ul>"},{"location":"home/changelog/#fixed_10","title":"Fixed:","text":"<ul> <li>Misc: Documentation to update mkdocs-material version for social plugin.</li> <li>Misc: Update links in README.</li> <li>Misc: Fix mypy typing.</li> </ul>"},{"location":"home/changelog/#0172-2024-04-24","title":"0.17.2 - 2024-04-24","text":""},{"location":"home/changelog/#changed_20","title":"Changed:","text":"<ul> <li>DAG Constructor: <code>list_to_dag</code> and <code>dict_to_dag</code> does not rely on <code>dataframe_to_dag</code> as pandas dataframe operation is phased out.</li> </ul>"},{"location":"home/changelog/#fixed_11","title":"Fixed:","text":"<ul> <li>DAG Constructor: Handle cases where reserved keywords are part of attribute upon creation and throw error accordingly.</li> <li>[#224] Tree/DAG Constructor: Null checks to not interpret 0 as null, this affects <code>dataframe_to_tree_by_relation</code>, <code>add_dataframe_to_tree_by_path</code>, <code>add_dataframe_to_tree_by_name</code>, <code>dataframe_to_tree</code>, and <code>dataframe_to_dag</code>. This will also affect showing/printing of trees when <code>attr_omit_null</code> is set to True.</li> </ul>"},{"location":"home/changelog/#0171-2024-04-23","title":"0.17.1 - 2024-04-23","text":""},{"location":"home/changelog/#fixed_12","title":"Fixed","text":"<ul> <li>[#222] Tree Constructor: <code>dataframe_to_tree_by_relation</code> duplicate root node name error message to handle different data types.</li> <li>Misc: Update links in README.</li> </ul>"},{"location":"home/changelog/#0170-2024-04-04","title":"0.17.0 - 2024-04-04","text":""},{"location":"home/changelog/#added_15","title":"Added","text":"<ul> <li>Misc: Group tests for benchmark timings to compare the timings by multiplier more effectively.</li> </ul>"},{"location":"home/changelog/#changed_21","title":"Changed","text":"<ul> <li>Tree Constructor: <code>add_dict_to_tree_by_name</code> and <code>add_dataframe_to_tree_by_name</code> modifies tree in-place instead of returning new tree, and does not accept <code>join_type</code> as argument as pandas dataframe operation is phased out. If there are clashing attributes, only those that have values will be replaced. This might not be backwards-compatible!</li> <li>Tree Constructor: <code>dataframe_to_tree</code> no longer relies on <code>add_dataframe_to_tree_by_path</code> as it performs assertion checks twice. This leads to 5% improvement in timings for a tree with 10000 nodes, averaged across 10 runs.</li> <li>Misc: Abstract out assertion checks for empty dataframe and duplicate attribute.</li> <li>Misc: Abstract out logic for checking null and filtering attributes.</li> <li>Misc: Optimisation in dictionary and dataframe operations.</li> </ul>"},{"location":"home/changelog/#fixed_13","title":"Fixed","text":"<ul> <li>Tree Constructor: <code>dict_to_tree</code> no longer uses dataframe operations, leading to 33% improvement in timings for a tree with 10000 nodes, averaged across 10 runs. The resulting data type of node follows the dictionary exactly, compared to the previous dataframe operations that may change the dtypes for certain columns. This might not be backwards-compatible!</li> <li>Tree Constructor: <code>dataframe_to_tree_by_relation</code> fix root node detection logic, ignore existing name column, ignore non-attribute columns, ignore null attribute columns.</li> <li>Tree Constructor: <code>add_dataframe_to_tree_by_path</code> ignore existing name column, ignore non-attribute columns, ignore null attribute columns.</li> <li>Tree Constructor: <code>add_dataframe_to_tree_by_name</code> ignore existing name column, ignore non-attribute columns, ignore null attribute columns.</li> <li>Tree Constructor: <code>dataframe_to_tree</code> ignore existing name column, ignore non-attribute columns, ignore null attribute columns.</li> <li>DAG Constructor: <code>dataframe_to_dag</code> ignore existing name column, ignore non-attribute columns, ignore null attribute columns.</li> </ul>"},{"location":"home/changelog/#0164-2024-03-14","title":"0.16.4 - 2024-03-14","text":""},{"location":"home/changelog/#fixed_14","title":"Fixed","text":"<ul> <li>[#216] Tree Exporter: Fix nan checker when printing trees.</li> </ul>"},{"location":"home/changelog/#0163-2024-03-14","title":"0.16.3 - 2024-03-14","text":""},{"location":"home/changelog/#added_16","title":"Added","text":"<ul> <li>BaseNode: Add diameter property.</li> <li>Misc: Tests to include benchmark timings for tree creation, compare benchmark tests across commits, reject pull request if benchmark tests fails.</li> <li>Misc: Documentation to include benchmark results.</li> </ul>"},{"location":"home/changelog/#changed_22","title":"Changed","text":"<ul> <li>Misc: Documentation to enable zooming in of images, add navigation section headers, remove some meta tags.</li> <li>Misc: Split up testing into multiple conftest files.</li> </ul>"},{"location":"home/changelog/#fixed_15","title":"Fixed","text":"<ul> <li>Tree Constructor: Tree creation from dictionary adds None for empty attributes instead of np.nan.</li> <li>[#216] Tree Exporter: <code>attr_omit_null</code> to handle nan/null values in addition to checking for None.</li> </ul>"},{"location":"home/changelog/#0162-2024-02-06","title":"0.16.2 - 2024-02-06","text":""},{"location":"home/changelog/#added_17","title":"Added","text":"<ul> <li>Misc: Documentation plugin Termynal for code animation.</li> <li>Misc: Usage of <code>docstr-coverage</code>.</li> <li>Misc: Docstrings for nested functions to pass <code>docstr-coverage</code>.</li> </ul>"},{"location":"home/changelog/#changed_23","title":"Changed","text":"<ul> <li>[#185] BaseNode: Make assertion checks optional.</li> <li>Misc: Documentation CSS for h1 display for windows compatibility, modify the related links on main page.</li> </ul>"},{"location":"home/changelog/#0161-2024-01-29","title":"0.16.1 - 2024-01-29","text":""},{"location":"home/changelog/#fixed_16","title":"Fixed","text":"<ul> <li>Misc: Compatibility of mkdocs with readthedocs.</li> </ul>"},{"location":"home/changelog/#0160-2024-01-28","title":"0.16.0 - 2024-01-28","text":""},{"location":"home/changelog/#added_18","title":"Added","text":"<ul> <li>Misc: Documentation using mkdocs.</li> </ul>"},{"location":"home/changelog/#changed_24","title":"Changed","text":"<ul> <li>Misc: Markdown edit for README, CHANGELOG.</li> <li>Misc: Docstring to indicate Examples, to indicate exceptions for BaseNode and DAGNode, simplify code for tree modification.</li> </ul>"},{"location":"home/changelog/#fixed_17","title":"Fixed","text":"<ul> <li>Misc: Docstring bullet point alignment, images compatibility with markdown.</li> </ul>"},{"location":"home/changelog/#0157-2024-01-26","title":"0.15.7 - 2024-01-26","text":""},{"location":"home/changelog/#added_19","title":"Added","text":"<ul> <li>Misc: Sphinx documentation to support mermaid markdown images, reflect CHANGELOG section, add more emojis.</li> </ul>"},{"location":"home/changelog/#changed_25","title":"Changed","text":"<ul> <li>Misc: Update SEO image.</li> <li>Misc: Fix Sphinx documentation font size difference between web and mobile, include last updated date.</li> <li>Misc: Upgrade package versions in pre-commit hook.</li> </ul>"},{"location":"home/changelog/#fixed_18","title":"Fixed","text":"<ul> <li>Tree Exporter: <code>hprint_tree</code> and <code>hyield_tree</code> to be compatible with <code>BinaryNode</code> where child nodes can be None type.</li> </ul>"},{"location":"home/changelog/#0156-2024-01-20","title":"0.15.6 - 2024-01-20","text":""},{"location":"home/changelog/#added_20","title":"Added","text":"<ul> <li>DAGNode: Able to access and delete node children via name with square bracket accessor with <code>__getitem__</code> and <code>__delitem__</code> magic methods.</li> <li>DAGNode: Able to delete all children for a node.</li> <li>DAGNode: Able to check if node contains child node with <code>__contains__</code> magic method.</li> <li>DAGNode: Able to iterate the node to access children with <code>__iter__</code> magic method.</li> </ul>"},{"location":"home/changelog/#changed_26","title":"Changed","text":"<ul> <li>Tree Search: Modify type hints to include DAGNode for <code>find_children</code>, <code>find_child</code>, and <code>find_child_by_name</code>.</li> <li>Misc: Neater handling of strings for tests.</li> <li>Misc: Documentation enhancement to split README into multiple files.</li> <li>Misc: New Sphinx documentation theme.</li> </ul>"},{"location":"home/changelog/#0155-2024-01-17","title":"0.15.5 - 2024-01-17","text":""},{"location":"home/changelog/#changed_27","title":"Changed","text":"<ul> <li>Misc: Neater handling of strings for tests.</li> <li>Misc: Better examples for merging trees and weighted trees in Sphinx documentation.</li> <li>Misc: Fix links and introduce unreleased segment in CHANGELOG.</li> </ul>"},{"location":"home/changelog/#0154-2024-01-11","title":"0.15.4 - 2024-01-11","text":""},{"location":"home/changelog/#changed_28","title":"Changed","text":"<ul> <li>Tree Exporter: <code>hprint_tree</code> and <code>hyield_tree</code> to allow hiding names of intermediate node.</li> </ul>"},{"location":"home/changelog/#fixed_19","title":"Fixed","text":"<ul> <li>Tree Constructor: <code>newick_to_tree</code> to handle invalid closing and use of apostrophe.</li> <li>Tree Exporter: <code>tree_to_newick</code> to handle special characters by wrapping them in apostrophe.</li> </ul>"},{"location":"home/changelog/#0153-2024-01-08","title":"0.15.3 - 2024-01-08","text":""},{"location":"home/changelog/#added_21","title":"Added","text":"<ul> <li>Tree Helper: <code>get_subtree</code> method to retrieve subtree.</li> </ul>"},{"location":"home/changelog/#0152-2024-01-08","title":"0.15.2 - 2024-01-08","text":""},{"location":"home/changelog/#added_22","title":"Added","text":"<ul> <li>Tree Exporter: <code>hprint_tree</code> and <code>hyield_tree</code> to print and retrieve results for tree in horizontal orientation.</li> <li>Node: Add <code>hshow</code> method to print tree in horizontal orientation to console.</li> </ul>"},{"location":"home/changelog/#0151-2024-01-05","title":"0.15.1 - 2024-01-05","text":""},{"location":"home/changelog/#added_23","title":"Added","text":"<ul> <li>Tree Constructor: <code>newick_to_tree</code> to convert Newick notation to tree.</li> </ul>"},{"location":"home/changelog/#changed_29","title":"Changed","text":"<ul> <li>Tree Exporter: <code>tree_to_newick</code> to accept more parameters to parse length and attributes.</li> </ul>"},{"location":"home/changelog/#fixed_20","title":"Fixed","text":"<ul> <li>Misc: Automate doctest setup to use os operations instead of string operations.</li> </ul>"},{"location":"home/changelog/#0150-2024-01-02","title":"0.15.0 - 2024-01-02","text":""},{"location":"home/changelog/#added_24","title":"Added","text":"<ul> <li>Tree Exporter: Export to Newick notation with <code>tree_to_newick</code>.</li> </ul>"},{"location":"home/changelog/#changed_30","title":"Changed","text":"<ul> <li>Tree Helper: Pruning tree to support pruning of multiple paths (accepts list of string).</li> <li>Tree Helper: Pruning tree to support pruning of an exact path (i.e., remove descendants) with <code>exact</code> parameter, default is prune and keep descendants.</li> </ul>"},{"location":"home/changelog/#0148-2023-12-25","title":"0.14.8 - 2023-12-25","text":""},{"location":"home/changelog/#changed_31","title":"Changed","text":"<ul> <li>Tree Modifier: Enhance documentation examples.</li> <li>Workflow To Do App: Change import and export logic.</li> <li>Misc: Organize assets folder based on whether it originated from README, docstrings, or sphinx documentation.</li> <li>Misc: Rename functions in <code>plot.py</code> utils file for coverage report.</li> </ul>"},{"location":"home/changelog/#fixed_21","title":"Fixed","text":"<ul> <li>Misc: Fix doctests and automate doctest checks.</li> </ul>"},{"location":"home/changelog/#0147-2023-12-22","title":"0.14.7 - 2023-12-22","text":""},{"location":"home/changelog/#changed_32","title":"Changed","text":"<ul> <li>Tree Helper: Enhance <code>get_tree_diff</code> to compare tree attributes by taking in <code>attr_list</code> parameter, and indicates difference with <code>(~)</code>.</li> </ul>"},{"location":"home/changelog/#fixed_22","title":"Fixed","text":"<ul> <li>Tree Helper: <code>get_tree_diff</code> compare tree structure by considering all nodes (previously only consider leaf nodes).</li> </ul>"},{"location":"home/changelog/#0146-2023-12-14","title":"0.14.6 - 2023-12-14","text":""},{"location":"home/changelog/#added_25","title":"Added","text":"<ul> <li>Node: Able to access and delete node children via name with square bracket accessor with <code>__getitem__</code> and <code>__delitem__</code> magic methods.</li> <li>BaseNode/Node/BinaryNode: Able to add one or more children with <code>append</code> and <code>extend</code> methods.</li> <li>BaseNode/Node/BinaryNode: Able to check if node contains child node with <code>__contains__</code> magic method.</li> <li>BaseNode/Node/BinaryNode: Able to iterate the node to access children with <code>__iter__</code> magic method. Results in children setter to only accept list/tuple/set instead of iterable types.</li> </ul>"},{"location":"home/changelog/#changed_33","title":"Changed","text":"<ul> <li>Tree Exporter: <code>tree_to_dot</code> accepts callable to set node and edge attrs for custom node (backward-compatible).</li> <li>Tree Exporter: <code>tree_to_mermaid</code> accepts callable to set node shape attr, edge arrow attr and node attr for custom node (backward-compatible).</li> <li>Tree Exporter: Change delimiter for <code>tree_to_mermaid</code> to prevent possible path confusion (backward-compatible).</li> <li>Misc: Code abstraction for assertion checks and constants.</li> <li>Misc: Documentation for exporting tree/dag to dot.</li> </ul>"},{"location":"home/changelog/#0145-2023-11-24","title":"0.14.5 - 2023-11-24","text":""},{"location":"home/changelog/#changed_34","title":"Changed","text":"<ul> <li>Misc: Update SECURITY file.</li> <li>Misc: Enhance documentation to add more emoji and highlight code blocks.</li> </ul>"},{"location":"home/changelog/#0144-2023-11-04","title":"0.14.4 - 2023-11-04","text":""},{"location":"home/changelog/#changed_35","title":"Changed","text":"<ul> <li>Misc: Clean up github actions.</li> </ul>"},{"location":"home/changelog/#0143-2023-10-31","title":"0.14.3 - 2023-10-31","text":""},{"location":"home/changelog/#added_26","title":"Added","text":"<ul> <li>Misc: Publish to conda, enable automated publishing to conda-forge in addition to existing PyPI.</li> <li>Misc: Tree demonstration code for <code>shift_and_replace_nodes</code> and <code>copy_and_replace_nodes_from_tree_to_tree</code> in README.</li> </ul>"},{"location":"home/changelog/#0142-2023-10-21","title":"0.14.2 - 2023-10-21","text":""},{"location":"home/changelog/#added_27","title":"Added","text":"<ul> <li>Misc: RTD integration.</li> <li>Misc: Enable manual publishing of python package.</li> </ul>"},{"location":"home/changelog/#0141-2023-10-18","title":"0.14.1 - 2023-10-18","text":""},{"location":"home/changelog/#added_28","title":"Added","text":"<ul> <li>Misc: Change main branch checks if the latest version exists (using git tag) before publishing package and building documentation.</li> </ul>"},{"location":"home/changelog/#0140-2023-10-18","title":"0.14.0 - 2023-10-18","text":""},{"location":"home/changelog/#added_29","title":"Added","text":"<ul> <li>Tree Modifier: Shift nodes with replacement of to-node with <code>shift_and_replace_nodes</code>.</li> <li>Tree Modifier: Copy nodes from tree to tree with replacement of to-node with <code>copy_and_replace_nodes_from_tree_to_tree</code>.</li> <li>Tree Modifier: Any permutation of configuration with replacement of to-node with <code>replace_logic</code>.</li> <li>Tree Modifier: Add relevant test cases and documentations accordingly.</li> </ul>"},{"location":"home/changelog/#0133-2023-10-17","title":"0.13.3 - 2023-10-17","text":""},{"location":"home/changelog/#added_30","title":"Added","text":"<ul> <li>Misc: Add automatic release notes with content into GitHub workflow.</li> </ul>"},{"location":"home/changelog/#0132-2023-10-17","title":"0.13.2 - 2023-10-17","text":""},{"location":"home/changelog/#added_31","title":"Added","text":"<ul> <li>Misc: Add automatic release notes into GitHub workflow.</li> </ul>"},{"location":"home/changelog/#0131-2023-10-15","title":"0.13.1 - 2023-10-15","text":""},{"location":"home/changelog/#added_32","title":"Added","text":"<ul> <li>Misc: Add automatic comment on code coverage to pull requests into GitHub workflow.</li> <li>Misc: Add more checks into pre-commit.</li> </ul>"},{"location":"home/changelog/#0130-2023-09-29","title":"0.13.0 - 2023-09-29","text":""},{"location":"home/changelog/#added_33","title":"Added","text":"<ul> <li>Tree Exporter: Export tree to flowchart diagram in mermaid markdown format using <code>tree_to_mermaid</code>.</li> </ul>"},{"location":"home/changelog/#changed_36","title":"Changed","text":"<ul> <li>Tree Exporter: Relax type hinting using TypeVar for <code>clone_tree</code>.</li> <li>Tree Helper: Accept Iterable instead of List for custom_style attribute of <code>yield_tree</code> and <code>print_tree</code>.</li> <li>Misc: Fix docstring for better presentation of code vs variable vs normal text.</li> </ul>"},{"location":"home/changelog/#0125-2023-09-26","title":"0.12.5 - 2023-09-26","text":""},{"location":"home/changelog/#added_34","title":"Added","text":"<ul> <li>Utility Groot: Add test cases.</li> </ul>"},{"location":"home/changelog/#fixed_23","title":"Fixed","text":"<ul> <li>Tree Exporter: <code>tree_to_pillow</code> function to reference online font file instead of relative path.</li> </ul>"},{"location":"home/changelog/#0124-2023-09-25","title":"0.12.4 - 2023-09-25","text":""},{"location":"home/changelog/#added_35","title":"Added","text":"<ul> <li>Utility Groot: Add groot utility functions.</li> </ul>"},{"location":"home/changelog/#0123-2023-09-17","title":"0.12.3 - 2023-09-17","text":""},{"location":"home/changelog/#changed_37","title":"Changed","text":"<ul> <li>Clearer documentation, fix docstring phrasing and spelling.</li> <li>Clearer error messages, standardize error messages.</li> </ul>"},{"location":"home/changelog/#0122-2023-09-12","title":"0.12.2 - 2023-09-12","text":""},{"location":"home/changelog/#changed_38","title":"Changed","text":"<ul> <li>Tree Plot: Reingold Tilford Algorithm code for succinctness and docstring.</li> </ul>"},{"location":"home/changelog/#0121-2023-09-11","title":"0.12.1 - 2023-09-11","text":""},{"location":"home/changelog/#fixed_24","title":"Fixed","text":"<ul> <li>Tree Plot: Reingold Tilford Algorithm to handle cases of negative x-coordinates with adjustment parameter.</li> </ul>"},{"location":"home/changelog/#0120-2023-09-09","title":"0.12.0 - 2023-09-09","text":""},{"location":"home/changelog/#changed_39","title":"Changed","text":"<ul> <li>Tree/DAG Constructor, Tree/DAG Exporter: Make <code>pandas</code> optional dependency.</li> </ul>"},{"location":"home/changelog/#fixed_25","title":"Fixed","text":"<ul> <li>Misc: Fix Calendar workflow to throw error when <code>to_dataframe</code> method is called on empty calendar.</li> <li>Tree/DAGNode Exporter, Tree Helper, Tree Search: Relax type hinting using TypeVar.</li> </ul>"},{"location":"home/changelog/#0110-2023-09-08","title":"0.11.0 - 2023-09-08","text":""},{"location":"home/changelog/#added_36","title":"Added","text":"<ul> <li>Tree Helper: <code>prune_tree</code> to allow pruning by <code>prune_path</code> and <code>max_depth</code>.</li> <li>Tree Plot: Implement Enhanced Reingold Tilford Algorithm to retrieve (x, y) coordinates for a tree structure.</li> </ul>"},{"location":"home/changelog/#changed_40","title":"Changed","text":"<ul> <li>BaseNode/DAGNode: <code>get_attr</code> method to allow default return value.</li> </ul>"},{"location":"home/changelog/#fixed_26","title":"Fixed","text":"<ul> <li>Utility Iterator: Relax type hinting using TypeVar.</li> </ul>"},{"location":"home/changelog/#0103-2023-08-12","title":"0.10.3 - 2023-08-12","text":""},{"location":"home/changelog/#added_37","title":"Added","text":"<ul> <li>Tree Constructor: <code>add_path_to_tree</code>, <code>dataframe_to_tree</code>, <code>dataframe_to_tree_by_relation</code> to allow custom node types that takes in constructor arguments.</li> </ul>"},{"location":"home/changelog/#changed_41","title":"Changed","text":"<ul> <li>Binary Tree: Able to accept node val of <code>str</code> type besides <code>int</code> type.</li> </ul>"},{"location":"home/changelog/#0102-2023-08-11","title":"0.10.2 - 2023-08-11","text":""},{"location":"home/changelog/#fixed_27","title":"Fixed","text":"<ul> <li>Tree Constructor: <code>nested_dict_to_tree</code> to throw TypeError if child_key is not list type.</li> </ul>"},{"location":"home/changelog/#0101-2023-07-27","title":"0.10.1 - 2023-07-27","text":""},{"location":"home/changelog/#added_38","title":"Added","text":"<ul> <li>[#71] Node: <code>path_name</code> to allow different node name of different dtypes; map everything to string type.</li> </ul>"},{"location":"home/changelog/#0100-2023-07-15","title":"0.10.0 - 2023-07-15","text":""},{"location":"home/changelog/#added_39","title":"Added","text":"<ul> <li>[#65] Tree Search: Implement <code>find_relative_path</code> to find relative path from node.</li> <li>[#65] Utility Iterator: Implement <code>zigzag_iter</code> and <code>zigzaggroup_iter</code> Tree traversal methods.</li> </ul>"},{"location":"home/changelog/#095-2023-07-13","title":"0.9.5 - 2023-07-13","text":""},{"location":"home/changelog/#added_40","title":"Added","text":"<ul> <li>Misc: Add init files, add link to discussions to README and pyproject, add sphinx coverage shortcuts.</li> </ul>"},{"location":"home/changelog/#fixed_28","title":"Fixed","text":"<ul> <li>[#66] DAGNode/Node: Children constructor to allow Iterable types, fix issue of lists being mutable.</li> <li>[#67] Node: <code>path_name</code> to reduce number of recursive calls to root node for <code>sep</code>.</li> </ul>"},{"location":"home/changelog/#094-2023-06-18","title":"0.9.4 - 2023-06-18","text":""},{"location":"home/changelog/#added_41","title":"Added","text":"<ul> <li>Tree Constructor: <code>list_to_tree_by_relation</code> and <code>dataframe_to_tree_by_relation</code> method to allow duplicate intermediate nodes (default is false).</li> <li>DAG Exporter: Add <code>node_shape</code> parameter in <code>dag_to_dot</code> export function for easier way to customize node shape.</li> <li>Misc: More test cases.</li> <li>Misc: Add security instructions on how to raise vulnerabilities.</li> <li>Misc: Add Calendar workflow to documentation.</li> </ul>"},{"location":"home/changelog/#changed_42","title":"Changed","text":"<ul> <li>Tree Constructor: <code>add_dict_to_tree_by_name</code> method rename argument from <code>path_attrs</code> to <code>name_attrs</code>.</li> <li>Misc: Modify contributing instructions.</li> </ul>"},{"location":"home/changelog/#fixed_29","title":"Fixed","text":"<ul> <li>Tree Exporter: <code>tree_to_dot</code> to handle cases when not all nodes have <code>edge_attr</code>.</li> <li>DAG Exporter: <code>dag_to_dot</code> to perform dictionary copy to prevent style from being overridden for child nodes.</li> <li>Tree Constructor: <code>dataframe_to_tree</code> to handle case when path column is not the first column.</li> </ul>"},{"location":"home/changelog/#093-2023-05-28","title":"0.9.3 - 2023-05-28","text":""},{"location":"home/changelog/#changed_43","title":"Changed","text":"<ul> <li>Tree Constructor: Relax type hint to <code>Iterable</code> instead of <code>List</code> for <code>list_to_tree</code> and <code>list_to_tree_by_relation</code> methods.</li> </ul>"},{"location":"home/changelog/#fixed_30","title":"Fixed","text":"<ul> <li>Node: Fix error message when trees have different <code>sep</code>.</li> </ul>"},{"location":"home/changelog/#092-2023-04-09","title":"0.9.2 - 2023-04-09","text":""},{"location":"home/changelog/#added_42","title":"Added","text":"<ul> <li>Node: Add <code>show</code> method to print tree to console.</li> <li>Workflow Calendar: Tree use case with calendar implementation.</li> </ul>"},{"location":"home/changelog/#091-2023-03-30","title":"0.9.1 - 2023-03-30","text":""},{"location":"home/changelog/#changed_44","title":"Changed","text":"<ul> <li>Node: Add <code>sep</code> parameter to constructor instead of using getter and setter methods to set <code>sep</code>.</li> </ul>"},{"location":"home/changelog/#090-2023-03-29","title":"0.9.0 - 2023-03-29","text":""},{"location":"home/changelog/#added_43","title":"Added","text":"<ul> <li>Tree Modifier: Ability to copy/shift nodes with full path in <code>from_paths</code> for faster search performance, add <code>with_full_path</code> parameter.</li> </ul>"},{"location":"home/changelog/#changed_45","title":"Changed","text":"<ul> <li>Tree Modifier: Enforce paths in <code>to_paths</code> to be full path for faster search performance.</li> <li>Tree Modifier: Faster creation of intermediate parent nodes in <code>to_paths</code>.</li> <li>Tree Modifier: Better handling of <code>sep</code> in paths by performing string replacement at the start.</li> <li>Tree Modifier: Check and throw error for invalid parameters, case when node is meant to be deleted but <code>copy=True</code>.</li> </ul>"},{"location":"home/changelog/#fixed_31","title":"Fixed","text":"<ul> <li>Tree Modifier: Fix issue trailing <code>sep</code> differing in <code>from_paths</code> and <code>to_paths</code> which should not throw error.</li> </ul>"},{"location":"home/changelog/#084-2023-03-24","title":"0.8.4 - 2023-03-24","text":""},{"location":"home/changelog/#added_44","title":"Added","text":"<ul> <li>Tree Search: Implement <code>find_child</code> and <code>find_children</code> to find single child or multiple children based on user-defined condition.</li> </ul>"},{"location":"home/changelog/#changed_46","title":"Changed","text":"<ul> <li>Tree and DAG Constructor: Reduce reliance on <code>numpy</code> package, only reject <code>None</code> attributes when creating tree from DataFrame (previously it rejects <code>[None]</code>).</li> <li>Tree Helper: Get difference between two trees reduce reliance on <code>numpy</code> package, enhance test cases.</li> <li>Tree Search: Rename <code>find_children</code> to <code>find_child_by_name</code> for clarity.</li> <li>Misc: Fix README for Windows installation.</li> </ul>"},{"location":"home/changelog/#083-2023-03-16","title":"0.8.3 - 2023-03-16","text":""},{"location":"home/changelog/#changed_47","title":"Changed","text":"<ul> <li>Workflow: Misc refactor and update log statements.</li> <li>Misc: Fix coverage report.</li> </ul>"},{"location":"home/changelog/#082-2023-03-16","title":"0.8.2 - 2023-03-16","text":""},{"location":"home/changelog/#changed_48","title":"Changed","text":"<ul> <li>Misc: Type checking to remove optional requirement for <code>mypy</code>.</li> <li>Misc: Shift .flake8, .mypy.ini, and pytest.ini files to pyproject.toml.</li> </ul>"},{"location":"home/changelog/#081-2023-03-10","title":"0.8.1 - 2023-03-10","text":""},{"location":"home/changelog/#fixed_32","title":"Fixed","text":"<ul> <li>Tree Modifier: Fix issue of <code>sep</code> of tree differing from the <code>sep</code> in <code>from_paths</code> and <code>to_paths</code>.</li> </ul>"},{"location":"home/changelog/#080-2023-03-10","title":"0.8.0 - 2023-03-10","text":""},{"location":"home/changelog/#added_45","title":"Added","text":"<ul> <li>Misc: Type checking with <code>mypy</code>, add type checks to pre-commit hooks.</li> </ul>"},{"location":"home/changelog/#changed_49","title":"Changed","text":"<ul> <li>DAGNode: <code>go_to</code> method to be consistent with <code>List[List[DAGNode]]</code> type.</li> </ul>"},{"location":"home/changelog/#fixed_33","title":"Fixed","text":"<ul> <li>Tree Exporter: Exception handling in <code>yield_tree</code> if <code>node_name_or_path</code> is not found.</li> <li>Workflow: Exception handling in prioritizing item/list if item/list is not the correct tree depth.</li> <li>Workflow: Exception handling in removing item/list if item/list is not found.</li> </ul>"},{"location":"home/changelog/#074-2023-02-27","title":"0.7.4 - 2023-02-27","text":""},{"location":"home/changelog/#fixed_34","title":"Fixed","text":"<ul> <li>Tree Constructor: Fix pandas SettingwithCopyWarning when performing dataframe operations.</li> </ul>"},{"location":"home/changelog/#073-2023-02-25","title":"0.7.3 - 2023-02-25","text":""},{"location":"home/changelog/#added_46","title":"Added","text":"<ul> <li>Tree Exporter: Fix <code>print_tree</code> checking attributes with <code>hasattr</code> to handle cases of null or 0 value attributes, add more test cases.</li> <li>Misc: Add more description to Contributing.</li> </ul>"},{"location":"home/changelog/#072-2023-02-18","title":"0.7.2 - 2023-02-18","text":""},{"location":"home/changelog/#added_47","title":"Added","text":"<ul> <li>Tree Exporter: Add <code>node_shape</code> parameter in <code>tree_to_dot</code> export function for easier way to customize node shape.</li> </ul>"},{"location":"home/changelog/#071-2023-02-18","title":"0.7.1 - 2023-02-18","text":""},{"location":"home/changelog/#added_48","title":"Added","text":"<ul> <li>BaseNode/Node: Add <code>go_to</code> BaseNode method to travel from one node to another node from the same tree.</li> <li>DAGNode: Add <code>go_to</code> DAGNode method to travel from one node to another node from the same DAG.</li> </ul>"},{"location":"home/changelog/#070-2023-02-18","title":"0.7.0 - 2023-02-18","text":""},{"location":"home/changelog/#added_49","title":"Added","text":"<ul> <li>Tree Modifier: Accept <code>merge_leaves</code> type of modification, enhance documentation to provide more examples and illustrations.</li> </ul>"},{"location":"home/changelog/#0610-2023-01-23","title":"0.6.10 - 2023-01-23","text":""},{"location":"home/changelog/#fixed_35","title":"Fixed","text":"<ul> <li>Tree Constructor: <code>str_to_tree</code> accept prefixes to support unicode characters in node names.</li> </ul>"},{"location":"home/changelog/#069-2023-01-22","title":"0.6.9 - 2023-01-22","text":""},{"location":"home/changelog/#added_50","title":"Added","text":"<ul> <li>Tree Construct: <code>str_to_tree</code> to construct tree from tree string.</li> </ul>"},{"location":"home/changelog/#068-2023-01-14","title":"0.6.8 - 2023-01-14","text":""},{"location":"home/changelog/#fixed_36","title":"Fixed","text":"<ul> <li>Tree Exporter: <code>tree_to_dot</code> to perform dictionary copy to prevent style from being overridden for child nodes.</li> </ul>"},{"location":"home/changelog/#067-2023-01-09","title":"0.6.7 - 2023-01-09","text":""},{"location":"home/changelog/#changed_50","title":"Changed","text":"<ul> <li>Binary Tree: Change <code>BNode</code> to <code>BinaryNode</code>, and construct method <code>list_to_btree</code> to <code>list_to_binarytree</code>.</li> </ul>"},{"location":"home/changelog/#066-2022-12-15","title":"0.6.6 - 2022-12-15","text":""},{"location":"home/changelog/#added_51","title":"Added","text":"<ul> <li>Tree Exporter: Export <code>print_tree</code> output to image using Pillow package.</li> </ul>"},{"location":"home/changelog/#065-2022-12-07","title":"0.6.5 - 2022-12-07","text":""},{"location":"home/changelog/#added_52","title":"Added","text":"<ul> <li>Tree Modifier: Shift/copy nodes able to shift node-only and delete the children (backwards-compatible).</li> </ul>"},{"location":"home/changelog/#064-2022-11-16","title":"0.6.4 - 2022-11-16","text":""},{"location":"home/changelog/#fixed_37","title":"Fixed","text":"<ul> <li>BNode: Minor fix on rollback functionality when original children includes None.</li> </ul>"},{"location":"home/changelog/#063-2022-11-15","title":"0.6.3 - 2022-11-15","text":""},{"location":"home/changelog/#added_53","title":"Added","text":"<ul> <li>DAGNode: Rollback functionality to original state when there is error setting parent and children (backwards-compatible).</li> </ul>"},{"location":"home/changelog/#changed_51","title":"Changed","text":"<ul> <li>BaseNode, BNode, DAGNode: Refactor by abstracting checks.</li> </ul>"},{"location":"home/changelog/#fixed_38","title":"Fixed","text":"<ul> <li>BaseNode: Fix rollback logic to handle failure in pre-assign checks and reassigning same child / parent.</li> <li>BNode: Fix issue of reassigning children shifting existing child from right to left.</li> </ul>"},{"location":"home/changelog/#062-2022-11-15","title":"0.6.2 - 2022-11-15","text":""},{"location":"home/changelog/#changed_52","title":"Changed","text":"<ul> <li>Tree Modifier: Shorter logging messages.</li> </ul>"},{"location":"home/changelog/#061-2022-11-14","title":"0.6.1 - 2022-11-14","text":""},{"location":"home/changelog/#changed_53","title":"Changed","text":"<ul> <li>Tree Modifier: Handle shifting/copying that removes intermediate layer (backwards-compatible).</li> </ul>"},{"location":"home/changelog/#060-2022-11-13","title":"0.6.0 - 2022-11-13","text":""},{"location":"home/changelog/#added_54","title":"Added","text":"<ul> <li>BaseNode: Rollback functionality to original state when there is error setting parent and children (backwards-compatible).</li> <li>BaseNode and DAGNode: Type hints.</li> <li>BNode: Node class for Binary Tree.</li> <li>BTree Constructor: From list.</li> <li>BNode Iterator: Level-Order Iterator.</li> <li>Misc: Add Tips and Tricks to documentation (List Directory).</li> </ul>"},{"location":"home/changelog/#fixed_39","title":"Fixed","text":"<ul> <li>DAGNode: Fix issue of duplicate parent constructor creating duplicate children.</li> </ul>"},{"location":"home/changelog/#055-2022-11-12","title":"0.5.5 - 2022-11-12","text":""},{"location":"home/changelog/#added_55","title":"Added","text":"<ul> <li>Misc: More docstring examples.</li> <li>Misc: More test cases.</li> </ul>"},{"location":"home/changelog/#fixed_40","title":"Fixed","text":"<ul> <li>Tree Modifier: Fix issue with <code>merge_children</code> argument not working as expected.</li> </ul>"},{"location":"home/changelog/#054-2022-11-12","title":"0.5.4 - 2022-11-12","text":""},{"location":"home/changelog/#added_56","title":"Added","text":"<ul> <li>BaseNode: Add sort() to sort children.</li> <li>Node: Make class more extendable with pre-/post-assign checks.</li> <li>Misc: Add Tips and Tricks to documentation (Extending Nodes).</li> <li>Misc: More test cases.</li> </ul>"},{"location":"home/changelog/#fixed_41","title":"Fixed","text":"<ul> <li>Tree Search: Type hints.</li> </ul>"},{"location":"home/changelog/#053-2022-11-11","title":"0.5.3 - 2022-11-11","text":""},{"location":"home/changelog/#added_57","title":"Added","text":"<ul> <li>DAG and Tree Exporter: More customisations allowed on edges.</li> <li>Misc: Add Tips and Tricks to documentation (Weighted Trees, Merging Trees).</li> </ul>"},{"location":"home/changelog/#fixed_42","title":"Fixed","text":"<ul> <li>Tree Modifier: Fix issue with <code>merge_children</code> argument not working as expected.</li> </ul>"},{"location":"home/changelog/#052-2022-11-10","title":"0.5.2 - 2022-11-10","text":""},{"location":"home/changelog/#fixed_43","title":"Fixed","text":"<ul> <li>Tree Constructor: Fix issue <code>dataframe_to_tree_by_relation</code> unable to find parent node.</li> </ul>"},{"location":"home/changelog/#051-2022-11-09","title":"0.5.1 - 2022-11-09","text":""},{"location":"home/changelog/#added_58","title":"Added","text":"<ul> <li>Misc: Clean codes and documentation.</li> </ul>"},{"location":"home/changelog/#050-2022-11-09","title":"0.5.0 - 2022-11-09","text":""},{"location":"home/changelog/#added_59","title":"Added","text":"<ul> <li>Misc: Clean codes and documentation.</li> </ul>"},{"location":"home/changelog/#changed_54","title":"Changed","text":"<ul> <li>Tree Exporter: Print tree to group multiple arguments together.</li> <li>DAG and Tree Exporter: Export to dot able to plot multiple disjointed trees/dags, rename <code>bgcolor</code> to <code>bg_colour</code>.</li> </ul>"},{"location":"home/changelog/#046-2022-11-09","title":"0.4.6 - 2022-11-09","text":""},{"location":"home/changelog/#added_60","title":"Added","text":"<ul> <li>Tree Constructor: From DataFrame of parent-child columns.</li> </ul>"},{"location":"home/changelog/#changed_55","title":"Changed","text":"<ul> <li>Tree Exporter: Print tree to define node name or path, and default to const style.</li> <li>Tree Constructor: Rename <code>list_to_tree_tuples</code> to <code>list_to_tree_by_relation</code>.</li> <li>Tree Constructor: Remove parameter <code>sep</code> for <code>nested_dict_to_tree</code>.</li> </ul>"},{"location":"home/changelog/#045-2022-11-08","title":"0.4.5 - 2022-11-08","text":""},{"location":"home/changelog/#changed_56","title":"Changed","text":"<ul> <li>Tree Exporter: Printing tree with added ability to omit null attributes.</li> </ul>"},{"location":"home/changelog/#044-2022-11-08","title":"0.4.4 - 2022-11-08","text":""},{"location":"home/changelog/#fixed_44","title":"Fixed","text":"<ul> <li>Tree Constructor: Handle adding attributes that are array-like - add array even when one of the items is null.</li> </ul>"},{"location":"home/changelog/#043-2022-11-08","title":"0.4.3 - 2022-11-08","text":""},{"location":"home/changelog/#added_61","title":"Added","text":"<ul> <li>Node: Print format for BaseNode.</li> </ul>"},{"location":"home/changelog/#042-2022-11-08","title":"0.4.2 - 2022-11-08","text":""},{"location":"home/changelog/#fixed_45","title":"Fixed","text":"<ul> <li>Tree Constructor: For list of tuples, handle cases where parent name is None.</li> </ul>"},{"location":"home/changelog/#041-2022-11-07","title":"0.4.1 - 2022-11-07","text":""},{"location":"home/changelog/#fixed_46","title":"Fixed","text":"<ul> <li>Tree Constructor: Handle adding attributes that are array-like - error in drop_duplicate() and pd.isnull().</li> </ul>"},{"location":"home/changelog/#040-2022-11-07","title":"0.4.0 - 2022-11-07","text":""},{"location":"home/changelog/#added_62","title":"Added","text":"<ul> <li>Tree Constructor: From list of tuples of parent-child.</li> </ul>"},{"location":"home/changelog/#033-2022-11-07","title":"0.3.3 - 2022-11-07","text":""},{"location":"home/changelog/#added_63","title":"Added","text":"<ul> <li>DAG Exporter: To list, nested dictionary, pandas DataFrame.</li> </ul>"},{"location":"home/changelog/#changed_57","title":"Changed","text":"<ul> <li>BaseNode and DAGNode: Modify docstring.</li> <li>Tree Exporter: Support Nodes with same name.</li> <li>Tree Modifier: Modify docstring.</li> <li>Utility Iterator: Modify docstring.</li> </ul>"},{"location":"home/changelog/#032-2022-11-07","title":"0.3.2 - 2022-11-07","text":""},{"location":"home/changelog/#fixed_47","title":"Fixed","text":"<ul> <li>Tree Exporter: Fix edge direction error.</li> </ul>"},{"location":"home/changelog/#031-2022-11-07","title":"0.3.1 - 2022-11-07","text":""},{"location":"home/changelog/#added_64","title":"Added","text":"<ul> <li>Tree and DAG Exporter: More customisations for Node to dot and DAGNode to dot.</li> </ul>"},{"location":"home/changelog/#030-2022-11-05","title":"0.3.0 - 2022-11-05","text":""},{"location":"home/changelog/#added_65","title":"Added","text":"<ul> <li>DAG Constructor: From list, nested dictionary, pandas DataFrame.</li> <li>Utility Iterator: DAG traversal methods.</li> </ul>"},{"location":"home/changelog/#changed_58","title":"Changed","text":"<ul> <li>Tree Exporter and DAG Exporter: More customisations for Node to dot and DAGNode to dot.</li> </ul>"},{"location":"home/changelog/#020-2022-11-03","title":"0.2.0 - 2022-11-03","text":""},{"location":"home/changelog/#added_66","title":"Added","text":"<ul> <li>Node: DAGNode for creating DAG graph.</li> <li>Tree Exporter: Support Node to dot which can export to png, svg, jpeg, dot files.</li> <li>DAG Exporter: Support DAGNode to dot.</li> </ul>"},{"location":"home/changelog/#010-2022-11-01","title":"0.1.0 - 2022-11-01","text":""},{"location":"home/changelog/#added_67","title":"Added","text":"<ul> <li>Node: Node and BaseNode.</li> <li>Tree Constructor: From list, nested dictionary, pandas DataFrame.</li> <li>Tree Exporter: To list, nested dictionary, pandas DataFrame.</li> <li>Tree Helper: Clone, prune trees, get difference between two trees.</li> <li>Tree Modifier: Shift and copy nodes within tree and between trees.</li> <li>Tree Search: Find single or multiple nodes based on name, attribute, or custom criteria.</li> <li>Utility Iterator: Tree traversal methods.</li> <li>Workflow To Do App: Tree use case with to-do list implementation.</li> </ul>"},{"location":"home/community/","title":"\ud83d\udc3e Community","text":"<p>There are many ways to contribute to bigtree</p> <ul> <li>Give bigtree a \ud83c\udf1f on GitHub</li> <li>Share your bigtree projects</li> <li>Contribute to bigtree open source libraries</li> <li>Support bigtree on buymeacoffee</li> </ul>"},{"location":"home/contributing/","title":"\ud83c\udf6a Contributing","text":"<p>bigtree is a tree implementation package for Python. It integrates with Python lists, dictionaries, pandas and polars DataFrame.</p> <p>Thank you for taking the time to contribute. Contributing to this package is an excellent opportunity to dive into tree implementations.</p>"},{"location":"home/contributing/#set-up","title":"Set Up","text":"<p>First, fork the repository and clone the forked repository.</p> <pre><code>$ git clone git@github.com:&lt;your-username&gt;/bigtree.git\n</code></pre> <p>Next, create a virtual environment and activate it.</p> condavenv <pre><code>$ conda create -n bigtree_venv python=3.10\n$ conda activate bigtree_venv\n</code></pre> <pre><code>$ python -m venv .venv\n$ source .venv/bin/activate\n</code></pre> <p>To check if it worked,</p> condavenv <pre><code>$ which pip\n/&lt;some directory&gt;/envs/bigtree_venv/bin/pip\n</code></pre> <pre><code>$ which pip\n/&lt;current directory&gt;/.venv/bin/pip\n</code></pre> <p>From the project folder, install the required python packages locally in editable mode and set up pre-commit checks.</p> <pre><code>$ python -m pip install -e \".[all]\"\n$ python -m pip install pre-commit\n$ pre-commit install\n</code></pre>"},{"location":"home/contributing/#developing","title":"Developing","text":"<p>After making your changes, create a new branch, add and commit your changed files. In this example, let's assume the changed file is <code>README.md</code>. If there are any pre-commit changes or comments, do modify, re-add and re-commit your files.</p> <pre><code>$ git checkout -b chore/update-readme\n$ git add README.md\n$ git commit -m \"chore: updated README\"\n</code></pre> <p>Push your changes to your created branch and create a pull request from your fork.</p> <pre><code>$ git push origin chore/update-readme\n</code></pre>"},{"location":"home/contributing/#testing","title":"Testing","text":"<p>If there are changes related to code, make sure to add or update the tests accordingly. Run the following lines of code and ensure the unit tests pass and the code coverage is 100%.</p> <pre><code>$ python -m pip install pytest pytest-benchmark pytest-cov coverage\n$ pytest --cov-report=term-missing --cov-config=pyproject.toml --cov=bigtree\n</code></pre>"},{"location":"home/contributing/#documentation","title":"Documentation","text":"<p>If there are changes related to code, make sure to add or update the documentations and docstrings accordingly.</p> <p>For documentation, <code>bigtree</code> uses mkdocs for documentation and previews can be viewed by running the following lines of code.</p> <pre><code>$ python -m pip install hatch\n$ hatch run mkdocs:build\n$ hatch run mkdocs:serve\n</code></pre> <p>For docstrings, ensure that the description is most updated and existing, added, or modified sample code examples in docstring still work. Run the following lines of code to generate the coverage report and test report for docstrings. Refer to the console log for information on the file location of the reports.</p> <pre><code>$ python -m pip install hatch\n$ hatch run docs:coverage\n$ hatch run docs:doctest\n</code></pre>"},{"location":"home/contributing/#consequent-changes","title":"Consequent Changes","text":"<p>Please open an issue to discuss important changes before embarking on an implementation.</p>"},{"location":"home/convention/","title":"\ud83d\udcac Convention and Standards","text":""},{"location":"home/convention/#git-workflow","title":"Git Workflow","text":"<p>When creating branches, it is recommended to create them in the format <code>type/action</code>. For example,</p> <pre><code>$ git checkout -b feat/add-this\n</code></pre> <p>This project enforces conventional commits when writing commit messages.</p> <ul> <li>The regex for conventional commits is as such <code>(?s)(build|ci|docs|feat|fix|perf|refactor|style|test|chore|revert|bump)(\\(\\S+\\))?!?:( [^\\n\\r]+)((\\n\\n.*)|(\\s*))?$</code>.</li> </ul>"},{"location":"home/convention/#code-style-and-format","title":"Code Style and Format","text":"<p>As much as possible, this project follows the Google Python Style Guide. During pre-commit checks, this project checks and formats code using <code>black</code>, <code>flake8</code>, <code>isort</code>, and <code>mypy</code>.</p>"},{"location":"home/convention/#testing","title":"Testing","text":"<p>For testing, this project uses <code>pytest</code> and <code>coverage</code> package for testing of codes, and <code>doctest</code> and <code>docstr-coverage</code> package for testing of docstrings.</p>"},{"location":"home/dag/","title":"\ud83c\udf34 Directed Acyclic Graph (DAG)","text":"<p>For Directed Acyclic Graph (DAG) implementation, there are 4 main components.</p>"},{"location":"home/dag/#node","title":"\ud83c\udf3c Node","text":"<ul> <li><code>DAGNode</code>, extendable class for constructing Directed Acyclic Graph (DAG)</li> </ul>"},{"location":"home/dag/#constructing-dag","title":"\u2728 Constructing DAG","text":"<ul> <li>From list, containing parent-child tuples</li> <li>From nested dictionary</li> <li>From pandas DataFrame</li> </ul>"},{"location":"home/dag/#traversing-dag","title":"\u27b0 Traversing DAG","text":"<ul> <li>Generic traversal method</li> </ul>"},{"location":"home/dag/#exporting-dag","title":"\ud83d\udd28 Exporting DAG","text":"<ul> <li>Export to list, dictionary, or pandas DataFrame</li> <li>Export DAG to dot (can save to .dot, .png, .svg, .jpeg files)</li> </ul>"},{"location":"home/install/","title":"\ud83d\udcbb Installation","text":"<p><code>bigtree</code> requires Python 3.8+. There are two ways to install <code>bigtree</code>, with pip (recommended) or conda.</p>"},{"location":"home/install/#installation-with-pip","title":"Installation with pip","text":""},{"location":"home/install/#basic-installation","title":"Basic Installation","text":"<p>To install <code>bigtree</code>, run the following line in command prompt:</p> pip install bigtreeInstalled"},{"location":"home/install/#installing-optional-dependencies","title":"Installing optional dependencies","text":"<p><code>bigtree</code> have a number of optional dependencies, which can be installed using \"extras\" syntax.</p> pip install 'bigtree[extra_1, extra_2]' <p>Examples of extra packages include:</p> <ul> <li><code>all</code>: include all optional dependencies</li> <li><code>image</code>: for exporting tree to image</li> <li><code>matplotlib</code>: for plotting trees</li> <li><code>pandas</code>: for pandas methods</li> <li><code>polars</code>: for polars methods</li> </ul> <p>For <code>image</code> extra dependency, you may need to install more plugins.</p> brew install gprof2dot  # for MacOSconda install graphviz  # for Windows"},{"location":"home/install/#installation-with-conda","title":"Installation with conda","text":"<p>To install <code>bigtree</code> with conda, run the following line in command prompt:</p> conda install -c conda-forge bigtree"},{"location":"home/tree/","title":"\ud83c\udf32 Tree","text":"<p>For Tree implementation, there are 9 main components.</p>"},{"location":"home/tree/#node","title":"\ud83c\udf3a Node","text":"<ul> <li><code>BaseNode</code>, extendable class</li> <li><code>Node</code>, BaseNode with node name attribute</li> </ul>"},{"location":"home/tree/#constructing-tree","title":"\u2728 Constructing Tree","text":"<ul> <li>From <code>Node</code>, using parent and children constructors</li> <li>From str, using tree display or Newick string notation</li> <li>From list, using paths or parent-child tuples</li> <li>From nested dictionary, using path-attribute key-value pairs or recursive structure</li> <li>From pandas DataFrame, using paths or parent-child columns</li> <li>From polars DataFrame, using paths or parent-child columns</li> <li>Add nodes to existing tree using path string</li> <li>Add nodes and attributes to existing tree using dictionary, pandas DataFrame, or polars DataFrame, using path</li> <li>Add only attributes to existing tree using dictionary, pandas DataFrame, or polars DataFrame, using node name</li> </ul>"},{"location":"home/tree/#traversing-tree","title":"\u27b0 Traversing Tree","text":"<ul> <li>Pre-Order Traversal</li> <li>Post-Order Traversal</li> <li>Level-Order Traversal</li> <li>Level-Order-Group Traversal</li> <li>ZigZag Traversal</li> <li>ZigZag-Group Traversal</li> </ul>"},{"location":"home/tree/#modifying-tree","title":"\ud83d\udcdd Modifying Tree","text":"<ul> <li>Copy nodes from location to destination</li> <li>Shift nodes from location to destination</li> <li>Shift and replace nodes from location to destination</li> <li>Copy nodes from one tree to another</li> <li>Copy and replace nodes from one tree to another</li> </ul>"},{"location":"home/tree/#tree-search","title":"\ud83d\udd0d Tree Search","text":"<ul> <li>Find multiple nodes based on name, partial path, relative path, attribute value, user-defined condition</li> <li>Find single nodes based on name, partial path, relative path, full path, attribute value, user-defined condition</li> <li>Find multiple child nodes based on user-defined condition</li> <li>Find single child node based on name, user-defined condition</li> </ul>"},{"location":"home/tree/#helper-function","title":"\ud83d\udd27 Helper Function","text":"<ul> <li>Cloning tree to another <code>Node</code> type</li> <li>Get subtree (smaller tree with different root)</li> <li>Prune tree (smaller tree with same root)</li> <li>Get difference between two trees</li> </ul>"},{"location":"home/tree/#plotting-tree","title":"\ud83d\udcca Plotting Tree","text":"<ul> <li>Enhanced Reingold Tilford Algorithm to retrieve (x, y) coordinates for a tree structure</li> <li>Plot tree using matplotlib (optional dependency)</li> </ul>"},{"location":"home/tree/#exporting-tree","title":"\ud83d\udd28 Exporting Tree","text":"<ul> <li>Print to console, in compact, vertical, or horizontal orientation</li> <li>Export to Newick string notation, dictionary, nested dictionary, pandas DataFrame, or polars DataFrame</li> <li>Export tree to dot (can save to .dot, .png, .svg, .jpeg files)</li> <li>Export tree to Pillow (can save to .png, .jpg)</li> <li>Export tree to Mermaid Flowchart (can display on .md)</li> </ul>"},{"location":"home/tree/#workflows","title":"\u2714\ufe0f Workflows","text":"<ul> <li>Sample workflows for tree demonstration!</li> </ul>"},{"location":"others/custom_coordinates/","title":"Trees with Custom Coordinates","text":"<p>Topic: export</p> <p>Trees can be plotted with <code>root.plot()</code> for a simple matplotlib. For more sophisticated plots, it is recommended to export the tree to dot (supports pydot, graphviz), mermaid, or pillow. To set your own x- and y- coordinates, this utilises and builds on top of the existing pydot package.</p> <p>There are 3 ways to get the x- and y- coordinates for each node</p> <ol> <li>Use reingold tilford function (fastest and easiest)</li> <li>Modify from the Reingold Tilford algorithm from (1)</li> <li>Use your custom coordinates</li> </ol> <p>Using these x- and y- coordinates, we can display it on a pydot plot using the <code>pos</code> node attribute. In the example below, we will make use of option (2) to generate our tree plot with custom coordinates.</p> <pre><code>from bigtree import Node, clone_tree, list_to_tree, reingold_tilford, tree_to_dot\n\n# Create tree\nroot = list_to_tree([\"a/b/d\", \"a/c\"])\n\n# Modify from the Reingold Tilford algorithm\nreingold_tilford(root)\n\n\nclass CoordinateNode(Node):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.y = 2 * self.y  # example\n\n\nroot_coordinate = clone_tree(root, CoordinateNode)\n\n\n# Export tree to dot (pydot)\ndef node_pos(_node):\n    return {\"pos\": f\"{_node.x},{_node.y}!\"}\n\n\ngraph = tree_to_dot(root_coordinate, node_attr=node_pos)\ngraph.write_png(\"assets/docs/coordinate_tree.png\", prog=\"neato\")\n</code></pre> <p></p>"},{"location":"others/list_dir/","title":"List Directory","text":"<p>Topic: construct</p> <p>To list directories recursively using bigtree, we can use the <code>glob</code> built-in Python package to extract a list of paths.</p> <pre><code>import glob\nfrom bigtree import list_to_tree, print_tree\n\n# Get all directories recursively\npath_list = []\nfor f in glob.glob(\"./**/*.py\", recursive=True):\n    path_list.append(f)\n\n# Construct tree\nroot = list_to_tree(path_list)\n\n# View tree\nprint_tree(root, max_depth=3)\n</code></pre>"},{"location":"others/merging_trees/","title":"Merging Trees","text":"<p>Topic: modify</p> <p>To merge two separate trees into one, we can use the tree modify module.</p> <p>In this example, we are merging two trees that have similar node <code>Pictures</code>. Children of node <code>Pictures</code> from both trees are retained as long as <code>merge_children=True</code> is set. If only children of the other tree are desired, set <code>overriding=True</code> instead.</p> <pre><code>from bigtree import copy_nodes_from_tree_to_tree, str_to_tree\n\n# Construct trees\ndownloads_folder = str_to_tree(\"\"\"\nDownloads\n\u251c\u2500\u2500 Pictures\n\u2502   \u2514\u2500\u2500 photo1.jpg\n\u2514\u2500\u2500 file1.doc\n\"\"\")\n\ndocuments_folder = str_to_tree(\"\"\"\nDocuments\n\u2514\u2500\u2500 Pictures\n    \u2514\u2500\u2500 photo2.jpg\n\"\"\")\n\n# Merge trees\ncopy_nodes_from_tree_to_tree(\n    from_tree=documents_folder,\n    to_tree=downloads_folder,\n    from_paths=[\"Documents/Pictures\"],\n    to_paths=[\"Downloads/Pictures\"],\n    merge_children=True,  # set overriding=True to override existing children\n)\n\n# Validate tree structure\ndownloads_folder.show()\n# Downloads\n# \u251c\u2500\u2500 Pictures\n# \u2502   \u251c\u2500\u2500 photo1.jpg\n# \u2502   \u2514\u2500\u2500 photo2.jpg\n# \u2514\u2500\u2500 file1.doc\n</code></pre>"},{"location":"others/nodes/","title":"Extending Nodes","text":"<p>Nodes can be extended from <code>BaseNode</code> or <code>Node</code> class to have extended functionalities or add pre-/post-assign checks.</p> <ul> <li>For example, <code>Node</code> class extends <code>BaseNode</code> and added the <code>name</code> functionality with pre-assign checks to ensure no duplicate path names.</li> </ul>"},{"location":"others/nodes/#population-node-add-functionalitymethodproperty","title":"Population Node (add functionality/method/property)","text":"<pre><code>from bigtree import Node, print_tree\n\n\nclass PopulationNode(Node):\n\n    def __init__(self, name: str, population: int = 0, **kwargs):\n        super().__init__(name, **kwargs)\n        self._population = population\n\n    @property\n    def population(self):\n        if self.is_leaf:\n            return self._population\n        return sum([child.population for child in self.children])\n\n    @property\n    def percentage(self):\n        if self.is_root:\n            return 1\n        return round(self.population / self.root.population, 2)\n\n\nroot = PopulationNode(\"World\")\nb1 = PopulationNode(\"Country A\", parent=root)\nc1 = PopulationNode(\"State A1\", 100, parent=b1)\nc2 = PopulationNode(\"State A2\", 50, parent=b1)\nb2 = PopulationNode(\"Country B\", 200, parent=root)\nb3 = PopulationNode(\"Country C\", 100, parent=root)\n\nprint_tree(root, attr_list=[\"population\", \"percentage\"])\n# World [population=450, percentage=1]\n# \u251c\u2500\u2500 Country A [population=150, percentage=0.33]\n# \u2502   \u251c\u2500\u2500 State A1 [population=100, percentage=0.22]\n# \u2502   \u2514\u2500\u2500 State A2 [population=50, percentage=0.11]\n# \u251c\u2500\u2500 Country B [population=200, percentage=0.44]\n# \u2514\u2500\u2500 Country C [population=100, percentage=0.22]\n</code></pre>"},{"location":"others/nodes/#read-only-node-add-pre-post-assign-checks","title":"Read-Only Node (add pre-/post-assign checks)","text":"<pre><code>import pytest\n\nfrom bigtree import Node\nfrom typing import List\n\n\nclass ReadOnlyNode(Node):\n\n    def __init__(self, *args, **kwargs):\n        self.__readonly = False\n        super().__init__(*args, **kwargs)\n        self.__readonly = True\n\n    def _Node__pre_assign_parent(self, new_parent: Node):\n        if self.__readonly:\n            raise RuntimeError(\"Nodes cannot be reassigned for ReadOnlyNode\")\n\n    def _Node__pre_assign_children(self, new_children: List[Node]):\n        if self.__readonly:\n            raise RuntimeError(\"Nodes cannot be reassigned for ReadOnlyNode\")\n\n\na = ReadOnlyNode(\"a\")\nb = ReadOnlyNode(\"b\", parent=a)\nc = ReadOnlyNode(\"c\", parent=a)\n\nwith pytest.raises(RuntimeError):\n    c.parent = b\n\nwith pytest.raises(RuntimeError):\n    a.children = [b, c]\n</code></pre>"},{"location":"others/remove_checks/","title":"Remove Tree Checks","text":"<p>Note</p> <p>Available from version 0.16.2 onwards</p> <p>When constructing trees, there are a few checks done that slow down performance. This slowness will be more apparent with very large trees. The checks are to</p> <ul> <li>Check parent/children data type</li> <li>Check for loops (expensive for trees that are deep as it checks the ancestors of node)</li> </ul> <p>These checks are enabled by default. To turn off these checks, you can set environment variable before importing <code>bigtree</code>.</p> <pre><code>import os\nos.environ[\"BIGTREE_CONF_ASSERTIONS\"] = \"\"\n\nimport bigtree\n</code></pre>"},{"location":"others/weighted_trees/","title":"Trees with Weighted Edges","text":"<p>Topic: export</p> <p>Edge weights should be defined in the child node for the parent-child edge since each node can only have one parent.</p> <p>We can simply add <code>weight</code> attribute to the <code>Node</code> class. However, if we want to visualize the weighted tree, we can create a <code>WeightedNode</code> class to generate the edge attribute dictionary.</p> <pre><code>from bigtree import Node, tree_to_dot\n\nclass WeightedNode(Node):\n    def __init__(self, name, weight=0, **kwargs):\n        super().__init__(name, **kwargs)\n        self.weight = weight\n\n    @property\n    def edge_attr(self):\n        \"\"\"Edge attribute for pydot diagram\n        Label for edge label, penwidth for edge width\n        \"\"\"\n        return {\"label\": self.weight, \"penwidth\": self.weight}\n\n# Construct weighted tree\nroot = WeightedNode(\"a\")\nb = WeightedNode(\"b\", parent=root, weight=1)\nc = WeightedNode(\"c\", parent=root, weight=2)\nd = WeightedNode(\"d\", parent=b, weight=3)\n\ngraph = tree_to_dot(root, node_colour=\"gold\", edge_attr=\"edge_attr\")\ngraph.write_png(\"assets/docs/weighted_tree.png\")\n</code></pre> <p></p>"},{"location":"others/work_with_classes/","title":"Working with Classes","text":"<p>Custom classes can be assigned to Node as <code>data</code> attribute, or any other attribute name.</p> <pre><code>from bigtree import Node\n\n\nclass Folder:\n    def __init__(self, name: str):\n        self.name = name\n\n    def __str__(self):\n         return f\"Folder&lt;{self.name}&gt;\"\n\nclass File:\n    def __init__(self, name: str):\n        self.name = name\n\n    def __str__(self):\n         return f\"File&lt;{self.name}&gt;\"\n\nfolder_documents = Node(\"My Documents\", data=Folder(\"Documents\"))\nfile_photo1 = Node(\"photo1.jpg\", data=File(\"photo.jpg\"))\nfile_photo2 = Node(\"photo2.jpg\", data=File(\"photo.jpg\"))\nfolder_documents.children = [file_photo1, file_photo2]\n\nfolder_documents.show()\n# My Documents\n# \u251c\u2500\u2500 photo1.jpg\n# \u2514\u2500\u2500 photo2.jpg\n\nfolder_documents.show(alias=\"data\")\n# Folder&lt;Documents&gt;\n# \u251c\u2500\u2500 File&lt;photo.jpg&gt;\n# \u2514\u2500\u2500 File&lt;photo.jpg&gt;\n</code></pre>"},{"location":"playground/","title":"\ud83c\udfa1\ufe0f Playground","text":"<p>This playground is pre-installed with <code>bigtree</code> and the Python standard libraries. Play around with the codes. Have fun!</p> <pre><code>&gt;&gt;&gt; from bigtree import list_to_tree\n&gt;&gt;&gt; root = list_to_tree([\"a/b\", \"a/c\", \"a/b/d\", \"a/b/e\", \"a/c/f\", \"a/b/e/g\", \"a/b/e/h\"])\n&gt;&gt;&gt; root.show()\na\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 d\n\u2502   \u2514\u2500\u2500 e\n\u2502       \u251c\u2500\u2500 g\n\u2502       \u2514\u2500\u2500 h\n\u2514\u2500\u2500 c\n    \u2514\u2500\u2500 f\n</code></pre>"}]}