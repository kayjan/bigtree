{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83c\udf33 Documentation","text":"<p>Tree Implementation and Methods for Python, integrated with Python list, dictionary, and pandas DataFrame.</p> <p>It is pythonic, making it easy to learn and extendable to many types of workflows.</p> <ul> <li> Set up in 2 minutes <p>Install <code>bigtree</code> with <code>pip</code> or <code>conda</code> and get up   and running in minutes</p> <p> Getting started</p> </li> </ul> <ul> <li> Getting started <p>View demonstration on how to use <code>bigtree</code></p> <p> Reference</p> </li> </ul> <p>Related Links:</p> <ul> <li>GitHub</li> <li>Community<ul> <li>Issues / Discussions / Changelog / Contributing</li> </ul> </li> <li>Package<ul> <li>PyPI / Conda</li> </ul> </li> <li>Articles<ul> <li>Python Tree Implementation with BigTree</li> <li>The Reingold Tilford Algorithm Explained, with Walkthrough</li> </ul> </li> <li><p>If you want to support bigtree, </p></li> </ul>"},{"location":"binarytree/","title":"\ud83c\udf35 Binary Tree","text":"<p>For Binary Tree implementation, there are 3 main components. Binary Node inherits from Node, so the components in Tree implementation are also available in Binary Tree.</p>"},{"location":"binarytree/#node","title":"\ud83c\udf3f Node","text":"<ul> <li><code>BinaryNode</code>, Node with binary tree rules</li> </ul>"},{"location":"binarytree/#constructing-binary-tree","title":"\u2728 Constructing Binary Tree","text":"<ul> <li>From list, using flattened list structure</li> </ul>"},{"location":"binarytree/#traversing-binary-tree","title":"\u27b0 Traversing Binary Tree","text":"<ul> <li>In-Order Traversal</li> </ul>"},{"location":"changelog/","title":"\ud83c\udf42 Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"Unreleased","text":""},{"location":"changelog/#0161-2023-01-29","title":"0.16.1 - 2023-01-29","text":""},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Misc: Compatibility of mkdocs with readthedocs.</li> </ul>"},{"location":"changelog/#0160-2023-01-28","title":"0.16.0 - 2023-01-28","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Misc: Documentation using mkdocs.</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Misc: Markdown edit for README, CHANGELOG.</li> <li>Misc: Docstring to indicate Examples, to indicate exceptions for BaseNode and DAGNode, simplify code for tree modification.</li> </ul>"},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Misc: Docstring bullet point alignment, images compatibility with markdown.</li> </ul>"},{"location":"changelog/#0157-2023-01-26","title":"0.15.7 - 2023-01-26","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Misc: Sphinx documentation to support mermaid markdown images, reflect CHANGELOG section, add more emojis.</li> </ul>"},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Misc: Update SEO image.</li> <li>Misc: Fix Sphinx documentation font size difference between web and mobile, include last updated date.</li> <li>Misc: Upgrade package versions in pre-commit hook.</li> </ul>"},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li>Tree Exporter: <code>hprint_tree</code> and <code>hyield_tree</code> to be compatible with <code>BinaryNode</code> where child nodes can be None type.</li> </ul>"},{"location":"changelog/#0156-2023-01-20","title":"0.15.6 - 2023-01-20","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>DAGNode: Able to access and delete node children via name with square bracket accessor with <code>__getitem__</code> and <code>__delitem__</code> magic methods.</li> <li>DAGNode: Able to delete all children for a node.</li> <li>DAGNode: Able to check if node contains child node with <code>__contains__</code> magic method.</li> <li>DAGNode: Able to iterate the node to access children with <code>__iter__</code> magic method.</li> </ul>"},{"location":"changelog/#changed_2","title":"Changed","text":"<ul> <li>Tree Search: Modify type hints to include DAGNode for <code>find_children</code>, <code>find_child</code>, and <code>find_child_by_name</code>.</li> <li>Misc: Neater handling of strings for tests.</li> <li>Misc: Documentation enhancement to split README into multiple files.</li> <li>Misc: New Sphinx documentation theme.</li> </ul>"},{"location":"changelog/#0155-2023-01-17","title":"0.15.5 - 2023-01-17","text":""},{"location":"changelog/#changed_3","title":"Changed","text":"<ul> <li>Misc: Neater handling of strings for tests.</li> <li>Misc: Better examples for merging trees and weighted trees in Sphinx documentation.</li> <li>Misc: Fix links and introduce unreleased segment in CHANGELOG.</li> </ul>"},{"location":"changelog/#0154-2024-01-11","title":"0.15.4 - 2024-01-11","text":""},{"location":"changelog/#changed_4","title":"Changed","text":"<ul> <li>Tree Exporter: <code>hprint_tree</code> and <code>hyield_tree</code> to allow hiding names of intermediate node.</li> </ul>"},{"location":"changelog/#fixed_3","title":"Fixed","text":"<ul> <li>Tree Constructor: <code>newick_to_tree</code> to handle invalid closing and use of apostrophe.</li> <li>Tree Exporter: <code>tree_to_newick</code> to handle special characters by wrapping them in apostrophe.</li> </ul>"},{"location":"changelog/#0153-2024-01-08","title":"0.15.3 - 2024-01-08","text":""},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>Tree Helper: <code>get_subtree</code> method to retrieve subtree.</li> </ul>"},{"location":"changelog/#0152-2024-01-08","title":"0.15.2 - 2024-01-08","text":""},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>Tree Exporter: <code>hprint_tree</code> and <code>hyield_tree</code> to print and retrieve results for tree in horizontal orientation.</li> <li>Node: Added <code>hshow</code> method to print tree in horizontal orientation to console.</li> </ul>"},{"location":"changelog/#0151-2024-01-05","title":"0.15.1 - 2024-01-05","text":""},{"location":"changelog/#added_5","title":"Added","text":"<ul> <li>Tree Constructor: <code>newick_to_tree</code> to convert Newick notation to tree.</li> </ul>"},{"location":"changelog/#changed_5","title":"Changed","text":"<ul> <li>Tree Exporter: <code>tree_to_newick</code> to accept more parameters to parse length and attributes.</li> </ul>"},{"location":"changelog/#fixed_4","title":"Fixed","text":"<ul> <li>Misc: Automated doctest setup to use os operations instead of string operations.</li> </ul>"},{"location":"changelog/#0150-2024-01-02","title":"0.15.0 - 2024-01-02","text":""},{"location":"changelog/#added_6","title":"Added","text":"<ul> <li>Tree Exporter: Export to Newick notation with <code>tree_to_newick</code>.</li> </ul>"},{"location":"changelog/#changed_6","title":"Changed","text":"<ul> <li>Tree Helper: Pruning tree to support pruning of multiple paths (accepts list of string).</li> <li>Tree Helper: Pruning tree to support pruning of an exact path (i.e., remove descendants) with <code>exact</code> parameter, default is prune and keep descendants.</li> </ul>"},{"location":"changelog/#0148-2023-12-25","title":"0.14.8 - 2023-12-25","text":""},{"location":"changelog/#changed_7","title":"Changed","text":"<ul> <li>Tree Modifier: Enhance documentation examples.</li> <li>Workflow To Do App: Change import and export logic.</li> <li>Misc: Organize assets folder based on whether it originated from README, docstrings, or sphinx documentation.</li> <li>Misc: Rename functions in <code>plot.py</code> utils file for coverage report.</li> </ul>"},{"location":"changelog/#fixed_5","title":"Fixed","text":"<ul> <li>Misc: Fixed doctests and automate doctest checks.</li> </ul>"},{"location":"changelog/#0147-2023-12-22","title":"0.14.7 - 2023-12-22","text":""},{"location":"changelog/#changed_8","title":"Changed","text":"<ul> <li>Tree Helper: <code>get_tree_diff</code> enhanced to compare tree attributes by taking in <code>attr_list</code> parameter, and indicates difference with <code>(~)</code>.</li> </ul>"},{"location":"changelog/#fixed_6","title":"Fixed","text":"<ul> <li>Tree Helper: <code>get_tree_diff</code> compare tree structure by considering all nodes (previously only consider leaf nodes).</li> </ul>"},{"location":"changelog/#0146-2023-12-14","title":"0.14.6 - 2023-12-14","text":""},{"location":"changelog/#added_7","title":"Added","text":"<ul> <li>Node: Able to access and delete node children via name with square bracket accessor with <code>__getitem__</code> and <code>__delitem__</code> magic methods.</li> <li>BaseNode/Node/BinaryNode: Able to add one or more children with <code>append</code> and <code>extend</code> methods.</li> <li>BaseNode/Node/BinaryNode: Able to check if node contains child node with <code>__contains__</code> magic method.</li> <li>BaseNode/Node/BinaryNode: Able to iterate the node to access children with <code>__iter__</code> magic method. Results in children setter to only accept list/tuple/set instead of iterable types.</li> </ul>"},{"location":"changelog/#changed_9","title":"Changed","text":"<ul> <li>Tree Exporter: <code>tree_to_dot</code> accepts callable to set node and edge attrs for custom node (backward-compatible).</li> <li>Tree Exporter: <code>tree_to_mermaid</code> accepts callable to set node shape attr, edge arrow attr and node attr for custom node (backward-compatible).</li> <li>Tree Exporter: Change delimiter for <code>tree_to_mermaid</code> to prevent possible path confusion (backward-compatible).</li> <li>Misc: Code abstraction for assertion checks and constants.</li> <li>Misc: Documentation for exporting tree/dag to dot.</li> </ul>"},{"location":"changelog/#0145-2023-11-24","title":"0.14.5 - 2023-11-24","text":""},{"location":"changelog/#changed_10","title":"Changed","text":"<ul> <li>Misc: Update SECURITY file.</li> <li>Misc: Documentation enhancement to add more emoji, and highlight code blocks.</li> </ul>"},{"location":"changelog/#0144-2023-11-04","title":"0.14.4 - 2023-11-04","text":""},{"location":"changelog/#changed_11","title":"Changed","text":"<ul> <li>Misc: Clean up github actions.</li> </ul>"},{"location":"changelog/#0143-2023-10-31","title":"0.14.3 - 2023-10-31","text":""},{"location":"changelog/#added_8","title":"Added","text":"<ul> <li>Misc: Publish to conda, enable automated publishing to conda-forge in addition to existing PyPI.</li> <li>Misc: Tree demonstration code for <code>shift_and_replace_nodes</code> and <code>copy_and_replace_nodes_from_tree_to_tree</code> in README.</li> </ul>"},{"location":"changelog/#0142-2023-10-21","title":"0.14.2 - 2023-10-21","text":""},{"location":"changelog/#added_9","title":"Added","text":"<ul> <li>Misc: RTD integration.</li> <li>Misc: Enable manual publishing of python package.</li> </ul>"},{"location":"changelog/#0141-2023-10-18","title":"0.14.1 - 2023-10-18","text":""},{"location":"changelog/#added_10","title":"Added","text":"<ul> <li>Misc: Changes to main branch checks if the latest version exists (using git tag) before publishing package and building documentation.</li> </ul>"},{"location":"changelog/#0140-2023-10-18","title":"0.14.0 - 2023-10-18","text":""},{"location":"changelog/#added_11","title":"Added","text":"<ul> <li>Tree Modifier: Shift nodes with replacement of to-node with <code>shift_and_replace_nodes</code>.</li> <li>Tree Modifier: Copy nodes from tree to tree with replacement of to-node with <code>copy_and_replace_nodes_from_tree_to_tree</code>.</li> <li>Tree Modifier: Any permutation of configuration with replacement of to-node with <code>replace_logic</code>.</li> <li>Tree Modifier: Add relevant test cases and documentations accordingly.</li> </ul>"},{"location":"changelog/#0133-2023-10-17","title":"0.13.3 - 2023-10-17","text":""},{"location":"changelog/#added_12","title":"Added","text":"<ul> <li>Misc: Add automatic release notes with content into GitHub workflow.</li> </ul>"},{"location":"changelog/#0132-2023-10-17","title":"0.13.2 - 2023-10-17","text":""},{"location":"changelog/#added_13","title":"Added","text":"<ul> <li>Misc: Add automatic release notes into GitHub workflow.</li> </ul>"},{"location":"changelog/#0131-2023-10-15","title":"0.13.1 - 2023-10-15","text":""},{"location":"changelog/#added_14","title":"Added","text":"<ul> <li>Misc: Add automatic comment on code coverage to pull requests into GitHub workflow.</li> <li>Misc: Add more checks into pre-commit.</li> </ul>"},{"location":"changelog/#0130-2023-09-29","title":"0.13.0 - 2023-09-29","text":""},{"location":"changelog/#added_15","title":"Added","text":"<ul> <li>Tree Exporter: Export tree to flowchart diagram in mermaid markdown format using <code>tree_to_mermaid</code>.</li> </ul>"},{"location":"changelog/#changed_12","title":"Changed","text":"<ul> <li>Tree Exporter: Relax type hinting using TypeVar for <code>clone_tree</code>.</li> <li>Tree Helper: Accept Iterable instead of List for custom_style attribute of <code>yield_tree</code> and <code>print_tree</code>.</li> <li>Misc: Fix docstring for better presentation of code vs variable vs normal text.</li> </ul>"},{"location":"changelog/#0125-2023-09-26","title":"0.12.5 - 2023-09-26","text":""},{"location":"changelog/#added_16","title":"Added","text":"<ul> <li>Utility Groot: Add test cases.</li> </ul>"},{"location":"changelog/#fixed_7","title":"Fixed","text":"<ul> <li>Tree Exporter: <code>tree_to_pillow</code> function to reference online font file instead of relative path.</li> </ul>"},{"location":"changelog/#0124-2023-09-25","title":"0.12.4 - 2023-09-25","text":""},{"location":"changelog/#added_17","title":"Added","text":"<ul> <li>Utility Groot: Add groot utility functions.</li> </ul>"},{"location":"changelog/#0123-2023-09-17","title":"0.12.3 - 2023-09-17","text":""},{"location":"changelog/#changed_13","title":"Changed","text":"<ul> <li>Clearer documentation, fixed docstring phrasing and spelling.</li> <li>Clearer error messages, standardized error messages.</li> </ul>"},{"location":"changelog/#0122-2023-09-12","title":"0.12.2 - 2023-09-12","text":""},{"location":"changelog/#changed_14","title":"Changed","text":"<ul> <li>Tree Plot: Reingold Tilford Algorithm code for succinctness and docstring.</li> </ul>"},{"location":"changelog/#0121-2023-09-11","title":"0.12.1 - 2023-09-11","text":""},{"location":"changelog/#fixed_8","title":"Fixed","text":"<ul> <li>Tree Plot: Reingold Tilford Algorithm to handle cases of negative x-coordinates with adjustment parameter.</li> </ul>"},{"location":"changelog/#0120-2023-09-09","title":"0.12.0 - 2023-09-09","text":""},{"location":"changelog/#changed_15","title":"Changed","text":"<ul> <li>Tree/DAG Constructor, Tree/DAG Exporter: Make <code>pandas</code> optional dependency.</li> </ul>"},{"location":"changelog/#fixed_9","title":"Fixed","text":"<ul> <li>Misc: Fixed Calendar workflow to throw error when <code>to_dataframe</code> method is called on empty calendar.</li> <li>Tree/DAGNode Exporter, Tree Helper, Tree Search: Relax type hinting using TypeVar.</li> </ul>"},{"location":"changelog/#0110-2023-09-08","title":"0.11.0 - 2023-09-08","text":""},{"location":"changelog/#added_18","title":"Added","text":"<ul> <li>Tree Helper: Pruning tree to allow pruning by <code>prune_path</code> and <code>max_depth</code>.</li> <li>Tree Plot: Implement Enhanced Reingold Tilford Algorithm to retrieve (x, y) coordinates for a tree structure.</li> </ul>"},{"location":"changelog/#changed_16","title":"Changed","text":"<ul> <li>BaseNode/DAGNode: <code>get_attr</code> method to allow default return value.</li> </ul>"},{"location":"changelog/#fixed_10","title":"Fixed","text":"<ul> <li>Utility Iterator: Relax type hinting using TypeVar.</li> </ul>"},{"location":"changelog/#0103-2023-08-12","title":"0.10.3 - 2023-08-12","text":""},{"location":"changelog/#added_19","title":"Added","text":"<ul> <li>Tree Constructor: <code>add_path_to_tree</code>, <code>dataframe_to_tree</code>, <code>dataframe_to_tree_by_relation</code> to allow custom node types that takes in constructor arguments.</li> </ul>"},{"location":"changelog/#changed_17","title":"Changed","text":"<ul> <li>Binary Tree: Able to accept node val of <code>str</code> type besides <code>int</code> type.</li> </ul>"},{"location":"changelog/#0102-2023-08-11","title":"0.10.2 - 2023-08-11","text":""},{"location":"changelog/#fixed_11","title":"Fixed","text":"<ul> <li>Tree Constructor: <code>nested_dict_to_tree</code> to throw TypeError if child_key is not list type.</li> </ul>"},{"location":"changelog/#0101-2023-07-27","title":"0.10.1 - 2023-07-27","text":""},{"location":"changelog/#added_20","title":"Added","text":"<ul> <li>[#71] Node: <code>path_name</code> to allow different node name of different dtypes; map everything to string type.</li> </ul>"},{"location":"changelog/#0100-2023-07-15","title":"0.10.0 - 2023-07-15","text":""},{"location":"changelog/#added_21","title":"Added","text":"<ul> <li>[#65] Tree Search: Implement <code>find_relative_path</code> to find relative path from node.</li> <li>[#65] Utility Iterator: Implement <code>zigzag_iter</code> and <code>zigzaggroup_iter</code> Tree traversal methods.</li> </ul>"},{"location":"changelog/#095-2023-07-13","title":"0.9.5 - 2023-07-13","text":""},{"location":"changelog/#added_22","title":"Added","text":"<ul> <li>Misc: Added init files, add link to discussions to README and pyproject, add sphinx coverage shortcuts.</li> </ul>"},{"location":"changelog/#fixed_12","title":"Fixed","text":"<ul> <li>[#66] DAGNode/Node: Children constructor to allow Iterable types, fixed issue of lists being mutable.</li> <li>[#67] Node: <code>path_name</code> to reduce number of recursive calls to root node for <code>sep</code>.</li> </ul>"},{"location":"changelog/#094-2023-06-18","title":"0.9.4 - 2023-06-18","text":""},{"location":"changelog/#added_23","title":"Added","text":"<ul> <li>Tree Constructor: <code>list_to_tree_by_relation</code> and <code>dataframe_to_tree_by_relation</code> method to allow duplicate intermediate nodes (default is false).</li> <li>DAG Exporter: Added <code>node_shape</code> parameter in <code>dag_to_dot</code> export function for easier way to customize node shape.</li> <li>Misc: More test cases.</li> <li>Misc: Added security instructions on how to raise vulnerabilities.</li> <li>Misc: Added Calendar workflow to documentation.</li> </ul>"},{"location":"changelog/#changed_18","title":"Changed","text":"<ul> <li>Tree Constructor: <code>add_dict_to_tree_by_name</code> method rename argument from <code>path_attrs</code> to <code>name_attrs</code>.</li> <li>Misc: Modified contributing instructions.</li> </ul>"},{"location":"changelog/#fixed_13","title":"Fixed","text":"<ul> <li>Tree Exporter: <code>tree_to_dot</code> to handle cases when not all nodes have <code>edge_attr</code>.</li> <li>DAG Exporter: <code>dag_to_dot</code> to perform dictionary copy to prevent style from being overridden for child nodes.</li> <li>Tree Constructor: <code>dataframe_to_tree</code> to handle case when path column is not the first column.</li> </ul>"},{"location":"changelog/#093-2023-05-28","title":"0.9.3 - 2023-05-28","text":""},{"location":"changelog/#changed_19","title":"Changed","text":"<ul> <li>Tree Constructor: Relax type hint to <code>Iterable</code> instead of <code>List</code> for <code>list_to_tree</code> and <code>list_to_tree_by_relation</code> methods.</li> </ul>"},{"location":"changelog/#fixed_14","title":"Fixed","text":"<ul> <li>Node: Fix error message when trees have different <code>sep</code>.</li> </ul>"},{"location":"changelog/#092-2023-04-09","title":"0.9.2 - 2023-04-09","text":""},{"location":"changelog/#added_24","title":"Added","text":"<ul> <li>Node: Added <code>show</code> method to print tree to console.</li> <li>Workflow Calendar: Tree use case with calendar implementation.</li> </ul>"},{"location":"changelog/#091-2023-03-30","title":"0.9.1 - 2023-03-30","text":""},{"location":"changelog/#changed_20","title":"Changed","text":"<ul> <li>Node: Added <code>sep</code> parameter to constructor instead of using getter and setter methods to set <code>sep</code>.</li> </ul>"},{"location":"changelog/#090-2023-03-29","title":"0.9.0 - 2023-03-29","text":""},{"location":"changelog/#added_25","title":"Added","text":"<ul> <li>Tree Modifier: Ability to copy/shift nodes with full path in <code>from_paths</code> for faster search performance, added <code>with_full_path</code> parameter.</li> </ul>"},{"location":"changelog/#changed_21","title":"Changed","text":"<ul> <li>Tree Modifier: Enforced paths in <code>to_paths</code> to be full path for faster search performance.</li> <li>Tree Modifier: Faster creation of intermediate parent nodes in <code>to_paths</code>.</li> <li>Tree Modifier: Better handling of <code>sep</code> in paths by performing string replacement at the start.</li> <li>Tree Modifier: Check and throw error for invalid parameters, case when node is meant to be deleted but <code>copy=True</code>.</li> </ul>"},{"location":"changelog/#fixed_15","title":"Fixed","text":"<ul> <li>Tree Modifier: Fix issue trailing <code>sep</code> differing in <code>from_paths</code> and <code>to_paths</code> which should not throw error.</li> </ul>"},{"location":"changelog/#084-2023-03-24","title":"0.8.4 - 2023-03-24","text":""},{"location":"changelog/#added_26","title":"Added","text":"<ul> <li>Tree Search: Implement <code>find_child</code> and <code>find_children</code> to find single child or multiple children based on user-defined condition.</li> </ul>"},{"location":"changelog/#changed_22","title":"Changed","text":"<ul> <li>Tree and DAG Constructor: Reduce reliance on <code>numpy</code> package, only reject <code>None</code> attributes when creating tree from DataFrame (previously it rejects <code>[None]</code>).</li> <li>Tree Helper: Get difference between two trees reduce reliance on <code>numpy</code> package, enhance test cases.</li> <li>Tree Search: Renamed <code>find_children</code> to <code>find_child_by_name</code> for clarity.</li> <li>Misc: Fix README for Windows installation.</li> </ul>"},{"location":"changelog/#083-2023-03-16","title":"0.8.3 - 2023-03-16","text":""},{"location":"changelog/#changed_23","title":"Changed","text":"<ul> <li>Workflow: Misc refactor and update log statements.</li> <li>Misc: Fix coverage report.</li> </ul>"},{"location":"changelog/#082-2023-03-16","title":"0.8.2 - 2023-03-16","text":""},{"location":"changelog/#changed_24","title":"Changed","text":"<ul> <li>Misc: Type checking to remove optional requirement for <code>mypy</code>.</li> <li>Misc: Shift .flake8, .mypy.ini, and pytest.ini files to pyproject.toml.</li> </ul>"},{"location":"changelog/#081-2023-03-10","title":"0.8.1 - 2023-03-10","text":""},{"location":"changelog/#fixed_16","title":"Fixed","text":"<ul> <li>Tree Modifier: Fix issue of <code>sep</code> of tree differing from the <code>sep</code> in <code>from_paths</code> and <code>to_paths</code>.</li> </ul>"},{"location":"changelog/#080-2023-03-10","title":"0.8.0 - 2023-03-10","text":""},{"location":"changelog/#added_27","title":"Added","text":"<ul> <li>Misc: Type checking with <code>mypy</code>, added type checks to pre-commit hooks.</li> </ul>"},{"location":"changelog/#changed_25","title":"Changed","text":"<ul> <li>DAGNode: <code>go_to</code> method to be consistent with <code>List[List[DAGNode]]</code> type.</li> </ul>"},{"location":"changelog/#fixed_17","title":"Fixed","text":"<ul> <li>Tree Exporter: Exception handling in <code>yield_tree</code> if <code>node_name_or_path</code> is not found.</li> <li>Workflow: Exception handling in prioritizing item/list if item/list is not the correct tree depth.</li> <li>Workflow: Exception handling in removing item/list if item/list is not found.</li> </ul>"},{"location":"changelog/#074-2023-02-27","title":"0.7.4 - 2023-02-27","text":""},{"location":"changelog/#fixed_18","title":"Fixed","text":"<ul> <li>Tree Constructor: Fixed pandas SettingwithCopyWarning when performing dataframe operations.</li> </ul>"},{"location":"changelog/#073-2023-02-25","title":"0.7.3 - 2023-02-25","text":""},{"location":"changelog/#added_28","title":"Added","text":"<ul> <li>Tree Exporter: Fixed <code>print_tree</code> checking attributes with <code>hasattr</code> to handle cases of null or 0 value attributes, add more test cases.</li> <li>Misc: Added more description to Contributing.</li> </ul>"},{"location":"changelog/#072-2023-02-18","title":"0.7.2 - 2023-02-18","text":""},{"location":"changelog/#added_29","title":"Added","text":"<ul> <li>Tree Exporter: Added <code>node_shape</code> parameter in <code>tree_to_dot</code> export function for easier way to customize node shape.</li> </ul>"},{"location":"changelog/#071-2023-02-18","title":"0.7.1 - 2023-02-18","text":""},{"location":"changelog/#added_30","title":"Added","text":"<ul> <li>BaseNode/Node: Added <code>go_to</code> BaseNode method to travel from one node to another node from the same tree.</li> <li>DAGNode: Added <code>go_to</code> DAGNode method to travel from one node to another node from the same DAG.</li> </ul>"},{"location":"changelog/#070-2023-02-18","title":"0.7.0 - 2023-02-18","text":""},{"location":"changelog/#added_31","title":"Added","text":"<ul> <li>Tree Modifier: Accept <code>merge_leaves</code> type of modification, enhance documentation to provide more examples and illustrations.</li> </ul>"},{"location":"changelog/#0610-2023-01-23","title":"0.6.10 - 2023-01-23","text":""},{"location":"changelog/#fixed_19","title":"Fixed","text":"<ul> <li>Tree Constructor: <code>str_to_tree</code> accept prefixes to support unicode characters in node names.</li> </ul>"},{"location":"changelog/#069-2023-01-22","title":"0.6.9 - 2023-01-22","text":""},{"location":"changelog/#added_32","title":"Added","text":"<ul> <li>Tree Construct: <code>str_to_tree</code> to construct tree from tree string.</li> </ul>"},{"location":"changelog/#068-2023-01-14","title":"0.6.8 - 2023-01-14","text":""},{"location":"changelog/#fixed_20","title":"Fixed","text":"<ul> <li>Tree Exporter: <code>tree_to_dot</code> to perform dictionary copy to prevent style from being overridden for child nodes.</li> </ul>"},{"location":"changelog/#067-2023-01-09","title":"0.6.7 - 2023-01-09","text":""},{"location":"changelog/#changed_26","title":"Changed","text":"<ul> <li>Binary Tree: Changed <code>BNode</code> to <code>BinaryNode</code>, and construct method <code>list_to_btree</code> to <code>list_to_binarytree</code>.</li> </ul>"},{"location":"changelog/#066-2022-12-15","title":"0.6.6 - 2022-12-15","text":""},{"location":"changelog/#added_33","title":"Added","text":"<ul> <li>Tree Exporter: Export <code>print_tree</code> output to image using Pillow package.</li> </ul>"},{"location":"changelog/#065-2022-12-07","title":"0.6.5 - 2022-12-07","text":""},{"location":"changelog/#added_34","title":"Added","text":"<ul> <li>Tree Modifier: Shift/copy nodes able to shift node-only and delete the children (backwards-compatible).</li> </ul>"},{"location":"changelog/#064-2022-11-16","title":"0.6.4 - 2022-11-16","text":""},{"location":"changelog/#fixed_21","title":"Fixed","text":"<ul> <li>BNode: Minor fix on rollback functionality when original children includes None.</li> </ul>"},{"location":"changelog/#063-2022-11-15","title":"0.6.3 - 2022-11-15","text":""},{"location":"changelog/#added_35","title":"Added","text":"<ul> <li>DAGNode: Rollback functionality to original state when there is error setting parent and children (backwards-compatible).</li> </ul>"},{"location":"changelog/#changed_27","title":"Changed","text":"<ul> <li>BaseNode, BNode, DAGNode: Refactor by abstracting checks.</li> </ul>"},{"location":"changelog/#fixed_22","title":"Fixed","text":"<ul> <li>BaseNode: Fix rollback logic to handle failure in pre-assign checks and reassigning same child / parent.</li> <li>BNode: Fix issue of reassigning children shifting existing child from right to left.</li> </ul>"},{"location":"changelog/#062-2022-11-15","title":"0.6.2 - 2022-11-15","text":""},{"location":"changelog/#changed_28","title":"Changed","text":"<ul> <li>Tree Modifier: Shorter logging messages.</li> </ul>"},{"location":"changelog/#061-2022-11-14","title":"0.6.1 - 2022-11-14","text":""},{"location":"changelog/#changed_29","title":"Changed","text":"<ul> <li>Tree Modifier: Handle shifting/copying that removes intermediate layer (backwards-compatible).</li> </ul>"},{"location":"changelog/#060-2022-11-13","title":"0.6.0 - 2022-11-13","text":""},{"location":"changelog/#added_36","title":"Added","text":"<ul> <li>BaseNode: Rollback functionality to original state when there is error setting parent and children (backwards-compatible).</li> <li>BaseNode and DAGNode: Type hints.</li> <li>BNode: Node class for Binary Tree.</li> <li>BTree Constructor: From list.</li> <li>BNode Iterator: Level-Order Iterator.</li> <li>Misc: Add Tips and Tricks to documentation (List Directory).</li> </ul>"},{"location":"changelog/#fixed_23","title":"Fixed","text":"<ul> <li>DAGNode: Fix issue of duplicate parent constructor creating duplicate children.</li> </ul>"},{"location":"changelog/#055-2022-11-12","title":"0.5.5 - 2022-11-12","text":""},{"location":"changelog/#added_37","title":"Added","text":"<ul> <li>Misc: More docstring examples.</li> <li>Misc: More test cases.</li> </ul>"},{"location":"changelog/#fixed_24","title":"Fixed","text":"<ul> <li>Tree Modifier: Fix issue with <code>merge_children</code> argument not working as expected.</li> </ul>"},{"location":"changelog/#054-2022-11-12","title":"0.5.4 - 2022-11-12","text":""},{"location":"changelog/#added_38","title":"Added","text":"<ul> <li>BaseNode: Add sort() to sort children.</li> <li>Node: Made more extendable with pre-/post-assign checks.</li> <li>Misc: Add Tips and Tricks to documentation (Extending Nodes).</li> <li>Misc: More test cases.</li> </ul>"},{"location":"changelog/#fixed_25","title":"Fixed","text":"<ul> <li>Tree Search: Type hints.</li> </ul>"},{"location":"changelog/#053-2022-11-11","title":"0.5.3 - 2022-11-11","text":""},{"location":"changelog/#added_39","title":"Added","text":"<ul> <li>DAG and Tree Exporter: More customizations allowed on edges.</li> <li>Add Tips and Tricks to documentation (Weighted Trees, Merging Trees).</li> </ul>"},{"location":"changelog/#fixed_26","title":"Fixed","text":"<ul> <li>Tree Modifier: Fix issue with <code>merge_children</code> argument not working as expected.</li> </ul>"},{"location":"changelog/#052-2022-11-10","title":"0.5.2 - 2022-11-10","text":""},{"location":"changelog/#fixed_27","title":"Fixed","text":"<ul> <li>Tree Constructor: Fix issue <code>dataframe_to_tree_by_relation</code> unable to find parent node.</li> </ul>"},{"location":"changelog/#051-2022-11-09","title":"0.5.1 - 2022-11-09","text":""},{"location":"changelog/#added_40","title":"Added","text":"<ul> <li>Misc: Clean codes and documentation.</li> </ul>"},{"location":"changelog/#050-2022-11-09","title":"0.5.0 - 2022-11-09","text":""},{"location":"changelog/#added_41","title":"Added","text":"<ul> <li>Misc: Clean codes and documentation.</li> </ul>"},{"location":"changelog/#changed_30","title":"Changed","text":"<ul> <li>Tree Exporter: Printing tree to group multiple arguments together.</li> <li>DAG and Tree Exporter: Export to dot able to plot multiple disjointed trees/dags, rename <code>bgcolor</code> to <code>bg_colour</code>.</li> </ul>"},{"location":"changelog/#046-2022-11-09","title":"0.4.6 - 2022-11-09","text":""},{"location":"changelog/#added_42","title":"Added","text":"<ul> <li>Tree Constructor: From DataFrame of parent-child columns.</li> </ul>"},{"location":"changelog/#changed_31","title":"Changed","text":"<ul> <li>Tree Exporter: Printing tree to define node name or path, and default to const style.</li> <li>Tree Constructor: Rename <code>list_to_tree_tuples</code> to <code>list_to_tree_by_relation</code>.</li> <li>Tree Constructor: Remove parameter <code>sep</code> for <code>nested_dict_to_tree</code>.</li> </ul>"},{"location":"changelog/#045-2022-11-08","title":"0.4.5 - 2022-11-08","text":""},{"location":"changelog/#changed_32","title":"Changed","text":"<ul> <li>Tree Exporter: Printing tree with added ability to omit null attributes.</li> </ul>"},{"location":"changelog/#044-2022-11-08","title":"0.4.4 - 2022-11-08","text":""},{"location":"changelog/#fixed_28","title":"Fixed","text":"<ul> <li>Tree Constructor: Handle adding attributes that are array-like - add array even when one of the items is null.</li> </ul>"},{"location":"changelog/#043-2022-11-08","title":"0.4.3 - 2022-11-08","text":""},{"location":"changelog/#added_43","title":"Added","text":"<ul> <li>Node: Print format for BaseNode.</li> </ul>"},{"location":"changelog/#042-2022-11-08","title":"0.4.2 - 2022-11-08","text":""},{"location":"changelog/#fixed_29","title":"Fixed","text":"<ul> <li>Tree Constructor: For list of tuples, handle cases where parent name is None.</li> </ul>"},{"location":"changelog/#041-2022-11-07","title":"0.4.1 - 2022-11-07","text":""},{"location":"changelog/#fixed_30","title":"Fixed","text":"<ul> <li>Tree Constructor: Handle adding attributes that are array-like - error in drop_duplicate() and pd.isnull().</li> </ul>"},{"location":"changelog/#040-2022-11-07","title":"0.4.0 - 2022-11-07","text":""},{"location":"changelog/#added_44","title":"Added","text":"<ul> <li>Tree Constructor: From list of tuples of parent-child.</li> </ul>"},{"location":"changelog/#033-2022-11-07","title":"0.3.3 - 2022-11-07","text":""},{"location":"changelog/#added_45","title":"Added","text":"<ul> <li>DAG Exporter: To list, nested dictionary, pandas DataFrame.</li> </ul>"},{"location":"changelog/#changed_33","title":"Changed","text":"<ul> <li>BaseNode and DAGNode: Modify docstring.</li> <li>Tree Exporter: Support Nodes with same name.</li> <li>Tree Modifier: Modify docstring.</li> <li>Utility Iterator: Modify docstring.</li> </ul>"},{"location":"changelog/#032-2022-11-07","title":"0.3.2 - 2022-11-07","text":""},{"location":"changelog/#fixed_31","title":"Fixed","text":"<ul> <li>Tree Exporter: Fix edge direction error.</li> </ul>"},{"location":"changelog/#031-2022-11-07","title":"0.3.1 - 2022-11-07","text":""},{"location":"changelog/#added_46","title":"Added","text":"<ul> <li>Tree and DAG Exporter: More customizations for Node to dot and DAGNode to dot.</li> </ul>"},{"location":"changelog/#030-2022-11-05","title":"0.3.0 - 2022-11-05","text":""},{"location":"changelog/#added_47","title":"Added","text":"<ul> <li>DAG Constructor: From list, nested dictionary, pandas DataFrame.</li> <li>Utility Iterator: DAG traversal methods.</li> </ul>"},{"location":"changelog/#changed_34","title":"Changed","text":"<ul> <li>Tree Exporter and DAG Exporter: More customizations for Node to dot and DAGNode to dot.</li> </ul>"},{"location":"changelog/#020-2022-11-03","title":"0.2.0 - 2022-11-03","text":""},{"location":"changelog/#added_48","title":"Added","text":"<ul> <li>Node: DAGNode for creating DAG graph.</li> <li>Tree Exporter: Support Node to dot which can export to png, svg, jpeg, dot files.</li> <li>DAG Exporter: Support DAGNode to dot.</li> </ul>"},{"location":"changelog/#010-2022-11-01","title":"0.1.0 - 2022-11-01","text":""},{"location":"changelog/#added_49","title":"Added","text":"<ul> <li>Node: Node and BaseNode.</li> <li>Tree Constructor: From list, nested dictionary, pandas DataFrame.</li> <li>Tree Exporter: To list, nested dictionary, pandas DataFrame.</li> <li>Tree Helper: Cloning, pruning trees, get difference between two trees.</li> <li>Tree Modifier: Shift and copy nodes within tree and between trees.</li> <li>Tree Search: Find single or multiple nodes based on name, attribute, or custom criteria.</li> <li>Utility Iterator: Tree traversal methods.</li> <li>Workflow To Do App: Tree use case with to-do list implementation.</li> </ul>"},{"location":"contributing/","title":"\ud83c\udf6a Contributing","text":"<p>bigtree is a tree implementation package for Python. It integrates with Python lists, dictionaries, and pandas DataFrame.</p> <p>Thank you for taking the time to contribute. Contributing to this package is an excellent opportunity to dive into tree implementations.</p>"},{"location":"contributing/#set-up","title":"Set Up","text":"<p>First, fork the repository and clone the forked repository.</p> <pre><code>$ git clone git@github.com:&lt;your-username&gt;/bigtree.git\n</code></pre> <p>Next, create a virtual environment and activate it.</p> <pre><code>$ conda create -n bigtree_venv python=3.10\n$ conda activate bigtree_venv\n</code></pre> <p>To check if it worked,</p> <pre><code>$ which pip\n/&lt;some directory&gt;/envs/bigtree_venv/bin/pip\n</code></pre> <p>From the project folder, install the required python packages locally in editable mode and set up pre-commit checks.</p> <pre><code>$ python -m pip install -e \".[all]\"\n$ python -m pip install pre-commit\n$ pre-commit install\n</code></pre>"},{"location":"contributing/#developing","title":"Developing","text":"<p>After making your changes, create a new branch, add and commit your changed files. In this example, lets assume the changed file is <code>README.md</code>. If there are any pre-commit changes and/or comments, do modify, re-add and re-commit your files.</p> <pre><code>$ git checkout -b chore/update-readme\n$ git add README.md\n$ git commit -m \"chore: updated README\"\n</code></pre> <p>Push your changes to your created branch and create a pull request from your fork.</p> <pre><code>$ git push origin chore/update-readme\n</code></pre>"},{"location":"contributing/#testing-and-documentation","title":"Testing and Documentation","text":"<p>If there are changes related to code, please make sure that the unit tests pass and the code coverage is 100%.</p> <pre><code>$ python -m pip install pytest coverage\n$ pytest --cov-report=term-missing --cov-config=pyproject.toml --cov=bigtree\n</code></pre> <p>Make sure your add/update the tests and documentations accordingly.</p> <p>If there are changes to the docstrings and/or sample codes in the docstring, do run the following lines of code to generate the coverage report and test report for docstrings. Refer to the console log for information on the file location of the reports.</p> <pre><code>$ python -m pip install hatch\n$ hatch run docs:coverage\n$ hatch run docs:doctest\n</code></pre>"},{"location":"contributing/#convention-and-standards","title":"Convention and Standards","text":"<p>When creating branches, it is recommended to create them in the format <code>type/action</code>. For example,</p> <pre><code>$ git checkout -b feat/add-this\n</code></pre> <p>When performing commits, it is also recommended to follow conventional commits when writing commit messages.</p> <p>During pre-commit checks, this project checks and formats code using <code>black</code>, <code>flake8</code>, <code>isort</code>, and <code>mypy</code>.</p> <p>For testing, this project uses <code>pytest</code> and <code>coverage</code> package for testing of codes, and <code>docstr-coverage</code> and <code>doctest</code> package for testing of docstrings.</p>"},{"location":"contributing/#consequent-changes","title":"Consequent Changes","text":"<p>Please open an issue to discuss important changes before embarking on an implementation.</p>"},{"location":"dag/","title":"\ud83c\udf34 Directed Acyclic Graph (DAG)","text":"<p>For Directed Acyclic Graph (DAG) implementation, there are 4 main components.</p>"},{"location":"dag/#node","title":"\ud83c\udf3c Node","text":"<ul> <li><code>DAGNode</code>, extendable class for constructing Directed Acyclic Graph (DAG)</li> </ul>"},{"location":"dag/#constructing-dag","title":"\u2728 Constructing DAG","text":"<ul> <li>From list, containing parent-child tuples</li> <li>From nested dictionary</li> <li>From pandas DataFrame</li> </ul>"},{"location":"dag/#traversing-dag","title":"\u27b0 Traversing DAG","text":"<ul> <li>Generic traversal method</li> </ul>"},{"location":"dag/#exporting-dag","title":"\ud83d\udd28 Exporting DAG","text":"<ul> <li>Export to list, dictionary, or pandas DataFrame</li> <li>Export DAG to dot (can save to .dot, .png, .svg, .jpeg files)</li> </ul>"},{"location":"home/","title":"\ud83c\udf33 Documentation","text":"<p>Tree Implementation and Methods for Python, integrated with Python list, dictionary, and pandas DataFrame.</p> <p>It is pythonic, making it easy to learn and extendable to many types of workflows.</p> <ul> <li> Set up in 2 minutes <p>Install <code>bigtree</code> with <code>pip</code> or <code>conda</code> and get up   and running in minutes</p> <p> Getting started</p> </li> </ul> <ul> <li> Getting started <p>View demonstration on how to use <code>bigtree</code></p> <p> Reference</p> </li> </ul> <p>Related Links:</p> <ul> <li>GitHub</li> <li>Community<ul> <li>Issues / Discussions / Changelog / Contributing</li> </ul> </li> <li>Package<ul> <li>PyPI / Conda</li> </ul> </li> <li>Articles<ul> <li>Python Tree Implementation with BigTree</li> <li>The Reingold Tilford Algorithm Explained, with Walkthrough</li> </ul> </li> <li><p>If you want to support bigtree, </p></li> </ul>"},{"location":"install/","title":"\ud83d\udcbb Installation","text":"<p>There are two ways to install <code>bigtree</code>, with pip (recommended) or conda.</p>"},{"location":"install/#installation-with-pip","title":"Installation with pip","text":"<p>To install <code>bigtree</code>, run the following line in command prompt:</p> <pre><code>$ pip install bigtree\n</code></pre> <p>If tree needs to use pandas methods, it requires additional dependencies. Run the following line in command prompt:</p> <pre><code>$ pip install 'bigtree[pandas]'\n</code></pre> <p>If tree needs to be exported to image, it requires additional dependencies. Run the following lines in command prompt:</p> <pre><code>$ pip install 'bigtree[image]'\n$ brew install gprof2dot  # for MacOS\n$ conda install graphviz  # for Windows\n</code></pre> <p>Alternatively, install all optional dependencies with the following line in command prompt:</p> <pre><code>$ pip install 'bigtree[all]'\n</code></pre>"},{"location":"install/#installation-with-conda","title":"Installation with conda","text":"<p>To install <code>bigtree</code> with conda, run the following line in command prompt:</p> <pre><code>$ conda install -c conda-forge bigtree\n</code></pre>"},{"location":"tree/","title":"\ud83c\udf32 Tree","text":"<p>For Tree implementation, there are 9 main components.</p>"},{"location":"tree/#node","title":"\ud83c\udf3a Node","text":"<ul> <li><code>BaseNode</code>, extendable class</li> <li><code>Node</code>, BaseNode with node name attribute</li> </ul>"},{"location":"tree/#constructing-tree","title":"\u2728 Constructing Tree","text":"<ul> <li>From <code>Node</code>, using parent and children constructors</li> <li>From str, using tree display or Newick string notation</li> <li>From list, using paths or parent-child tuples</li> <li>From nested dictionary, using path-attribute key-value pairs or recursive structure</li> <li>From pandas DataFrame, using paths or parent-child columns</li> <li>Add nodes to existing tree using path string</li> <li>Add nodes and attributes to existing tree using dictionary or pandas DataFrame, using path</li> <li>Add only attributes to existing tree using dictionary or pandas DataFrame, using node name</li> </ul>"},{"location":"tree/#traversing-tree","title":"\u27b0 Traversing Tree","text":"<ul> <li>Pre-Order Traversal</li> <li>Post-Order Traversal</li> <li>Level-Order Traversal</li> <li>Level-Order-Group Traversal</li> <li>ZigZag Traversal</li> <li>ZigZag-Group Traversal</li> </ul>"},{"location":"tree/#modifying-tree","title":"\ud83d\udcdd Modifying Tree","text":"<ul> <li>Copy nodes from location to destination</li> <li>Shift nodes from location to destination</li> <li>Shift and replace nodes from location to destination</li> <li>Copy nodes from one tree to another</li> <li>Copy and replace nodes from one tree to another</li> </ul>"},{"location":"tree/#tree-search","title":"\ud83d\udd0d Tree Search","text":"<ul> <li>Find multiple nodes based on name, partial path, relative path, attribute value, user-defined condition</li> <li>Find single nodes based on name, partial path, relative path, full path, attribute value, user-defined condition</li> <li>Find multiple child nodes based on user-defined condition</li> <li>Find single child node based on name, user-defined condition</li> </ul>"},{"location":"tree/#helper-function","title":"\ud83d\udd27 Helper Function","text":"<ul> <li>Cloning tree to another <code>Node</code> type</li> <li>Get subtree (smaller tree with different root)</li> <li>Prune tree (smaller tree with same root)</li> <li>Get difference between two trees</li> </ul>"},{"location":"tree/#plotting-tree","title":"\ud83d\udcca Plotting Tree","text":"<ul> <li>Enhanced Reingold Tilford Algorithm to retrieve (x, y) coordinates for a tree structure</li> </ul>"},{"location":"tree/#exporting-tree","title":"\ud83d\udd28 Exporting Tree","text":"<ul> <li>Print to console, in vertical or horizontal orientation</li> <li>Export to Newick string notation, dictionary, nested dictionary, or pandas DataFrame</li> <li>Export tree to dot (can save to .dot, .png, .svg, .jpeg files)</li> <li>Export tree to Pillow (can save to .png, .jpg)</li> <li>Export tree to Mermaid Flowchart (can display on .md)</li> </ul>"},{"location":"tree/#workflows","title":"\u2714\ufe0f Workflows","text":"<ul> <li>Sample workflows for tree demonstration!</li> </ul>"},{"location":"bigtree/binarytree/","title":"\ud83c\udf35 Binary Tree","text":""},{"location":"bigtree/binarytree/construct/","title":"\u2728 Construct","text":"<p>Construct Binary Tree from a list.</p>"},{"location":"bigtree/binarytree/construct/#binary-tree-construct-methods","title":"Binary Tree Construct Methods","text":"Construct Binary Tree from Using heapq structure Add node attributes List <code>list_to_binarytree</code> No"},{"location":"bigtree/binarytree/construct/#bigtree.binarytree.construct","title":"bigtree.binarytree.construct","text":""},{"location":"bigtree/binarytree/construct/#bigtree.binarytree.construct.list_to_binarytree","title":"list_to_binarytree","text":"<pre><code>list_to_binarytree(heapq_list, node_type=BinaryNode)\n</code></pre> <p>Construct tree from a list of numbers (int or float) in heapq format.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import list_to_binarytree, tree_to_dot\n&gt;&gt;&gt; nums_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n&gt;&gt;&gt; root = list_to_binarytree(nums_list)\n&gt;&gt;&gt; root.show()\n1\n\u251c\u2500\u2500 2\n\u2502   \u251c\u2500\u2500 4\n\u2502   \u2502   \u251c\u2500\u2500 8\n\u2502   \u2502   \u2514\u2500\u2500 9\n\u2502   \u2514\u2500\u2500 5\n\u2502       \u2514\u2500\u2500 10\n\u2514\u2500\u2500 3\n    \u251c\u2500\u2500 6\n    \u2514\u2500\u2500 7\n&gt;&gt;&gt; graph = tree_to_dot(root, node_colour=\"gold\")\n&gt;&gt;&gt; graph.write_png(\"assets/construct_binarytree.png\")\n</code></pre> <p></p> <p>Parameters:</p> Name Type Description Default <code>heapq_list</code> <code>List[int]</code> <p>list containing integer node names, ordered in heapq fashion</p> required <code>node_type</code> <code>Type[BinaryNode]</code> <p>node type of tree to be created, defaults to <code>BinaryNode</code></p> <code>BinaryNode</code> <p>Returns:</p> Type Description <code>BinaryNode</code> <p>(BinaryNode)</p>"},{"location":"bigtree/dag/","title":"\ud83c\udf34 Directed Acyclic Graph (DAG)","text":""},{"location":"bigtree/dag/construct/","title":"\u2728 Construct","text":"<p>Construct Directed Acyclic Graph (DAG) from list, dictionary, and pandas DataFrame.</p>"},{"location":"bigtree/dag/construct/#dag-construct-methods","title":"DAG Construct Methods","text":"Construct DAG from Using parent-child relation Add node attributes List <code>list_to_dag</code> No Dictionary <code>dict_to_dag</code> Yes DataFrame <code>dataframe_to_dag</code> Yes <p>These functions are not standalone functions. Under the hood, they have the following dependency,</p> <p></p>"},{"location":"bigtree/dag/construct/#bigtree.dag.construct","title":"bigtree.dag.construct","text":""},{"location":"bigtree/dag/construct/#bigtree.dag.construct.list_to_dag","title":"list_to_dag","text":"<pre><code>list_to_dag(relations, node_type=DAGNode)\n</code></pre> <p>Construct DAG from list of tuples containing parent-child names. Note that node names must be unique.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import list_to_dag, dag_iterator\n&gt;&gt;&gt; relations_list = [(\"a\", \"c\"), (\"a\", \"d\"), (\"b\", \"c\"), (\"c\", \"d\"), (\"d\", \"e\")]\n&gt;&gt;&gt; dag = list_to_dag(relations_list)\n&gt;&gt;&gt; [(parent.node_name, child.node_name) for parent, child in dag_iterator(dag)]\n[('a', 'd'), ('c', 'd'), ('d', 'e'), ('a', 'c'), ('b', 'c')]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>relations</code> <code>List[Tuple[str, str]]</code> <p>list containing tuple of parent-child names</p> required <code>node_type</code> <code>Type[DAGNode]</code> <p>node type of DAG to be created, defaults to <code>DAGNode</code></p> <code>DAGNode</code> <p>Returns:</p> Type Description <code>DAGNode</code> <p>(DAGNode)</p>"},{"location":"bigtree/dag/construct/#bigtree.dag.construct.dict_to_dag","title":"dict_to_dag","text":"<pre><code>dict_to_dag(\n    relation_attrs, parent_key=\"parents\", node_type=DAGNode\n)\n</code></pre> <p>Construct DAG from nested dictionary, <code>key</code>: child name, <code>value</code>: dictionary of parent names, attribute name, and attribute value. Note that node names must be unique.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import dict_to_dag, dag_iterator\n&gt;&gt;&gt; relation_dict = {\n...     \"a\": {\"step\": 1},\n...     \"b\": {\"step\": 1},\n...     \"c\": {\"parents\": [\"a\", \"b\"], \"step\": 2},\n...     \"d\": {\"parents\": [\"a\", \"c\"], \"step\": 2},\n...     \"e\": {\"parents\": [\"d\"], \"step\": 3},\n... }\n&gt;&gt;&gt; dag = dict_to_dag(relation_dict, parent_key=\"parents\")\n&gt;&gt;&gt; [(parent.node_name, child.node_name) for parent, child in dag_iterator(dag)]\n[('a', 'd'), ('c', 'd'), ('d', 'e'), ('a', 'c'), ('b', 'c')]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>relation_attrs</code> <code>Dict[str, Any]</code> <p>dictionary containing node, node parents, and node attribute information, key: child name, value: dictionary of parent names, node attribute, and attribute value</p> required <code>parent_key</code> <code>str</code> <p>key of dictionary to retrieve list of parents name, defaults to 'parent'</p> <code>'parents'</code> <code>node_type</code> <code>Type[DAGNode]</code> <p>node type of DAG to be created, defaults to <code>DAGNode</code></p> <code>DAGNode</code> <p>Returns:</p> Type Description <code>DAGNode</code> <p>(DAGNode)</p>"},{"location":"bigtree/dag/construct/#bigtree.dag.construct.dataframe_to_dag","title":"dataframe_to_dag","text":"<pre><code>dataframe_to_dag(\n    data,\n    child_col=\"\",\n    parent_col=\"\",\n    attribute_cols=[],\n    node_type=DAGNode,\n)\n</code></pre> <p>Construct DAG from pandas DataFrame. Note that node names must be unique.</p> <ul> <li><code>child_col</code> and <code>parent_col</code> specify columns for child name and parent name to construct DAG.</li> <li><code>attribute_cols</code> specify columns for node attribute for child name.</li> <li>If columns are not specified, <code>child_col</code> takes first column, <code>parent_col</code> takes second column, and all other     columns are <code>attribute_cols</code>.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from bigtree import dataframe_to_dag, dag_iterator\n&gt;&gt;&gt; relation_data = pd.DataFrame([\n...     [\"a\", None, 1],\n...     [\"b\", None, 1],\n...     [\"c\", \"a\", 2],\n...     [\"c\", \"b\", 2],\n...     [\"d\", \"a\", 2],\n...     [\"d\", \"c\", 2],\n...     [\"e\", \"d\", 3],\n... ],\n...     columns=[\"child\", \"parent\", \"step\"]\n... )\n&gt;&gt;&gt; dag = dataframe_to_dag(relation_data)\n&gt;&gt;&gt; [(parent.node_name, child.node_name) for parent, child in dag_iterator(dag)]\n[('a', 'd'), ('c', 'd'), ('d', 'e'), ('a', 'c'), ('b', 'c')]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>data containing path and node attribute information</p> required <code>child_col</code> <code>str</code> <p>column of data containing child name information, defaults to '' if not set, it will take the first column of data</p> <code>''</code> <code>parent_col</code> <code>str</code> <p>column of data containing parent name information, defaults to '' if not set, it will take the second column of data</p> <code>''</code> <code>attribute_cols</code> <code>List[str]</code> <p>columns of data containing child node attribute information, if not set, it will take all columns of data except <code>child_col</code> and <code>parent_col</code></p> <code>[]</code> <code>node_type</code> <code>Type[DAGNode]</code> <p>node type of DAG to be created, defaults to <code>DAGNode</code></p> <code>DAGNode</code> <p>Returns:</p> Type Description <code>DAGNode</code> <p>(DAGNode)</p>"},{"location":"bigtree/dag/export/","title":"\ud83d\udd28 Export","text":"<p>Export Directed Acyclic Graph (DAG) to list, dictionary, and pandas DataFrame.</p>"},{"location":"bigtree/dag/export/#dag-export-methods","title":"DAG Export Methods","text":"Export DAG to Method Extract node attributes List <code>dag_to_list</code> No Dictionary <code>dag_to_dict</code> Yes with <code>attr_dict</code> or <code>all_attrs</code> DataFrame <code>dag_to_dataframe</code> Yes with <code>attr_dict</code> or <code>all_attrs</code> Dot (for .dot, .png, .svg, .jpeg, etc.) <code>dag_to_dot</code> No"},{"location":"bigtree/dag/export/#bigtree.dag.export","title":"bigtree.dag.export","text":""},{"location":"bigtree/dag/export/#bigtree.dag.export.dag_to_list","title":"dag_to_list","text":"<pre><code>dag_to_list(dag)\n</code></pre> <p>Export DAG to list of tuples containing parent-child names</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import DAGNode, dag_to_list\n&gt;&gt;&gt; a = DAGNode(\"a\", step=1)\n&gt;&gt;&gt; b = DAGNode(\"b\", step=1)\n&gt;&gt;&gt; c = DAGNode(\"c\", step=2, parents=[a, b])\n&gt;&gt;&gt; d = DAGNode(\"d\", step=2, parents=[a, c])\n&gt;&gt;&gt; e = DAGNode(\"e\", step=3, parents=[d])\n&gt;&gt;&gt; dag_to_list(a)\n[('a', 'c'), ('a', 'd'), ('b', 'c'), ('c', 'd'), ('d', 'e')]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>dag</code> <code>DAGNode</code> <p>DAG to be exported</p> required <p>Returns:</p> Type Description <code>List[Tuple[str, str]]</code> <p>(List[Tuple[str, str]])</p>"},{"location":"bigtree/dag/export/#bigtree.dag.export.dag_to_dict","title":"dag_to_dict","text":"<pre><code>dag_to_dict(\n    dag, parent_key=\"parents\", attr_dict={}, all_attrs=False\n)\n</code></pre> <p>Export DAG to dictionary.</p> <p>Exported dictionary will have key as child name, and parent names and node attributes as a nested dictionary.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import DAGNode, dag_to_dict\n&gt;&gt;&gt; a = DAGNode(\"a\", step=1)\n&gt;&gt;&gt; b = DAGNode(\"b\", step=1)\n&gt;&gt;&gt; c = DAGNode(\"c\", step=2, parents=[a, b])\n&gt;&gt;&gt; d = DAGNode(\"d\", step=2, parents=[a, c])\n&gt;&gt;&gt; e = DAGNode(\"e\", step=3, parents=[d])\n&gt;&gt;&gt; dag_to_dict(a, parent_key=\"parent\", attr_dict={\"step\": \"step no.\"})\n{'a': {'step no.': 1}, 'c': {'parent': ['a', 'b'], 'step no.': 2}, 'd': {'parent': ['a', 'c'], 'step no.': 2}, 'b': {'step no.': 1}, 'e': {'parent': ['d'], 'step no.': 3}}\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>dag</code> <code>DAGNode</code> <p>DAG to be exported</p> required <code>parent_key</code> <code>str</code> <p>dictionary key for <code>node.parent.node_name</code>, defaults to <code>parents</code></p> <code>'parents'</code> <code>attr_dict</code> <code>Dict[str, str]</code> <p>dictionary mapping node attributes to dictionary key, key: node attributes, value: corresponding dictionary key, optional</p> <code>{}</code> <code>all_attrs</code> <code>bool</code> <p>indicator whether to retrieve all <code>Node</code> attributes, defaults to False</p> <code>False</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>(Dict[str, Any])</p>"},{"location":"bigtree/dag/export/#bigtree.dag.export.dag_to_dataframe","title":"dag_to_dataframe","text":"<pre><code>dag_to_dataframe(\n    dag,\n    name_col=\"name\",\n    parent_col=\"parent\",\n    attr_dict={},\n    all_attrs=False,\n)\n</code></pre> <p>Export DAG to pandas DataFrame.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import DAGNode, dag_to_dataframe\n&gt;&gt;&gt; a = DAGNode(\"a\", step=1)\n&gt;&gt;&gt; b = DAGNode(\"b\", step=1)\n&gt;&gt;&gt; c = DAGNode(\"c\", step=2, parents=[a, b])\n&gt;&gt;&gt; d = DAGNode(\"d\", step=2, parents=[a, c])\n&gt;&gt;&gt; e = DAGNode(\"e\", step=3, parents=[d])\n&gt;&gt;&gt; dag_to_dataframe(a, name_col=\"name\", parent_col=\"parent\", attr_dict={\"step\": \"step no.\"})\n  name parent  step no.\n0    a   None         1\n1    c      a         2\n2    d      a         2\n3    b   None         1\n4    c      b         2\n5    d      c         2\n6    e      d         3\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>dag</code> <code>DAGNode</code> <p>DAG to be exported</p> required <code>name_col</code> <code>str</code> <p>column name for <code>node.node_name</code>, defaults to 'name'</p> <code>'name'</code> <code>parent_col</code> <code>str</code> <p>column name for <code>node.parent.node_name</code>, defaults to 'parent'</p> <code>'parent'</code> <code>attr_dict</code> <code>Dict[str, str]</code> <p>dictionary mapping node attributes to column name, key: node attributes, value: corresponding column in dataframe, optional</p> <code>{}</code> <code>all_attrs</code> <code>bool</code> <p>indicator whether to retrieve all <code>Node</code> attributes, defaults to False</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>(pd.DataFrame)</p>"},{"location":"bigtree/dag/export/#bigtree.dag.export.dag_to_dot","title":"dag_to_dot","text":"<pre><code>dag_to_dot(\n    dag,\n    rankdir=\"TB\",\n    bg_colour=\"\",\n    node_colour=\"\",\n    node_shape=\"\",\n    edge_colour=\"\",\n    node_attr=\"\",\n    edge_attr=\"\",\n)\n</code></pre> <p>Export DAG or list of DAGs to image. Note that node names must be unique. Possible node attributes include style, fillcolor, shape.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import DAGNode, dag_to_dot\n&gt;&gt;&gt; a = DAGNode(\"a\", step=1)\n&gt;&gt;&gt; b = DAGNode(\"b\", step=1)\n&gt;&gt;&gt; c = DAGNode(\"c\", step=2, parents=[a, b])\n&gt;&gt;&gt; d = DAGNode(\"d\", step=2, parents=[a, c])\n&gt;&gt;&gt; e = DAGNode(\"e\", step=3, parents=[d])\n&gt;&gt;&gt; dag_graph = dag_to_dot(a)\n</code></pre> <p>Display image directly without saving (requires IPython)</p> <pre><code>&gt;&gt;&gt; from IPython.display import Image, display\n&gt;&gt;&gt; plt = Image(dag_graph.create_png())\n&gt;&gt;&gt; display(plt)\n&lt;IPython.core.display.Image object&gt;\n</code></pre> <p>Export to image, dot file, etc.</p> <pre><code>&gt;&gt;&gt; dag_graph.write_png(\"assets/docstr/tree_dag.png\")\n&gt;&gt;&gt; dag_graph.write_dot(\"assets/docstr/tree_dag.dot\")\n</code></pre> <p>Export to string</p> <pre><code>&gt;&gt;&gt; dag_graph.to_string()\n'strict digraph G {\\nrankdir=TB;\\nc [label=c];\\na [label=a];\\na -&gt; c;\\nd [label=d];\\na [label=a];\\na -&gt; d;\\nc [label=c];\\nb [label=b];\\nb -&gt; c;\\nd [label=d];\\nc [label=c];\\nc -&gt; d;\\ne [label=e];\\nd [label=d];\\nd -&gt; e;\\n}\\n'\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>dag</code> <code>Union[DAGNode, List[DAGNode]]</code> <p>DAG or list of DAGs to be exported</p> required <code>rankdir</code> <code>str</code> <p>set direction of graph layout, defaults to 'TB', can be 'BT, 'LR', 'RL'</p> <code>'TB'</code> <code>bg_colour</code> <code>str</code> <p>background color of image, defaults to ''</p> <code>''</code> <code>node_colour</code> <code>str</code> <p>fill colour of nodes, defaults to ''</p> <code>''</code> <code>node_shape</code> <code>str</code> <p>shape of nodes, defaults to None Possible node_shape include \"circle\", \"square\", \"diamond\", \"triangle\"</p> <code>''</code> <code>edge_colour</code> <code>str</code> <p>colour of edges, defaults to ''</p> <code>''</code> <code>node_attr</code> <code>str</code> <p>node attribute for style, overrides node_colour, defaults to '' Possible node attributes include {\"style\": \"filled\", \"fillcolor\": \"gold\"}</p> <code>''</code> <code>edge_attr</code> <code>str</code> <p>edge attribute for style, overrides edge_colour, defaults to '' Possible edge attributes include {\"style\": \"bold\", \"label\": \"edge label\", \"color\": \"black\"}</p> <code>''</code> <p>Returns:</p> Type Description <code>Dot</code> <p>(pydot.Dot)</p>"},{"location":"bigtree/node/","title":"\ud83c\udf3f Node","text":""},{"location":"bigtree/node/basenode/","title":"\ud83c\udf31 BaseNode","text":""},{"location":"bigtree/node/basenode/#bigtree.node.basenode","title":"bigtree.node.basenode","text":""},{"location":"bigtree/node/basenode/#bigtree.node.basenode.BaseNode","title":"BaseNode","text":"<pre><code>BaseNode(parent=None, children=None, **kwargs)\n</code></pre> <p>BaseNode extends any Python class to a tree node. Nodes can have attributes if they are initialized from <code>Node</code>, dictionary, or pandas DataFrame.</p> <p>Nodes can be linked to each other with <code>parent</code> and <code>children</code> setter methods, or using bitshift operator with the convention <code>parent_node &gt;&gt; child_node</code> or <code>child_node &lt;&lt; parent_node</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, print_tree\n&gt;&gt;&gt; root = Node(\"a\", age=90)\n&gt;&gt;&gt; b = Node(\"b\", age=65)\n&gt;&gt;&gt; c = Node(\"c\", age=60)\n&gt;&gt;&gt; d = Node(\"d\", age=40)\n&gt;&gt;&gt; root.children = [b, c]\n&gt;&gt;&gt; d.parent = b\n&gt;&gt;&gt; print_tree(root, attr_list=[\"age\"])\na [age=90]\n\u251c\u2500\u2500 b [age=65]\n\u2502   \u2514\u2500\u2500 d [age=40]\n\u2514\u2500\u2500 c [age=60]\n</code></pre> <pre><code>&gt;&gt;&gt; from bigtree import Node\n&gt;&gt;&gt; root = Node(\"a\", age=90)\n&gt;&gt;&gt; b = Node(\"b\", age=65)\n&gt;&gt;&gt; c = Node(\"c\", age=60)\n&gt;&gt;&gt; d = Node(\"d\", age=40)\n&gt;&gt;&gt; root &gt;&gt; b\n&gt;&gt;&gt; root &gt;&gt; c\n&gt;&gt;&gt; d &lt;&lt; b\n&gt;&gt;&gt; print_tree(root, attr_list=[\"age\"])\na [age=90]\n\u251c\u2500\u2500 b [age=65]\n\u2502   \u2514\u2500\u2500 d [age=40]\n\u2514\u2500\u2500 c [age=60]\n</code></pre> <p>Directly passing <code>parent</code> argument.</p> <pre><code>&gt;&gt;&gt; from bigtree import Node\n&gt;&gt;&gt; root = Node(\"a\")\n&gt;&gt;&gt; b = Node(\"b\", parent=root)\n&gt;&gt;&gt; c = Node(\"c\", parent=root)\n&gt;&gt;&gt; d = Node(\"d\", parent=b)\n</code></pre> <p>Directly passing <code>children</code> argument.</p> <pre><code>&gt;&gt;&gt; from bigtree import Node\n&gt;&gt;&gt; d = Node(\"d\")\n&gt;&gt;&gt; c = Node(\"c\")\n&gt;&gt;&gt; b = Node(\"b\", children=[d])\n&gt;&gt;&gt; a = Node(\"a\", children=[b, c])\n</code></pre> <p>BaseNode Creation</p> <p>Node can be created by instantiating a <code>BaseNode</code> class or by using a dictionary. If node is created with dictionary, all keys of dictionary will be stored as class attributes.</p> <pre><code>&gt;&gt;&gt; from bigtree import Node\n&gt;&gt;&gt; root = Node.from_dict({\"name\": \"a\", \"age\": 90})\n</code></pre> <p>BaseNode Attributes</p> <p>These are node attributes that have getter and/or setter methods.</p> <p>Get and set other <code>BaseNode</code></p> <ol> <li><code>parent</code>: Get/set parent node</li> <li><code>children</code>: Get/set child nodes</li> </ol> <p>Get other <code>BaseNode</code></p> <ol> <li><code>ancestors</code>: Get ancestors of node excluding self, iterator</li> <li><code>descendants</code>: Get descendants of node excluding self, iterator</li> <li><code>leaves</code>: Get all leaf node(s) from self, iterator</li> <li><code>siblings</code>: Get siblings of self</li> <li><code>left_sibling</code>: Get sibling left of self</li> <li><code>right_sibling</code>: Get sibling right of self</li> </ol> <p>Get <code>BaseNode</code> configuration</p> <ol> <li><code>node_path</code>: Get tuple of nodes from root</li> <li><code>is_root</code>: Get indicator if self is root node</li> <li><code>is_leaf</code>: Get indicator if self is leaf node</li> <li><code>root</code>: Get root node of tree</li> <li><code>depth</code>: Get depth of self</li> <li><code>max_depth</code>: Get maximum depth from root to leaf node</li> </ol> <p>BaseNode Methods</p> <p>These are methods available to be performed on <code>BaseNode</code>.</p> <p>Constructor methods</p> <ol> <li><code>from_dict()</code>: Create BaseNode from dictionary</li> </ol> <p><code>BaseNode</code> methods</p> <ol> <li><code>describe()</code>: Get node information sorted by attributes, return list of tuples</li> <li><code>get_attr(attr_name: str)</code>: Get value of node attribute</li> <li><code>set_attrs(attrs: dict)</code>: Set node attribute name(s) and value(s)</li> <li><code>go_to(node: Self)</code>: Get a path from own node to another node from same tree</li> <li><code>append(node: Self)</code>: Add child to node</li> <li><code>extend(nodes: List[Self])</code>: Add multiple children to node</li> <li><code>copy()</code>: Deep copy self</li> <li><code>sort()</code>: Sort child nodes</li> </ol>"},{"location":"bigtree/node/basenode/#bigtree.node.basenode.BaseNode.parent","title":"parent  <code>property</code> <code>writable</code>","text":"<pre><code>parent\n</code></pre> <p>Get parent node</p> <p>Returns:</p> Type Description <code>Optional[T]</code> <p>(Optional[Self])</p>"},{"location":"bigtree/node/basenode/#bigtree.node.basenode.BaseNode.parents","title":"parents  <code>property</code> <code>writable</code>","text":"<pre><code>parents\n</code></pre> <p>Do not allow <code>parents</code> attribute to be accessed</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>No such attribute</p>"},{"location":"bigtree/node/basenode/#bigtree.node.basenode.BaseNode.children","title":"children  <code>deletable</code> <code>property</code> <code>writable</code>","text":"<pre><code>children\n</code></pre> <p>Get child nodes</p> <p>Returns:</p> Type Description <code>Tuple[T, ...]</code> <p>(Tuple[Self, ...])</p>"},{"location":"bigtree/node/basenode/#bigtree.node.basenode.BaseNode.ancestors","title":"ancestors  <code>property</code>","text":"<pre><code>ancestors\n</code></pre> <p>Get iterator to yield all ancestors of self, does not include self</p> <p>Returns:</p> Type Description <code>Iterable[T]</code> <p>(Iterable[Self])</p>"},{"location":"bigtree/node/basenode/#bigtree.node.basenode.BaseNode.descendants","title":"descendants  <code>property</code>","text":"<pre><code>descendants\n</code></pre> <p>Get iterator to yield all descendants of self, does not include self</p> <p>Returns:</p> Type Description <code>Iterable[T]</code> <p>(Iterable[Self])</p>"},{"location":"bigtree/node/basenode/#bigtree.node.basenode.BaseNode.leaves","title":"leaves  <code>property</code>","text":"<pre><code>leaves\n</code></pre> <p>Get iterator to yield all leaf nodes from self</p> <p>Returns:</p> Type Description <code>Iterable[T]</code> <p>(Iterable[Self])</p>"},{"location":"bigtree/node/basenode/#bigtree.node.basenode.BaseNode.siblings","title":"siblings  <code>property</code>","text":"<pre><code>siblings\n</code></pre> <p>Get siblings of self</p> <p>Returns:</p> Type Description <code>Iterable[T]</code> <p>(Iterable[Self])</p>"},{"location":"bigtree/node/basenode/#bigtree.node.basenode.BaseNode.left_sibling","title":"left_sibling  <code>property</code>","text":"<pre><code>left_sibling\n</code></pre> <p>Get sibling left of self</p> <p>Returns:</p> Type Description <code>T</code> <p>(Self)</p>"},{"location":"bigtree/node/basenode/#bigtree.node.basenode.BaseNode.right_sibling","title":"right_sibling  <code>property</code>","text":"<pre><code>right_sibling\n</code></pre> <p>Get sibling right of self</p> <p>Returns:</p> Type Description <code>T</code> <p>(Self)</p>"},{"location":"bigtree/node/basenode/#bigtree.node.basenode.BaseNode.node_path","title":"node_path  <code>property</code>","text":"<pre><code>node_path\n</code></pre> <p>Get tuple of nodes starting from root</p> <p>Returns:</p> Type Description <code>Iterable[T]</code> <p>(Iterable[Self])</p>"},{"location":"bigtree/node/basenode/#bigtree.node.basenode.BaseNode.is_root","title":"is_root  <code>property</code>","text":"<pre><code>is_root\n</code></pre> <p>Get indicator if self is root node</p> <p>Returns:</p> Type Description <code>bool</code> <p>(bool)</p>"},{"location":"bigtree/node/basenode/#bigtree.node.basenode.BaseNode.is_leaf","title":"is_leaf  <code>property</code>","text":"<pre><code>is_leaf\n</code></pre> <p>Get indicator if self is leaf node</p> <p>Returns:</p> Type Description <code>bool</code> <p>(bool)</p>"},{"location":"bigtree/node/basenode/#bigtree.node.basenode.BaseNode.root","title":"root  <code>property</code>","text":"<pre><code>root\n</code></pre> <p>Get root node of tree</p> <p>Returns:</p> Type Description <code>T</code> <p>(Self)</p>"},{"location":"bigtree/node/basenode/#bigtree.node.basenode.BaseNode.depth","title":"depth  <code>property</code>","text":"<pre><code>depth\n</code></pre> <p>Get depth of self, indexing starts from 1</p> <p>Returns:</p> Type Description <code>int</code> <p>(int)</p>"},{"location":"bigtree/node/basenode/#bigtree.node.basenode.BaseNode.max_depth","title":"max_depth  <code>property</code>","text":"<pre><code>max_depth\n</code></pre> <p>Get maximum depth from root to leaf node</p> <p>Returns:</p> Type Description <code>int</code> <p>(int)</p>"},{"location":"bigtree/node/basenode/#bigtree.node.basenode.BaseNode.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(input_dict)\n</code></pre> <p>Construct node from dictionary, all keys of dictionary will be stored as class attributes Input dictionary must have key <code>name</code> if not <code>Node</code> will not have any name</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node\n&gt;&gt;&gt; a = Node.from_dict({\"name\": \"a\", \"age\": 90})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>input_dict</code> <code>Dict[str, Any]</code> <p>dictionary with node information, key: attribute name, value: attribute value</p> required <p>Returns:</p> Type Description <code>BaseNode</code> <p>(BaseNode)</p>"},{"location":"bigtree/node/basenode/#bigtree.node.basenode.BaseNode.describe","title":"describe","text":"<pre><code>describe(exclude_attributes=[], exclude_prefix='')\n</code></pre> <p>Get node information sorted by attribute name, returns list of tuples</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree.node.node import Node\n&gt;&gt;&gt; a = Node('a', age=90)\n&gt;&gt;&gt; a.describe()\n[('_BaseNode__children', []), ('_BaseNode__parent', None), ('_sep', '/'), ('age', 90), ('name', 'a')]\n&gt;&gt;&gt; a.describe(exclude_prefix=\"_\")\n[('age', 90), ('name', 'a')]\n&gt;&gt;&gt; a.describe(exclude_prefix=\"_\", exclude_attributes=[\"name\"])\n[('age', 90)]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>exclude_attributes</code> <code>List[str]</code> <p>list of attributes to exclude</p> <code>[]</code> <code>exclude_prefix</code> <code>str</code> <p>prefix of attributes to exclude</p> <code>''</code> <p>Returns:</p> Type Description <code>List[Tuple[str, Any]]</code> <p>(List[Tuple[str, Any]])</p>"},{"location":"bigtree/node/basenode/#bigtree.node.basenode.BaseNode.get_attr","title":"get_attr","text":"<pre><code>get_attr(attr_name, default_value=None)\n</code></pre> <p>Get value of node attribute Returns default value if attribute name does not exist</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree.node.node import Node\n&gt;&gt;&gt; a = Node('a', age=90)\n&gt;&gt;&gt; a.get_attr(\"age\")\n90\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>attr_name</code> <code>str</code> <p>attribute name</p> required <code>default_value</code> <code>Any</code> <p>default value if attribute does not exist, defaults to None</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>(Any)</p>"},{"location":"bigtree/node/basenode/#bigtree.node.basenode.BaseNode.set_attrs","title":"set_attrs","text":"<pre><code>set_attrs(attrs)\n</code></pre> <p>Set node attributes</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree.node.node import Node\n&gt;&gt;&gt; a = Node('a')\n&gt;&gt;&gt; a.set_attrs({\"age\": 90})\n&gt;&gt;&gt; a\nNode(/a, age=90)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>attrs</code> <code>Dict[str, Any]</code> <p>attribute dictionary, key: attribute name, value: attribute value</p> required"},{"location":"bigtree/node/basenode/#bigtree.node.basenode.BaseNode.go_to","title":"go_to","text":"<pre><code>go_to(node)\n</code></pre> <p>Get path from current node to specified node from same tree</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, print_tree\n&gt;&gt;&gt; a = Node(name=\"a\")\n&gt;&gt;&gt; b = Node(name=\"b\", parent=a)\n&gt;&gt;&gt; c = Node(name=\"c\", parent=a)\n&gt;&gt;&gt; d = Node(name=\"d\", parent=b)\n&gt;&gt;&gt; e = Node(name=\"e\", parent=b)\n&gt;&gt;&gt; f = Node(name=\"f\", parent=c)\n&gt;&gt;&gt; g = Node(name=\"g\", parent=e)\n&gt;&gt;&gt; h = Node(name=\"h\", parent=e)\n&gt;&gt;&gt; print_tree(a)\na\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 d\n\u2502   \u2514\u2500\u2500 e\n\u2502       \u251c\u2500\u2500 g\n\u2502       \u2514\u2500\u2500 h\n\u2514\u2500\u2500 c\n    \u2514\u2500\u2500 f\n&gt;&gt;&gt; d.go_to(d)\n[Node(/a/b/d, )]\n&gt;&gt;&gt; d.go_to(g)\n[Node(/a/b/d, ), Node(/a/b, ), Node(/a/b/e, ), Node(/a/b/e/g, )]\n&gt;&gt;&gt; d.go_to(f)\n[Node(/a/b/d, ), Node(/a/b, ), Node(/a, ), Node(/a/c, ), Node(/a/c/f, )]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Self</code> <p>node to travel to from current node, inclusive of start and end node</p> required <p>Returns:</p> Type Description <code>Iterable[T]</code> <p>(Iterable[Self])</p>"},{"location":"bigtree/node/basenode/#bigtree.node.basenode.BaseNode.append","title":"append","text":"<pre><code>append(other)\n</code></pre> <p>Add other as child of self</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>other node, child to be added</p> required"},{"location":"bigtree/node/basenode/#bigtree.node.basenode.BaseNode.extend","title":"extend","text":"<pre><code>extend(others)\n</code></pre> <p>Add others as children of self</p> <p>Parameters:</p> Name Type Description Default <code>others</code> <code>Self</code> <p>other nodes, children to be added</p> required"},{"location":"bigtree/node/basenode/#bigtree.node.basenode.BaseNode.copy","title":"copy","text":"<pre><code>copy()\n</code></pre> <p>Deep copy self; clone self</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree.node.node import Node\n&gt;&gt;&gt; a = Node('a')\n&gt;&gt;&gt; a_copy = a.copy()\n</code></pre> <p>Returns:</p> Type Description <code>T</code> <p>(Self)</p>"},{"location":"bigtree/node/basenode/#bigtree.node.basenode.BaseNode.sort","title":"sort","text":"<pre><code>sort(**kwargs)\n</code></pre> <p>Sort children, possible keyword arguments include <code>key=lambda node: node.name</code>, <code>reverse=True</code></p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, print_tree\n&gt;&gt;&gt; a = Node('a')\n&gt;&gt;&gt; c = Node(\"c\", parent=a)\n&gt;&gt;&gt; b = Node(\"b\", parent=a)\n&gt;&gt;&gt; print_tree(a)\na\n\u251c\u2500\u2500 c\n\u2514\u2500\u2500 b\n&gt;&gt;&gt; a.sort(key=lambda node: node.name)\n&gt;&gt;&gt; print_tree(a)\na\n\u251c\u2500\u2500 b\n\u2514\u2500\u2500 c\n</code></pre>"},{"location":"bigtree/node/binarynode/","title":"\ud83c\udf38 BinaryNode","text":""},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode","title":"bigtree.node.binarynode","text":""},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode","title":"BinaryNode","text":"<pre><code>BinaryNode(\n    name=\"\",\n    left=None,\n    right=None,\n    parent=None,\n    children=None,\n    **kwargs\n)\n</code></pre> <p>             Bases: <code>Node</code></p> <p>BinaryNode is an extension of Node, and is able to extend to any Python class for Binary Tree implementation. Nodes can have attributes if they are initialized from <code>BinaryNode</code>, dictionary, or pandas DataFrame.</p> <p>BinaryNode can be linked to each other with <code>children</code>, <code>left</code>, or <code>right</code> setter methods. If initialized with <code>children</code>, it must be length 2, denoting left and right child.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import BinaryNode, print_tree\n&gt;&gt;&gt; a = BinaryNode(1)\n&gt;&gt;&gt; b = BinaryNode(2)\n&gt;&gt;&gt; c = BinaryNode(3)\n&gt;&gt;&gt; d = BinaryNode(4)\n&gt;&gt;&gt; a.children = [b, c]\n&gt;&gt;&gt; b.right = d\n&gt;&gt;&gt; print_tree(a)\n1\n\u251c\u2500\u2500 2\n\u2502   \u2514\u2500\u2500 4\n\u2514\u2500\u2500 3\n</code></pre> <p>Directly passing <code>left</code>, <code>right</code>, or <code>children</code> argument.</p> <pre><code>&gt;&gt;&gt; from bigtree import BinaryNode\n&gt;&gt;&gt; d = BinaryNode(4)\n&gt;&gt;&gt; c = BinaryNode(3)\n&gt;&gt;&gt; b = BinaryNode(2, right=d)\n&gt;&gt;&gt; a = BinaryNode(1, children=[b, c])\n</code></pre> <p>BinaryNode Creation</p> <p>Node can be created by instantiating a <code>BinaryNode</code> class or by using a dictionary. If node is created with dictionary, all keys of dictionary will be stored as class attributes.</p> <pre><code>&gt;&gt;&gt; from bigtree import BinaryNode\n&gt;&gt;&gt; a = BinaryNode.from_dict({\"name\": \"1\"})\n&gt;&gt;&gt; a\nBinaryNode(name=1, val=1)\n</code></pre> <p>BinaryNode Attributes</p> <p>These are node attributes that have getter and/or setter methods.</p> <p>Get <code>BinaryNode</code> configuration</p> <ol> <li><code>left</code>: Get left children</li> <li><code>right</code>: Get right children</li> </ol>"},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode.parents","title":"parents  <code>property</code> <code>writable</code>","text":"<pre><code>parents\n</code></pre> <p>Do not allow <code>parents</code> attribute to be accessed</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>No such attribute</p>"},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode.ancestors","title":"ancestors  <code>property</code>","text":"<pre><code>ancestors\n</code></pre> <p>Get iterator to yield all ancestors of self, does not include self</p> <p>Returns:</p> Type Description <code>Iterable[T]</code> <p>(Iterable[Self])</p>"},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode.descendants","title":"descendants  <code>property</code>","text":"<pre><code>descendants\n</code></pre> <p>Get iterator to yield all descendants of self, does not include self</p> <p>Returns:</p> Type Description <code>Iterable[T]</code> <p>(Iterable[Self])</p>"},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode.leaves","title":"leaves  <code>property</code>","text":"<pre><code>leaves\n</code></pre> <p>Get iterator to yield all leaf nodes from self</p> <p>Returns:</p> Type Description <code>Iterable[T]</code> <p>(Iterable[Self])</p>"},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode.siblings","title":"siblings  <code>property</code>","text":"<pre><code>siblings\n</code></pre> <p>Get siblings of self</p> <p>Returns:</p> Type Description <code>Iterable[T]</code> <p>(Iterable[Self])</p>"},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode.left_sibling","title":"left_sibling  <code>property</code>","text":"<pre><code>left_sibling\n</code></pre> <p>Get sibling left of self</p> <p>Returns:</p> Type Description <code>T</code> <p>(Self)</p>"},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode.right_sibling","title":"right_sibling  <code>property</code>","text":"<pre><code>right_sibling\n</code></pre> <p>Get sibling right of self</p> <p>Returns:</p> Type Description <code>T</code> <p>(Self)</p>"},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode.node_path","title":"node_path  <code>property</code>","text":"<pre><code>node_path\n</code></pre> <p>Get tuple of nodes starting from root</p> <p>Returns:</p> Type Description <code>Iterable[T]</code> <p>(Iterable[Self])</p>"},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode.is_root","title":"is_root  <code>property</code>","text":"<pre><code>is_root\n</code></pre> <p>Get indicator if self is root node</p> <p>Returns:</p> Type Description <code>bool</code> <p>(bool)</p>"},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode.root","title":"root  <code>property</code>","text":"<pre><code>root\n</code></pre> <p>Get root node of tree</p> <p>Returns:</p> Type Description <code>T</code> <p>(Self)</p>"},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode.depth","title":"depth  <code>property</code>","text":"<pre><code>depth\n</code></pre> <p>Get depth of self, indexing starts from 1</p> <p>Returns:</p> Type Description <code>int</code> <p>(int)</p>"},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode.max_depth","title":"max_depth  <code>property</code>","text":"<pre><code>max_depth\n</code></pre> <p>Get maximum depth from root to leaf node</p> <p>Returns:</p> Type Description <code>int</code> <p>(int)</p>"},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode.sep","title":"sep  <code>property</code> <code>writable</code>","text":"<pre><code>sep\n</code></pre> <p>Get separator, gets from root node</p> <p>Returns:</p> Type Description <code>str</code> <p>(str)</p>"},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode.node_name","title":"node_name  <code>property</code>","text":"<pre><code>node_name\n</code></pre> <p>Get node name</p> <p>Returns:</p> Type Description <code>str</code> <p>(str)</p>"},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode.path_name","title":"path_name  <code>property</code>","text":"<pre><code>path_name\n</code></pre> <p>Get path name, separated by self.sep</p> <p>Returns:</p> Type Description <code>str</code> <p>(str)</p>"},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode.left","title":"left  <code>property</code> <code>writable</code>","text":"<pre><code>left\n</code></pre> <p>Get left children</p> <p>Returns:</p> Type Description <code>T</code> <p>(Self)</p>"},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode.right","title":"right  <code>property</code> <code>writable</code>","text":"<pre><code>right\n</code></pre> <p>Get right children</p> <p>Returns:</p> Type Description <code>T</code> <p>(Self)</p>"},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode.parent","title":"parent  <code>property</code> <code>writable</code>","text":"<pre><code>parent\n</code></pre> <p>Get parent node</p> <p>Returns:</p> Type Description <code>Optional[T]</code> <p>(Optional[Self])</p>"},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode.children","title":"children  <code>deletable</code> <code>property</code> <code>writable</code>","text":"<pre><code>children\n</code></pre> <p>Get child nodes</p> <p>Returns:</p> Type Description <code>Tuple[T, ...]</code> <p>(Tuple[Optional[Self]])</p>"},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode.is_leaf","title":"is_leaf  <code>property</code>","text":"<pre><code>is_leaf\n</code></pre> <p>Get indicator if self is leaf node</p> <p>Returns:</p> Type Description <code>bool</code> <p>(bool)</p>"},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(input_dict)\n</code></pre> <p>Construct node from dictionary, all keys of dictionary will be stored as class attributes Input dictionary must have key <code>name</code> if not <code>Node</code> will not have any name</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node\n&gt;&gt;&gt; a = Node.from_dict({\"name\": \"a\", \"age\": 90})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>input_dict</code> <code>Dict[str, Any]</code> <p>dictionary with node information, key: attribute name, value: attribute value</p> required <p>Returns:</p> Type Description <code>BaseNode</code> <p>(BaseNode)</p>"},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode.describe","title":"describe","text":"<pre><code>describe(exclude_attributes=[], exclude_prefix='')\n</code></pre> <p>Get node information sorted by attribute name, returns list of tuples</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree.node.node import Node\n&gt;&gt;&gt; a = Node('a', age=90)\n&gt;&gt;&gt; a.describe()\n[('_BaseNode__children', []), ('_BaseNode__parent', None), ('_sep', '/'), ('age', 90), ('name', 'a')]\n&gt;&gt;&gt; a.describe(exclude_prefix=\"_\")\n[('age', 90), ('name', 'a')]\n&gt;&gt;&gt; a.describe(exclude_prefix=\"_\", exclude_attributes=[\"name\"])\n[('age', 90)]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>exclude_attributes</code> <code>List[str]</code> <p>list of attributes to exclude</p> <code>[]</code> <code>exclude_prefix</code> <code>str</code> <p>prefix of attributes to exclude</p> <code>''</code> <p>Returns:</p> Type Description <code>List[Tuple[str, Any]]</code> <p>(List[Tuple[str, Any]])</p>"},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode.get_attr","title":"get_attr","text":"<pre><code>get_attr(attr_name, default_value=None)\n</code></pre> <p>Get value of node attribute Returns default value if attribute name does not exist</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree.node.node import Node\n&gt;&gt;&gt; a = Node('a', age=90)\n&gt;&gt;&gt; a.get_attr(\"age\")\n90\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>attr_name</code> <code>str</code> <p>attribute name</p> required <code>default_value</code> <code>Any</code> <p>default value if attribute does not exist, defaults to None</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>(Any)</p>"},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode.set_attrs","title":"set_attrs","text":"<pre><code>set_attrs(attrs)\n</code></pre> <p>Set node attributes</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree.node.node import Node\n&gt;&gt;&gt; a = Node('a')\n&gt;&gt;&gt; a.set_attrs({\"age\": 90})\n&gt;&gt;&gt; a\nNode(/a, age=90)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>attrs</code> <code>Dict[str, Any]</code> <p>attribute dictionary, key: attribute name, value: attribute value</p> required"},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode.go_to","title":"go_to","text":"<pre><code>go_to(node)\n</code></pre> <p>Get path from current node to specified node from same tree</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, print_tree\n&gt;&gt;&gt; a = Node(name=\"a\")\n&gt;&gt;&gt; b = Node(name=\"b\", parent=a)\n&gt;&gt;&gt; c = Node(name=\"c\", parent=a)\n&gt;&gt;&gt; d = Node(name=\"d\", parent=b)\n&gt;&gt;&gt; e = Node(name=\"e\", parent=b)\n&gt;&gt;&gt; f = Node(name=\"f\", parent=c)\n&gt;&gt;&gt; g = Node(name=\"g\", parent=e)\n&gt;&gt;&gt; h = Node(name=\"h\", parent=e)\n&gt;&gt;&gt; print_tree(a)\na\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 d\n\u2502   \u2514\u2500\u2500 e\n\u2502       \u251c\u2500\u2500 g\n\u2502       \u2514\u2500\u2500 h\n\u2514\u2500\u2500 c\n    \u2514\u2500\u2500 f\n&gt;&gt;&gt; d.go_to(d)\n[Node(/a/b/d, )]\n&gt;&gt;&gt; d.go_to(g)\n[Node(/a/b/d, ), Node(/a/b, ), Node(/a/b/e, ), Node(/a/b/e/g, )]\n&gt;&gt;&gt; d.go_to(f)\n[Node(/a/b/d, ), Node(/a/b, ), Node(/a, ), Node(/a/c, ), Node(/a/c/f, )]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Self</code> <p>node to travel to from current node, inclusive of start and end node</p> required <p>Returns:</p> Type Description <code>Iterable[T]</code> <p>(Iterable[Self])</p>"},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode.append","title":"append","text":"<pre><code>append(other)\n</code></pre> <p>Add other as child of self</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>other node, child to be added</p> required"},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode.extend","title":"extend","text":"<pre><code>extend(others)\n</code></pre> <p>Add others as children of self</p> <p>Parameters:</p> Name Type Description Default <code>others</code> <code>Self</code> <p>other nodes, children to be added</p> required"},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode.copy","title":"copy","text":"<pre><code>copy()\n</code></pre> <p>Deep copy self; clone self</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree.node.node import Node\n&gt;&gt;&gt; a = Node('a')\n&gt;&gt;&gt; a_copy = a.copy()\n</code></pre> <p>Returns:</p> Type Description <code>T</code> <p>(Self)</p>"},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode.show","title":"show","text":"<pre><code>show(**kwargs)\n</code></pre> <p>Print tree to console, takes in same keyword arguments as <code>print_tree</code> function</p>"},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode.hshow","title":"hshow","text":"<pre><code>hshow(**kwargs)\n</code></pre> <p>Print tree in horizontal orientation to console, takes in same keyword arguments as <code>hprint_tree</code> function</p>"},{"location":"bigtree/node/binarynode/#bigtree.node.binarynode.BinaryNode.sort","title":"sort","text":"<pre><code>sort(**kwargs)\n</code></pre> <p>Sort children, possible keyword arguments include <code>key=lambda node: node.val</code>, <code>reverse=True</code></p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import BinaryNode, print_tree\n&gt;&gt;&gt; a = BinaryNode(1)\n&gt;&gt;&gt; c = BinaryNode(3, parent=a)\n&gt;&gt;&gt; b = BinaryNode(2, parent=a)\n&gt;&gt;&gt; print_tree(a)\n1\n\u251c\u2500\u2500 3\n\u2514\u2500\u2500 2\n&gt;&gt;&gt; a.sort(key=lambda node: node.val)\n&gt;&gt;&gt; print_tree(a)\n1\n\u251c\u2500\u2500 2\n\u2514\u2500\u2500 3\n</code></pre>"},{"location":"bigtree/node/dagnode/","title":"\ud83c\udf3c DAGNode","text":""},{"location":"bigtree/node/dagnode/#bigtree.node.dagnode","title":"bigtree.node.dagnode","text":""},{"location":"bigtree/node/dagnode/#bigtree.node.dagnode.DAGNode","title":"DAGNode","text":"<pre><code>DAGNode(name='', parents=None, children=None, **kwargs)\n</code></pre> <p>Base DAGNode extends any Python class to a DAG node, for DAG implementation. In DAG implementation, a node can have multiple parents.</p> <p>Parents and children cannot be reassigned once assigned, as Nodes are allowed to have multiple parents and children. If each node only has one parent, use <code>Node</code> class. DAGNodes can have attributes if they are initialized from <code>DAGNode</code> or dictionary.</p> <p>DAGNode can be linked to each other with <code>parents</code> and <code>children</code> setter methods, or using bitshift operator with the convention <code>parent_node &gt;&gt; child_node</code> or <code>child_node &lt;&lt; parent_node</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import DAGNode\n&gt;&gt;&gt; a = DAGNode(\"a\")\n&gt;&gt;&gt; b = DAGNode(\"b\")\n&gt;&gt;&gt; c = DAGNode(\"c\")\n&gt;&gt;&gt; d = DAGNode(\"d\")\n&gt;&gt;&gt; c.parents = [a, b]\n&gt;&gt;&gt; c.children = [d]\n</code></pre> <pre><code>&gt;&gt;&gt; from bigtree import DAGNode\n&gt;&gt;&gt; a = DAGNode(\"a\")\n&gt;&gt;&gt; b = DAGNode(\"b\")\n&gt;&gt;&gt; c = DAGNode(\"c\")\n&gt;&gt;&gt; d = DAGNode(\"d\")\n&gt;&gt;&gt; a &gt;&gt; c\n&gt;&gt;&gt; b &gt;&gt; c\n&gt;&gt;&gt; d &lt;&lt; c\n</code></pre> <p>Directly passing <code>parents</code> argument.</p> <pre><code>&gt;&gt;&gt; from bigtree import DAGNode\n&gt;&gt;&gt; a = DAGNode(\"a\")\n&gt;&gt;&gt; b = DAGNode(\"b\")\n&gt;&gt;&gt; c = DAGNode(\"c\", parents=[a, b])\n&gt;&gt;&gt; d = DAGNode(\"d\", parents=[c])\n</code></pre> <p>Directly passing <code>children</code> argument.</p> <pre><code>&gt;&gt;&gt; from bigtree import DAGNode\n&gt;&gt;&gt; d = DAGNode(\"d\")\n&gt;&gt;&gt; c = DAGNode(\"c\", children=[d])\n&gt;&gt;&gt; b = DAGNode(\"b\", children=[c])\n&gt;&gt;&gt; a = DAGNode(\"a\", children=[c])\n</code></pre> <p>DAGNode Creation</p> <p>Node can be created by instantiating a <code>DAGNode</code> class or by using a dictionary. If node is created with dictionary, all keys of dictionary will be stored as class attributes.</p> <pre><code>&gt;&gt;&gt; from bigtree import DAGNode\n&gt;&gt;&gt; a = DAGNode.from_dict({\"name\": \"a\", \"age\": 90})\n</code></pre> <p>DAGNode Attributes</p> <p>These are node attributes that have getter and/or setter methods.</p> <p>Get and set other <code>DAGNode</code></p> <ol> <li><code>parents</code>: Get/set parent nodes</li> <li><code>children</code>: Get/set child nodes</li> </ol> <p>Get other <code>DAGNode</code></p> <ol> <li><code>ancestors</code>: Get ancestors of node excluding self, iterator</li> <li><code>descendants</code>: Get descendants of node excluding self, iterator</li> <li><code>siblings</code>: Get siblings of self</li> </ol> <p>Get <code>DAGNode</code> configuration</p> <ol> <li><code>node_name</code>: Get node name, without accessing <code>name</code> directly</li> <li><code>is_root</code>: Get indicator if self is root node</li> <li><code>is_leaf</code>: Get indicator if self is leaf node</li> </ol> <p>DAGNode Methods</p> <p>These are methods available to be performed on <code>DAGNode</code>.</p> <p>Constructor methods</p> <ol> <li><code>from_dict()</code>: Create DAGNode from dictionary</li> </ol> <p><code>DAGNode</code> methods</p> <ol> <li><code>describe()</code>: Get node information sorted by attributes, return list of tuples</li> <li><code>get_attr(attr_name: str)</code>: Get value of node attribute</li> <li><code>set_attrs(attrs: dict)</code>: Set node attribute name(s) and value(s)</li> <li><code>go_to(node: Self)</code>: Get a path from own node to another node from same DAG</li> <li><code>copy()</code>: Deep copy self</li> </ol>"},{"location":"bigtree/node/dagnode/#bigtree.node.dagnode.DAGNode.parent","title":"parent  <code>property</code> <code>writable</code>","text":"<pre><code>parent\n</code></pre> <p>Do not allow <code>parent</code> attribute to be accessed</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>No such attribute</p>"},{"location":"bigtree/node/dagnode/#bigtree.node.dagnode.DAGNode.parents","title":"parents  <code>property</code> <code>writable</code>","text":"<pre><code>parents\n</code></pre> <p>Get parent nodes</p> <p>Returns:</p> Type Description <code>Iterable[T]</code> <p>(Iterable[Self])</p>"},{"location":"bigtree/node/dagnode/#bigtree.node.dagnode.DAGNode.children","title":"children  <code>deletable</code> <code>property</code> <code>writable</code>","text":"<pre><code>children\n</code></pre> <p>Get child nodes</p> <p>Returns:</p> Type Description <code>Iterable[T]</code> <p>(Iterable[Self])</p>"},{"location":"bigtree/node/dagnode/#bigtree.node.dagnode.DAGNode.ancestors","title":"ancestors  <code>property</code>","text":"<pre><code>ancestors\n</code></pre> <p>Get iterator to yield all ancestors of self, does not include self</p> <p>Returns:</p> Type Description <code>Iterable[T]</code> <p>(Iterable[Self])</p>"},{"location":"bigtree/node/dagnode/#bigtree.node.dagnode.DAGNode.descendants","title":"descendants  <code>property</code>","text":"<pre><code>descendants\n</code></pre> <p>Get iterator to yield all descendants of self, does not include self</p> <p>Returns:</p> Type Description <code>Iterable[T]</code> <p>(Iterable[Self])</p>"},{"location":"bigtree/node/dagnode/#bigtree.node.dagnode.DAGNode.siblings","title":"siblings  <code>property</code>","text":"<pre><code>siblings\n</code></pre> <p>Get siblings of self</p> <p>Returns:</p> Type Description <code>Iterable[T]</code> <p>(Iterable[Self])</p>"},{"location":"bigtree/node/dagnode/#bigtree.node.dagnode.DAGNode.node_name","title":"node_name  <code>property</code>","text":"<pre><code>node_name\n</code></pre> <p>Get node name</p> <p>Returns:</p> Type Description <code>str</code> <p>(str)</p>"},{"location":"bigtree/node/dagnode/#bigtree.node.dagnode.DAGNode.is_root","title":"is_root  <code>property</code>","text":"<pre><code>is_root\n</code></pre> <p>Get indicator if self is root node</p> <p>Returns:</p> Type Description <code>bool</code> <p>(bool)</p>"},{"location":"bigtree/node/dagnode/#bigtree.node.dagnode.DAGNode.is_leaf","title":"is_leaf  <code>property</code>","text":"<pre><code>is_leaf\n</code></pre> <p>Get indicator if self is leaf node</p> <p>Returns:</p> Type Description <code>bool</code> <p>(bool)</p>"},{"location":"bigtree/node/dagnode/#bigtree.node.dagnode.DAGNode.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(input_dict)\n</code></pre> <p>Construct node from dictionary, all keys of dictionary will be stored as class attributes Input dictionary must have key <code>name</code> if not <code>Node</code> will not have any name</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import DAGNode\n&gt;&gt;&gt; a = DAGNode.from_dict({\"name\": \"a\", \"age\": 90})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>input_dict</code> <code>Dict[str, Any]</code> <p>dictionary with node information, key: attribute name, value: attribute value</p> required <p>Returns:</p> Type Description <code>DAGNode</code> <p>(DAGNode)</p>"},{"location":"bigtree/node/dagnode/#bigtree.node.dagnode.DAGNode.describe","title":"describe","text":"<pre><code>describe(exclude_attributes=[], exclude_prefix='')\n</code></pre> <p>Get node information sorted by attribute name, returns list of tuples</p> <p>Parameters:</p> Name Type Description Default <code>exclude_attributes</code> <code>List[str]</code> <p>list of attributes to exclude</p> <code>[]</code> <code>exclude_prefix</code> <code>str</code> <p>prefix of attributes to exclude</p> <code>''</code> <p>Returns:</p> Type Description <code>List[Tuple[str, Any]]</code> <p>(List[Tuple[str, Any]])</p>"},{"location":"bigtree/node/dagnode/#bigtree.node.dagnode.DAGNode.get_attr","title":"get_attr","text":"<pre><code>get_attr(attr_name, default_value=None)\n</code></pre> <p>Get value of node attribute Returns default value if attribute name does not exist</p> <p>Parameters:</p> Name Type Description Default <code>attr_name</code> <code>str</code> <p>attribute name</p> required <code>default_value</code> <code>Any</code> <p>default value if attribute does not exist, defaults to None</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>(Any)</p>"},{"location":"bigtree/node/dagnode/#bigtree.node.dagnode.DAGNode.set_attrs","title":"set_attrs","text":"<pre><code>set_attrs(attrs)\n</code></pre> <p>Set node attributes</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree.node.dagnode import DAGNode\n&gt;&gt;&gt; a = DAGNode('a')\n&gt;&gt;&gt; a.set_attrs({\"age\": 90})\n&gt;&gt;&gt; a\nDAGNode(a, age=90)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>attrs</code> <code>Dict[str, Any]</code> <p>attribute dictionary, key: attribute name, value: attribute value</p> required"},{"location":"bigtree/node/dagnode/#bigtree.node.dagnode.DAGNode.go_to","title":"go_to","text":"<pre><code>go_to(node)\n</code></pre> <p>Get list of possible paths from current node to specified node from same tree</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import DAGNode\n&gt;&gt;&gt; a = DAGNode(\"a\")\n&gt;&gt;&gt; b = DAGNode(\"b\")\n&gt;&gt;&gt; c = DAGNode(\"c\")\n&gt;&gt;&gt; d = DAGNode(\"d\")\n&gt;&gt;&gt; a &gt;&gt; c\n&gt;&gt;&gt; b &gt;&gt; c\n&gt;&gt;&gt; c &gt;&gt; d\n&gt;&gt;&gt; a &gt;&gt; d\n&gt;&gt;&gt; a.go_to(c)\n[[DAGNode(a, ), DAGNode(c, )]]\n&gt;&gt;&gt; a.go_to(d)\n[[DAGNode(a, ), DAGNode(c, ), DAGNode(d, )], [DAGNode(a, ), DAGNode(d, )]]\n&gt;&gt;&gt; a.go_to(b)\nTraceback (most recent call last):\n    ...\nbigtree.utils.exceptions.TreeError: It is not possible to go to DAGNode(b, )\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Self</code> <p>node to travel to from current node, inclusive of start and end node</p> required <p>Returns:</p> Type Description <code>List[List[T]]</code> <p>(List[List[Self]])</p>"},{"location":"bigtree/node/dagnode/#bigtree.node.dagnode.DAGNode.copy","title":"copy","text":"<pre><code>copy()\n</code></pre> <p>Deep copy self; clone DAGNode</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree.node.dagnode import DAGNode\n&gt;&gt;&gt; a = DAGNode('a')\n&gt;&gt;&gt; a_copy = a.copy()\n</code></pre> <p>Returns:</p> Type Description <code>T</code> <p>(Self)</p>"},{"location":"bigtree/node/node/","title":"\ud83c\udf3a Node","text":""},{"location":"bigtree/node/node/#bigtree.node.node","title":"bigtree.node.node","text":""},{"location":"bigtree/node/node/#bigtree.node.node.Node","title":"Node","text":"<pre><code>Node(name='', sep='/', **kwargs)\n</code></pre> <p>             Bases: <code>BaseNode</code></p> <p>Node is an extension of BaseNode, and is able to extend to any Python class. Nodes can have attributes if they are initialized from <code>Node</code>, dictionary, or pandas DataFrame.</p> <p>Nodes can be linked to each other with <code>parent</code> and <code>children</code> setter methods.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node\n&gt;&gt;&gt; a = Node(\"a\")\n&gt;&gt;&gt; b = Node(\"b\")\n&gt;&gt;&gt; c = Node(\"c\")\n&gt;&gt;&gt; d = Node(\"d\")\n&gt;&gt;&gt; b.parent = a\n&gt;&gt;&gt; b.children = [c, d]\n</code></pre> <p>Directly passing <code>parent</code> argument.</p> <pre><code>&gt;&gt;&gt; from bigtree import Node\n&gt;&gt;&gt; a = Node(\"a\")\n&gt;&gt;&gt; b = Node(\"b\", parent=a)\n&gt;&gt;&gt; c = Node(\"c\", parent=b)\n&gt;&gt;&gt; d = Node(\"d\", parent=b)\n</code></pre> <p>Directly passing <code>children</code> argument.</p> <pre><code>&gt;&gt;&gt; from bigtree import Node\n&gt;&gt;&gt; d = Node(\"d\")\n&gt;&gt;&gt; c = Node(\"c\")\n&gt;&gt;&gt; b = Node(\"b\", children=[c, d])\n&gt;&gt;&gt; a = Node(\"a\", children=[b])\n</code></pre> <p>Node Creation</p> <p>Node can be created by instantiating a <code>Node</code> class or by using a dictionary. If node is created with dictionary, all keys of dictionary will be stored as class attributes.</p> <pre><code>&gt;&gt;&gt; from bigtree import Node\n&gt;&gt;&gt; a = Node.from_dict({\"name\": \"a\", \"age\": 90})\n</code></pre> <p>Node Attributes</p> <p>These are node attributes that have getter and/or setter methods.</p> <p>Get and set <code>Node</code> configuration</p> <ol> <li><code>sep</code>: Get/set separator for path name</li> </ol> <p>Get <code>Node</code> configuration</p> <ol> <li><code>node_name</code>: Get node name, without accessing <code>name</code> directly</li> <li><code>path_name</code>: Get path name from root, separated by <code>sep</code></li> </ol> <p>Node Methods</p> <p>These are methods available to be performed on <code>Node</code>.</p> <p><code>Node</code> methods</p> <ol> <li><code>show()</code>: Print tree to console</li> <li><code>hshow()</code>: Print tree in horizontal orientation to console</li> </ol>"},{"location":"bigtree/node/node/#bigtree.node.node.Node.parent","title":"parent  <code>property</code> <code>writable</code>","text":"<pre><code>parent\n</code></pre> <p>Get parent node</p> <p>Returns:</p> Type Description <code>Optional[T]</code> <p>(Optional[Self])</p>"},{"location":"bigtree/node/node/#bigtree.node.node.Node.children","title":"children  <code>deletable</code> <code>property</code> <code>writable</code>","text":"<pre><code>children\n</code></pre> <p>Get child nodes</p> <p>Returns:</p> Type Description <code>Tuple[T, ...]</code> <p>(Tuple[Self, ...])</p>"},{"location":"bigtree/node/node/#bigtree.node.node.Node.parents","title":"parents  <code>property</code> <code>writable</code>","text":"<pre><code>parents\n</code></pre> <p>Do not allow <code>parents</code> attribute to be accessed</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>No such attribute</p>"},{"location":"bigtree/node/node/#bigtree.node.node.Node.ancestors","title":"ancestors  <code>property</code>","text":"<pre><code>ancestors\n</code></pre> <p>Get iterator to yield all ancestors of self, does not include self</p> <p>Returns:</p> Type Description <code>Iterable[T]</code> <p>(Iterable[Self])</p>"},{"location":"bigtree/node/node/#bigtree.node.node.Node.descendants","title":"descendants  <code>property</code>","text":"<pre><code>descendants\n</code></pre> <p>Get iterator to yield all descendants of self, does not include self</p> <p>Returns:</p> Type Description <code>Iterable[T]</code> <p>(Iterable[Self])</p>"},{"location":"bigtree/node/node/#bigtree.node.node.Node.leaves","title":"leaves  <code>property</code>","text":"<pre><code>leaves\n</code></pre> <p>Get iterator to yield all leaf nodes from self</p> <p>Returns:</p> Type Description <code>Iterable[T]</code> <p>(Iterable[Self])</p>"},{"location":"bigtree/node/node/#bigtree.node.node.Node.siblings","title":"siblings  <code>property</code>","text":"<pre><code>siblings\n</code></pre> <p>Get siblings of self</p> <p>Returns:</p> Type Description <code>Iterable[T]</code> <p>(Iterable[Self])</p>"},{"location":"bigtree/node/node/#bigtree.node.node.Node.left_sibling","title":"left_sibling  <code>property</code>","text":"<pre><code>left_sibling\n</code></pre> <p>Get sibling left of self</p> <p>Returns:</p> Type Description <code>T</code> <p>(Self)</p>"},{"location":"bigtree/node/node/#bigtree.node.node.Node.right_sibling","title":"right_sibling  <code>property</code>","text":"<pre><code>right_sibling\n</code></pre> <p>Get sibling right of self</p> <p>Returns:</p> Type Description <code>T</code> <p>(Self)</p>"},{"location":"bigtree/node/node/#bigtree.node.node.Node.node_path","title":"node_path  <code>property</code>","text":"<pre><code>node_path\n</code></pre> <p>Get tuple of nodes starting from root</p> <p>Returns:</p> Type Description <code>Iterable[T]</code> <p>(Iterable[Self])</p>"},{"location":"bigtree/node/node/#bigtree.node.node.Node.is_root","title":"is_root  <code>property</code>","text":"<pre><code>is_root\n</code></pre> <p>Get indicator if self is root node</p> <p>Returns:</p> Type Description <code>bool</code> <p>(bool)</p>"},{"location":"bigtree/node/node/#bigtree.node.node.Node.is_leaf","title":"is_leaf  <code>property</code>","text":"<pre><code>is_leaf\n</code></pre> <p>Get indicator if self is leaf node</p> <p>Returns:</p> Type Description <code>bool</code> <p>(bool)</p>"},{"location":"bigtree/node/node/#bigtree.node.node.Node.root","title":"root  <code>property</code>","text":"<pre><code>root\n</code></pre> <p>Get root node of tree</p> <p>Returns:</p> Type Description <code>T</code> <p>(Self)</p>"},{"location":"bigtree/node/node/#bigtree.node.node.Node.depth","title":"depth  <code>property</code>","text":"<pre><code>depth\n</code></pre> <p>Get depth of self, indexing starts from 1</p> <p>Returns:</p> Type Description <code>int</code> <p>(int)</p>"},{"location":"bigtree/node/node/#bigtree.node.node.Node.max_depth","title":"max_depth  <code>property</code>","text":"<pre><code>max_depth\n</code></pre> <p>Get maximum depth from root to leaf node</p> <p>Returns:</p> Type Description <code>int</code> <p>(int)</p>"},{"location":"bigtree/node/node/#bigtree.node.node.Node.sep","title":"sep  <code>property</code> <code>writable</code>","text":"<pre><code>sep\n</code></pre> <p>Get separator, gets from root node</p> <p>Returns:</p> Type Description <code>str</code> <p>(str)</p>"},{"location":"bigtree/node/node/#bigtree.node.node.Node.node_name","title":"node_name  <code>property</code>","text":"<pre><code>node_name\n</code></pre> <p>Get node name</p> <p>Returns:</p> Type Description <code>str</code> <p>(str)</p>"},{"location":"bigtree/node/node/#bigtree.node.node.Node.path_name","title":"path_name  <code>property</code>","text":"<pre><code>path_name\n</code></pre> <p>Get path name, separated by self.sep</p> <p>Returns:</p> Type Description <code>str</code> <p>(str)</p>"},{"location":"bigtree/node/node/#bigtree.node.node.Node.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(input_dict)\n</code></pre> <p>Construct node from dictionary, all keys of dictionary will be stored as class attributes Input dictionary must have key <code>name</code> if not <code>Node</code> will not have any name</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node\n&gt;&gt;&gt; a = Node.from_dict({\"name\": \"a\", \"age\": 90})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>input_dict</code> <code>Dict[str, Any]</code> <p>dictionary with node information, key: attribute name, value: attribute value</p> required <p>Returns:</p> Type Description <code>BaseNode</code> <p>(BaseNode)</p>"},{"location":"bigtree/node/node/#bigtree.node.node.Node.describe","title":"describe","text":"<pre><code>describe(exclude_attributes=[], exclude_prefix='')\n</code></pre> <p>Get node information sorted by attribute name, returns list of tuples</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree.node.node import Node\n&gt;&gt;&gt; a = Node('a', age=90)\n&gt;&gt;&gt; a.describe()\n[('_BaseNode__children', []), ('_BaseNode__parent', None), ('_sep', '/'), ('age', 90), ('name', 'a')]\n&gt;&gt;&gt; a.describe(exclude_prefix=\"_\")\n[('age', 90), ('name', 'a')]\n&gt;&gt;&gt; a.describe(exclude_prefix=\"_\", exclude_attributes=[\"name\"])\n[('age', 90)]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>exclude_attributes</code> <code>List[str]</code> <p>list of attributes to exclude</p> <code>[]</code> <code>exclude_prefix</code> <code>str</code> <p>prefix of attributes to exclude</p> <code>''</code> <p>Returns:</p> Type Description <code>List[Tuple[str, Any]]</code> <p>(List[Tuple[str, Any]])</p>"},{"location":"bigtree/node/node/#bigtree.node.node.Node.get_attr","title":"get_attr","text":"<pre><code>get_attr(attr_name, default_value=None)\n</code></pre> <p>Get value of node attribute Returns default value if attribute name does not exist</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree.node.node import Node\n&gt;&gt;&gt; a = Node('a', age=90)\n&gt;&gt;&gt; a.get_attr(\"age\")\n90\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>attr_name</code> <code>str</code> <p>attribute name</p> required <code>default_value</code> <code>Any</code> <p>default value if attribute does not exist, defaults to None</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>(Any)</p>"},{"location":"bigtree/node/node/#bigtree.node.node.Node.set_attrs","title":"set_attrs","text":"<pre><code>set_attrs(attrs)\n</code></pre> <p>Set node attributes</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree.node.node import Node\n&gt;&gt;&gt; a = Node('a')\n&gt;&gt;&gt; a.set_attrs({\"age\": 90})\n&gt;&gt;&gt; a\nNode(/a, age=90)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>attrs</code> <code>Dict[str, Any]</code> <p>attribute dictionary, key: attribute name, value: attribute value</p> required"},{"location":"bigtree/node/node/#bigtree.node.node.Node.go_to","title":"go_to","text":"<pre><code>go_to(node)\n</code></pre> <p>Get path from current node to specified node from same tree</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, print_tree\n&gt;&gt;&gt; a = Node(name=\"a\")\n&gt;&gt;&gt; b = Node(name=\"b\", parent=a)\n&gt;&gt;&gt; c = Node(name=\"c\", parent=a)\n&gt;&gt;&gt; d = Node(name=\"d\", parent=b)\n&gt;&gt;&gt; e = Node(name=\"e\", parent=b)\n&gt;&gt;&gt; f = Node(name=\"f\", parent=c)\n&gt;&gt;&gt; g = Node(name=\"g\", parent=e)\n&gt;&gt;&gt; h = Node(name=\"h\", parent=e)\n&gt;&gt;&gt; print_tree(a)\na\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 d\n\u2502   \u2514\u2500\u2500 e\n\u2502       \u251c\u2500\u2500 g\n\u2502       \u2514\u2500\u2500 h\n\u2514\u2500\u2500 c\n    \u2514\u2500\u2500 f\n&gt;&gt;&gt; d.go_to(d)\n[Node(/a/b/d, )]\n&gt;&gt;&gt; d.go_to(g)\n[Node(/a/b/d, ), Node(/a/b, ), Node(/a/b/e, ), Node(/a/b/e/g, )]\n&gt;&gt;&gt; d.go_to(f)\n[Node(/a/b/d, ), Node(/a/b, ), Node(/a, ), Node(/a/c, ), Node(/a/c/f, )]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Self</code> <p>node to travel to from current node, inclusive of start and end node</p> required <p>Returns:</p> Type Description <code>Iterable[T]</code> <p>(Iterable[Self])</p>"},{"location":"bigtree/node/node/#bigtree.node.node.Node.append","title":"append","text":"<pre><code>append(other)\n</code></pre> <p>Add other as child of self</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>other node, child to be added</p> required"},{"location":"bigtree/node/node/#bigtree.node.node.Node.extend","title":"extend","text":"<pre><code>extend(others)\n</code></pre> <p>Add others as children of self</p> <p>Parameters:</p> Name Type Description Default <code>others</code> <code>Self</code> <p>other nodes, children to be added</p> required"},{"location":"bigtree/node/node/#bigtree.node.node.Node.copy","title":"copy","text":"<pre><code>copy()\n</code></pre> <p>Deep copy self; clone self</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree.node.node import Node\n&gt;&gt;&gt; a = Node('a')\n&gt;&gt;&gt; a_copy = a.copy()\n</code></pre> <p>Returns:</p> Type Description <code>T</code> <p>(Self)</p>"},{"location":"bigtree/node/node/#bigtree.node.node.Node.sort","title":"sort","text":"<pre><code>sort(**kwargs)\n</code></pre> <p>Sort children, possible keyword arguments include <code>key=lambda node: node.name</code>, <code>reverse=True</code></p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, print_tree\n&gt;&gt;&gt; a = Node('a')\n&gt;&gt;&gt; c = Node(\"c\", parent=a)\n&gt;&gt;&gt; b = Node(\"b\", parent=a)\n&gt;&gt;&gt; print_tree(a)\na\n\u251c\u2500\u2500 c\n\u2514\u2500\u2500 b\n&gt;&gt;&gt; a.sort(key=lambda node: node.name)\n&gt;&gt;&gt; print_tree(a)\na\n\u251c\u2500\u2500 b\n\u2514\u2500\u2500 c\n</code></pre>"},{"location":"bigtree/node/node/#bigtree.node.node.Node.show","title":"show","text":"<pre><code>show(**kwargs)\n</code></pre> <p>Print tree to console, takes in same keyword arguments as <code>print_tree</code> function</p>"},{"location":"bigtree/node/node/#bigtree.node.node.Node.hshow","title":"hshow","text":"<pre><code>hshow(**kwargs)\n</code></pre> <p>Print tree in horizontal orientation to console, takes in same keyword arguments as <code>hprint_tree</code> function</p>"},{"location":"bigtree/tree/","title":"\ud83c\udf32 Tree","text":""},{"location":"bigtree/tree/construct/","title":"\u2728 Construct","text":""},{"location":"bigtree/tree/construct/#tree-construct-methods","title":"Tree Construct Methods","text":"<p>Construct Tree from list, dictionary, and pandas DataFrame.</p> <p>To decide which method to use, consider your data type and data values.</p> Construct tree from Using full path Using parent-child relation Using notation Add node attributes String <code>str_to_tree</code> NA <code>newick_to_tree</code> No (for <code>str_to_tree</code>)Yes (for  <code>newick_to_tree</code>) List <code>list_to_tree</code> <code>list_to_tree_by_relation</code> NA No Dictionary <code>dict_to_tree</code> <code>nested_dict_to_tree</code> NA Yes DataFrame <code>dataframe_to_tree</code> <code>dataframe_to_tree_by_relation</code> NA Yes"},{"location":"bigtree/tree/construct/#tree-add-attributes-methods","title":"Tree Add Attributes Methods","text":"<p>To add attributes to an existing tree,</p> Add attributes from Using full path Using node name String <code>add_path_to_tree</code> NA Dictionary <code>add_dict_to_tree_by_path</code> <code>add_dict_to_tree_by_name</code> DataFrame <code>add_dataframe_to_tree_by_path</code> <code>add_dataframe_to_tree_by_name</code> <p>Note</p> <p>If attributes are added to existing tree using full path, paths that previously did not exist will be added. If attributes are added to existing tree using node name, names that previously did not exist will not be created.</p> <p>These functions are not standalone functions. Under the hood, they have the following dependency,</p> <p></p>"},{"location":"bigtree/tree/construct/#bigtree.tree.construct","title":"bigtree.tree.construct","text":""},{"location":"bigtree/tree/construct/#bigtree.tree.construct.add_path_to_tree","title":"add_path_to_tree","text":"<pre><code>add_path_to_tree(\n    tree,\n    path,\n    sep=\"/\",\n    duplicate_name_allowed=True,\n    node_attrs={},\n)\n</code></pre> <p>Add nodes and attributes to existing tree in-place, return node of path added. Adds to existing tree from list of path strings.</p> <p>Path should contain <code>Node</code> name, separated by <code>sep</code>.</p> <ul> <li>For example: Path string \"a/b\" refers to Node(\"b\") with parent Node(\"a\").</li> <li>Path separator <code>sep</code> is for the input <code>path</code> and can differ from existing tree.</li> </ul> <p>Path can start from root node <code>name</code>, or start with <code>sep</code>.</p> <ul> <li>For example: Path string can be \"/a/b\" or \"a/b\", if sep is \"/\".</li> </ul> <p>All paths should start from the same root node.</p> <ul> <li>For example: Path strings should be \"a/b\", \"a/c\", \"a/b/d\" etc., and should not start with another root node.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import add_path_to_tree, Node\n&gt;&gt;&gt; root = Node(\"a\")\n&gt;&gt;&gt; add_path_to_tree(root, \"a/b/c\")\nNode(/a/b/c, )\n&gt;&gt;&gt; root.show()\na\n\u2514\u2500\u2500 b\n    \u2514\u2500\u2500 c\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>Node</code> <p>existing tree</p> required <code>path</code> <code>str</code> <p>path to be added to tree</p> required <code>sep</code> <code>str</code> <p>path separator for input <code>path</code></p> <code>'/'</code> <code>duplicate_name_allowed</code> <code>bool</code> <p>indicator if nodes with duplicate <code>Node</code> name is allowed, defaults to True</p> <code>True</code> <code>node_attrs</code> <code>Dict[str, Any]</code> <p>attributes to add to node, key: attribute name, value: attribute value, optional</p> <code>{}</code> <p>Returns:</p> Type Description <code>Node</code> <p>(Node)</p>"},{"location":"bigtree/tree/construct/#bigtree.tree.construct.add_dict_to_tree_by_path","title":"add_dict_to_tree_by_path","text":"<pre><code>add_dict_to_tree_by_path(\n    tree, path_attrs, sep=\"/\", duplicate_name_allowed=True\n)\n</code></pre> <p>Add nodes and attributes to tree in-place, return root of tree. Adds to existing tree from nested dictionary, <code>key</code>: path, <code>value</code>: dict of attribute name and attribute value.</p> <p>Path should contain <code>Node</code> name, separated by <code>sep</code>.</p> <ul> <li>For example: Path string \"a/b\" refers to Node(\"b\") with parent Node(\"a\").</li> <li>Path separator <code>sep</code> is for the input <code>path</code> and can differ from existing tree.</li> </ul> <p>Path can start from root node <code>name</code>, or start with <code>sep</code>.</p> <ul> <li>For example: Path string can be \"/a/b\" or \"a/b\", if sep is \"/\".</li> </ul> <p>All paths should start from the same root node.</p> <ul> <li>For example: Path strings should be \"a/b\", \"a/c\", \"a/b/d\" etc. and should not start with another root node.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, add_dict_to_tree_by_path\n&gt;&gt;&gt; root = Node(\"a\")\n&gt;&gt;&gt; path_dict = {\n...     \"a\": {\"age\": 90},\n...     \"a/b\": {\"age\": 65},\n...     \"a/c\": {\"age\": 60},\n...     \"a/b/d\": {\"age\": 40},\n...     \"a/b/e\": {\"age\": 35},\n...     \"a/c/f\": {\"age\": 38},\n...     \"a/b/e/g\": {\"age\": 10},\n...     \"a/b/e/h\": {\"age\": 6},\n... }\n&gt;&gt;&gt; root = add_dict_to_tree_by_path(root, path_dict)\n&gt;&gt;&gt; root.show()\na\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 d\n\u2502   \u2514\u2500\u2500 e\n\u2502       \u251c\u2500\u2500 g\n\u2502       \u2514\u2500\u2500 h\n\u2514\u2500\u2500 c\n    \u2514\u2500\u2500 f\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>Node</code> <p>existing tree</p> required <code>path_attrs</code> <code>Dict[str, Dict[str, Any]]</code> <p>dictionary containing node path and attribute information, key: node path, value: dict of node attribute name and attribute value</p> required <code>sep</code> <code>str</code> <p>path separator for input <code>path_attrs</code></p> <code>'/'</code> <code>duplicate_name_allowed</code> <code>bool</code> <p>indicator if nodes with duplicate <code>Node</code> name is allowed, defaults to True</p> <code>True</code> <p>Returns:</p> Type Description <code>Node</code> <p>(Node)</p>"},{"location":"bigtree/tree/construct/#bigtree.tree.construct.add_dict_to_tree_by_name","title":"add_dict_to_tree_by_name","text":"<pre><code>add_dict_to_tree_by_name(\n    tree, name_attrs, join_type=\"left\"\n)\n</code></pre> <p>Add attributes to tree, return new root of tree. Adds to existing tree from nested dictionary, <code>key</code>: name, <code>value</code>: dict of attribute name and attribute value.</p> <p>Function can return all existing tree nodes or only tree nodes that are in the input dictionary keys depending on join type. Input dictionary keys that are not existing node names will be ignored. Note that if multiple nodes have the same name, attributes will be added to all nodes sharing the same name.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, add_dict_to_tree_by_name\n&gt;&gt;&gt; root = Node(\"a\")\n&gt;&gt;&gt; b = Node(\"b\", parent=root)\n&gt;&gt;&gt; name_dict = {\n...     \"a\": {\"age\": 90},\n...     \"b\": {\"age\": 65},\n... }\n&gt;&gt;&gt; root = add_dict_to_tree_by_name(root, name_dict)\n&gt;&gt;&gt; root.show(attr_list=[\"age\"])\na [age=90]\n\u2514\u2500\u2500 b [age=65]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>Node</code> <p>existing tree</p> required <code>name_attrs</code> <code>Dict[str, Dict[str, Any]]</code> <p>dictionary containing node name and attribute information, key: node name, value: dict of node attribute name and attribute value</p> required <code>join_type</code> <code>str</code> <p>join type with attribute, default of 'left' takes existing tree nodes, if join_type is set to 'inner' it will only take tree nodes that are in <code>name_attrs</code> key and drop others</p> <code>'left'</code> <p>Returns:</p> Type Description <code>Node</code> <p>(Node)</p>"},{"location":"bigtree/tree/construct/#bigtree.tree.construct.add_dataframe_to_tree_by_path","title":"add_dataframe_to_tree_by_path","text":"<pre><code>add_dataframe_to_tree_by_path(\n    tree,\n    data,\n    path_col=\"\",\n    attribute_cols=[],\n    sep=\"/\",\n    duplicate_name_allowed=True,\n)\n</code></pre> <p>Add nodes and attributes to tree in-place, return root of tree.</p> <p><code>path_col</code> and <code>attribute_cols</code> specify columns for node path and attributes to add to existing tree. If columns are not specified, <code>path_col</code> takes first column and all other columns are <code>attribute_cols</code></p> <p>Path in path column should contain <code>Node</code> name, separated by <code>sep</code>.</p> <ul> <li>For example: Path string \"a/b\" refers to Node(\"b\") with parent Node(\"a\").</li> <li>Path separator <code>sep</code> is for the input <code>path</code> and can differ from existing tree.</li> </ul> <p>Path in path column can start from root node <code>name</code>, or start with <code>sep</code>.</p> <ul> <li>For example: Path string can be \"/a/b\" or \"a/b\", if sep is \"/\".</li> </ul> <p>All paths should start from the same root node.</p> <ul> <li>For example: Path strings should be \"a/b\", \"a/c\", \"a/b/d\" etc. and should not start with another root node.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from bigtree import add_dataframe_to_tree_by_path, Node\n&gt;&gt;&gt; root = Node(\"a\")\n&gt;&gt;&gt; path_data = pd.DataFrame([\n...     [\"a\", 90],\n...     [\"a/b\", 65],\n...     [\"a/c\", 60],\n...     [\"a/b/d\", 40],\n...     [\"a/b/e\", 35],\n...     [\"a/c/f\", 38],\n...     [\"a/b/e/g\", 10],\n...     [\"a/b/e/h\", 6],\n... ],\n...     columns=[\"PATH\", \"age\"]\n... )\n&gt;&gt;&gt; root = add_dataframe_to_tree_by_path(root, path_data)\n&gt;&gt;&gt; root.show(attr_list=[\"age\"])\na [age=90]\n\u251c\u2500\u2500 b [age=65]\n\u2502   \u251c\u2500\u2500 d [age=40]\n\u2502   \u2514\u2500\u2500 e [age=35]\n\u2502       \u251c\u2500\u2500 g [age=10]\n\u2502       \u2514\u2500\u2500 h [age=6]\n\u2514\u2500\u2500 c [age=60]\n    \u2514\u2500\u2500 f [age=38]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>Node</code> <p>existing tree</p> required <code>data</code> <code>DataFrame</code> <p>data containing node path and attribute information</p> required <code>path_col</code> <code>str</code> <p>column of data containing <code>path_name</code> information, if not set, it will take the first column of data</p> <code>''</code> <code>attribute_cols</code> <code>List[str]</code> <p>columns of data containing node attribute information, if not set, it will take all columns of data except <code>path_col</code></p> <code>[]</code> <code>sep</code> <code>str</code> <p>path separator for input <code>path_col</code></p> <code>'/'</code> <code>duplicate_name_allowed</code> <code>bool</code> <p>indicator if nodes with duplicate <code>Node</code> name is allowed, defaults to True</p> <code>True</code> <p>Returns:</p> Type Description <code>Node</code> <p>(Node)</p>"},{"location":"bigtree/tree/construct/#bigtree.tree.construct.add_dataframe_to_tree_by_name","title":"add_dataframe_to_tree_by_name","text":"<pre><code>add_dataframe_to_tree_by_name(\n    tree,\n    data,\n    name_col=\"\",\n    attribute_cols=[],\n    join_type=\"left\",\n)\n</code></pre> <p>Add attributes to tree, return new root of tree.</p> <p><code>name_col</code> and <code>attribute_cols</code> specify columns for node name and attributes to add to existing tree. If columns are not specified, the first column will be taken as name column and all other columns as attributes.</p> <p>Function can return all existing tree nodes or only tree nodes that are in the input data node names. Input data node names that are not existing node names will be ignored. Note that if multiple nodes have the same name, attributes will be added to all nodes sharing same name.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from bigtree import add_dataframe_to_tree_by_name, Node\n&gt;&gt;&gt; root = Node(\"a\")\n&gt;&gt;&gt; b = Node(\"b\", parent=root)\n&gt;&gt;&gt; name_data = pd.DataFrame([\n...     [\"a\", 90],\n...     [\"b\", 65],\n... ],\n...     columns=[\"NAME\", \"age\"]\n... )\n&gt;&gt;&gt; root = add_dataframe_to_tree_by_name(root, name_data)\n&gt;&gt;&gt; root.show(attr_list=[\"age\"])\na [age=90]\n\u2514\u2500\u2500 b [age=65]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>Node</code> <p>existing tree</p> required <code>data</code> <code>DataFrame</code> <p>data containing node name and attribute information</p> required <code>name_col</code> <code>str</code> <p>column of data containing <code>name</code> information, if not set, it will take the first column of data</p> <code>''</code> <code>attribute_cols</code> <code>List[str]</code> <p>column(s) of data containing node attribute information, if not set, it will take all columns of data except <code>path_col</code></p> <code>[]</code> <code>join_type</code> <code>str</code> <p>join type with attribute, default of 'left' takes existing tree nodes, if join_type is set to 'inner' it will only take tree nodes with attributes and drop the other nodes</p> <code>'left'</code> <p>Returns:</p> Type Description <code>Node</code> <p>(Node)</p>"},{"location":"bigtree/tree/construct/#bigtree.tree.construct.str_to_tree","title":"str_to_tree","text":"<pre><code>str_to_tree(\n    tree_string, tree_prefix_list=[], node_type=Node\n)\n</code></pre> <p>Construct tree from tree string</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import str_to_tree\n&gt;&gt;&gt; tree_str = 'a\\n\u251c\u2500\u2500 b\\n\u2502   \u251c\u2500\u2500 d\\n\u2502   \u2514\u2500\u2500 e\\n\u2502       \u251c\u2500\u2500 g\\n\u2502       \u2514\u2500\u2500 h\\n\u2514\u2500\u2500 c\\n    \u2514\u2500\u2500 f'\n&gt;&gt;&gt; root = str_to_tree(tree_str, tree_prefix_list=[\"\u251c\u2500\u2500\", \"\u2514\u2500\u2500\"])\n&gt;&gt;&gt; root.show()\na\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 d\n\u2502   \u2514\u2500\u2500 e\n\u2502       \u251c\u2500\u2500 g\n\u2502       \u2514\u2500\u2500 h\n\u2514\u2500\u2500 c\n    \u2514\u2500\u2500 f\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree_string</code> <code>str</code> <p>String to construct tree</p> required <code>tree_prefix_list</code> <code>List[str]</code> <p>List of prefix to mark the end of tree branch/stem and start of node name, optional. If not specified, it will infer unicode characters and whitespace as prefix.</p> <code>[]</code> <code>node_type</code> <code>Type[Node]</code> <p>node type of tree to be created, defaults to <code>Node</code></p> <code>Node</code> <p>Returns:</p> Type Description <code>Node</code> <p>(Node)</p>"},{"location":"bigtree/tree/construct/#bigtree.tree.construct.list_to_tree","title":"list_to_tree","text":"<pre><code>list_to_tree(\n    paths,\n    sep=\"/\",\n    duplicate_name_allowed=True,\n    node_type=Node,\n)\n</code></pre> <p>Construct tree from list of path strings.</p> <p>Path should contain <code>Node</code> name, separated by <code>sep</code>.</p> <ul> <li>For example: Path string \"a/b\" refers to Node(\"b\") with parent Node(\"a\").</li> </ul> <p>Path can start from root node <code>name</code>, or start with <code>sep</code>.</p> <ul> <li>For example: Path string can be \"/a/b\" or \"a/b\", if sep is \"/\".</li> </ul> <p>All paths should start from the same root node.</p> <ul> <li>For example: Path strings should be \"a/b\", \"a/c\", \"a/b/d\" etc. and should not start with another root node.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import list_to_tree\n&gt;&gt;&gt; path_list = [\"a/b\", \"a/c\", \"a/b/d\", \"a/b/e\", \"a/c/f\", \"a/b/e/g\", \"a/b/e/h\"]\n&gt;&gt;&gt; root = list_to_tree(path_list)\n&gt;&gt;&gt; root.show()\na\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 d\n\u2502   \u2514\u2500\u2500 e\n\u2502       \u251c\u2500\u2500 g\n\u2502       \u2514\u2500\u2500 h\n\u2514\u2500\u2500 c\n    \u2514\u2500\u2500 f\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>paths</code> <code>Iterable[str]</code> <p>list containing path strings</p> required <code>sep</code> <code>str</code> <p>path separator for input <code>paths</code> and created tree, defaults to <code>/</code></p> <code>'/'</code> <code>duplicate_name_allowed</code> <code>bool</code> <p>indicator if nodes with duplicate <code>Node</code> name is allowed, defaults to True</p> <code>True</code> <code>node_type</code> <code>Type[Node]</code> <p>node type of tree to be created, defaults to <code>Node</code></p> <code>Node</code> <p>Returns:</p> Type Description <code>Node</code> <p>(Node)</p>"},{"location":"bigtree/tree/construct/#bigtree.tree.construct.list_to_tree_by_relation","title":"list_to_tree_by_relation","text":"<pre><code>list_to_tree_by_relation(\n    relations, allow_duplicates=False, node_type=Node\n)\n</code></pre> <p>Construct tree from list of tuple containing parent-child names.</p> <p>Since tree is created from parent-child names, only names of leaf nodes may be repeated. Error will be thrown if names of intermediate nodes are repeated as there will be confusion. This error can be ignored by setting <code>allow_duplicates</code> to be True.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import list_to_tree_by_relation\n&gt;&gt;&gt; relations_list = [(\"a\", \"b\"), (\"a\", \"c\"), (\"b\", \"d\"), (\"b\", \"e\"), (\"c\", \"f\"), (\"e\", \"g\"), (\"e\", \"h\")]\n&gt;&gt;&gt; root = list_to_tree_by_relation(relations_list)\n&gt;&gt;&gt; root.show()\na\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 d\n\u2502   \u2514\u2500\u2500 e\n\u2502       \u251c\u2500\u2500 g\n\u2502       \u2514\u2500\u2500 h\n\u2514\u2500\u2500 c\n    \u2514\u2500\u2500 f\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>relations</code> <code>Iterable[Tuple[str, str]]</code> <p>list containing tuple containing parent-child names</p> required <code>allow_duplicates</code> <code>bool</code> <p>allow duplicate intermediate nodes such that child node will be tagged to multiple parent nodes, defaults to False</p> <code>False</code> <code>node_type</code> <code>Type[Node]</code> <p>node type of tree to be created, defaults to <code>Node</code></p> <code>Node</code> <p>Returns:</p> Type Description <code>Node</code> <p>(Node)</p>"},{"location":"bigtree/tree/construct/#bigtree.tree.construct.dict_to_tree","title":"dict_to_tree","text":"<pre><code>dict_to_tree(\n    path_attrs,\n    sep=\"/\",\n    duplicate_name_allowed=True,\n    node_type=Node,\n)\n</code></pre> <p>Construct tree from nested dictionary using path, <code>key</code>: path, <code>value</code>: dict of attribute name and attribute value.</p> <p>Path should contain <code>Node</code> name, separated by <code>sep</code>.</p> <ul> <li>For example: Path string \"a/b\" refers to Node(\"b\") with parent Node(\"a\").</li> </ul> <p>Path can start from root node <code>name</code>, or start with <code>sep</code>.</p> <ul> <li>For example: Path string can be \"/a/b\" or \"a/b\", if sep is \"/\".</li> </ul> <p>All paths should start from the same root node.</p> <ul> <li>For example: Path strings should be \"a/b\", \"a/c\", \"a/b/d\" etc. and should not start with another root node.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import dict_to_tree\n&gt;&gt;&gt; path_dict = {\n...     \"a\": {\"age\": 90},\n...     \"a/b\": {\"age\": 65},\n...     \"a/c\": {\"age\": 60},\n...     \"a/b/d\": {\"age\": 40},\n...     \"a/b/e\": {\"age\": 35},\n...     \"a/c/f\": {\"age\": 38},\n...     \"a/b/e/g\": {\"age\": 10},\n...     \"a/b/e/h\": {\"age\": 6},\n... }\n&gt;&gt;&gt; root = dict_to_tree(path_dict)\n&gt;&gt;&gt; root.show(attr_list=[\"age\"])\na [age=90]\n\u251c\u2500\u2500 b [age=65]\n\u2502   \u251c\u2500\u2500 d [age=40]\n\u2502   \u2514\u2500\u2500 e [age=35]\n\u2502       \u251c\u2500\u2500 g [age=10]\n\u2502       \u2514\u2500\u2500 h [age=6]\n\u2514\u2500\u2500 c [age=60]\n    \u2514\u2500\u2500 f [age=38]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>path_attrs</code> <code>Dict[str, Any]</code> <p>dictionary containing path and node attribute information, key: path, value: dict of tree attribute and attribute value</p> required <code>sep</code> <code>str</code> <p>path separator of input <code>path_attrs</code> and created tree, defaults to <code>/</code></p> <code>'/'</code> <code>duplicate_name_allowed</code> <code>bool</code> <p>indicator if nodes with duplicate <code>Node</code> name is allowed, defaults to True</p> <code>True</code> <code>node_type</code> <code>Type[Node]</code> <p>node type of tree to be created, defaults to <code>Node</code></p> <code>Node</code> <p>Returns:</p> Type Description <code>Node</code> <p>(Node)</p>"},{"location":"bigtree/tree/construct/#bigtree.tree.construct.nested_dict_to_tree","title":"nested_dict_to_tree","text":"<pre><code>nested_dict_to_tree(\n    node_attrs,\n    name_key=\"name\",\n    child_key=\"children\",\n    node_type=Node,\n)\n</code></pre> <p>Construct tree from nested recursive dictionary.</p> <ul> <li><code>key</code>: <code>name_key</code>, <code>child_key</code>, or any attributes key.</li> <li><code>value</code> of <code>name_key</code> (str): node name.</li> <li><code>value</code> of <code>child_key</code> (List[Dict[str, Any]]): list of dict containing <code>name_key</code> and <code>child_key</code> (recursive).</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import nested_dict_to_tree\n&gt;&gt;&gt; path_dict = {\n...     \"name\": \"a\",\n...     \"age\": 90,\n...     \"children\": [\n...         {\"name\": \"b\",\n...          \"age\": 65,\n...          \"children\": [\n...              {\"name\": \"d\", \"age\": 40},\n...              {\"name\": \"e\", \"age\": 35, \"children\": [\n...                  {\"name\": \"g\", \"age\": 10},\n...              ]},\n...          ]},\n...     ],\n... }\n&gt;&gt;&gt; root = nested_dict_to_tree(path_dict)\n&gt;&gt;&gt; root.show(attr_list=[\"age\"])\na [age=90]\n\u2514\u2500\u2500 b [age=65]\n    \u251c\u2500\u2500 d [age=40]\n    \u2514\u2500\u2500 e [age=35]\n        \u2514\u2500\u2500 g [age=10]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>node_attrs</code> <code>Dict[str, Any]</code> <p>dictionary containing node, children, and node attribute information, key: <code>name_key</code> and <code>child_key</code> value of <code>name_key</code> (str): node name value of <code>child_key</code> (List[Dict[str, Any]]): list of dict containing <code>name_key</code> and <code>child_key</code> (recursive)</p> required <code>name_key</code> <code>str</code> <p>key of node name, value is type str</p> <code>'name'</code> <code>child_key</code> <code>str</code> <p>key of child list, value is type list</p> <code>'children'</code> <code>node_type</code> <code>Type[Node]</code> <p>node type of tree to be created, defaults to <code>Node</code></p> <code>Node</code> <p>Returns:</p> Type Description <code>Node</code> <p>(Node)</p>"},{"location":"bigtree/tree/construct/#bigtree.tree.construct.dataframe_to_tree","title":"dataframe_to_tree","text":"<pre><code>dataframe_to_tree(\n    data,\n    path_col=\"\",\n    attribute_cols=[],\n    sep=\"/\",\n    duplicate_name_allowed=True,\n    node_type=Node,\n)\n</code></pre> <p>Construct tree from pandas DataFrame using path, return root of tree.</p> <p><code>path_col</code> and <code>attribute_cols</code> specify columns for node path and attributes to construct tree. If columns are not specified, <code>path_col</code> takes first column and all other columns are <code>attribute_cols</code>.</p> <p>Path in path column can start from root node <code>name</code>, or start with <code>sep</code>.</p> <ul> <li>For example: Path string can be \"/a/b\" or \"a/b\", if sep is \"/\".</li> </ul> <p>Path in path column should contain <code>Node</code> name, separated by <code>sep</code>.</p> <ul> <li>For example: Path string \"a/b\" refers to Node(\"b\") with parent Node(\"a\").</li> </ul> <p>All paths should start from the same root node.</p> <ul> <li>For example: Path strings should be \"a/b\", \"a/c\", \"a/b/d\" etc. and should not start with another root node.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from bigtree import dataframe_to_tree\n&gt;&gt;&gt; path_data = pd.DataFrame([\n...     [\"a\", 90],\n...     [\"a/b\", 65],\n...     [\"a/c\", 60],\n...     [\"a/b/d\", 40],\n...     [\"a/b/e\", 35],\n...     [\"a/c/f\", 38],\n...     [\"a/b/e/g\", 10],\n...     [\"a/b/e/h\", 6],\n... ],\n...     columns=[\"PATH\", \"age\"]\n... )\n&gt;&gt;&gt; root = dataframe_to_tree(path_data)\n&gt;&gt;&gt; root.show(attr_list=[\"age\"])\na [age=90]\n\u251c\u2500\u2500 b [age=65]\n\u2502   \u251c\u2500\u2500 d [age=40]\n\u2502   \u2514\u2500\u2500 e [age=35]\n\u2502       \u251c\u2500\u2500 g [age=10]\n\u2502       \u2514\u2500\u2500 h [age=6]\n\u2514\u2500\u2500 c [age=60]\n    \u2514\u2500\u2500 f [age=38]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>data containing path and node attribute information</p> required <code>path_col</code> <code>str</code> <p>column of data containing <code>path_name</code> information, if not set, it will take the first column of data</p> <code>''</code> <code>attribute_cols</code> <code>List[str]</code> <p>columns of data containing node attribute information, if not set, it will take all columns of data except <code>path_col</code></p> <code>[]</code> <code>sep</code> <code>str</code> <p>path separator of input <code>path_col</code> and created tree, defaults to <code>/</code></p> <code>'/'</code> <code>duplicate_name_allowed</code> <code>bool</code> <p>indicator if nodes with duplicate <code>Node</code> name is allowed, defaults to True</p> <code>True</code> <code>node_type</code> <code>Type[Node]</code> <p>node type of tree to be created, defaults to <code>Node</code></p> <code>Node</code> <p>Returns:</p> Type Description <code>Node</code> <p>(Node)</p>"},{"location":"bigtree/tree/construct/#bigtree.tree.construct.dataframe_to_tree_by_relation","title":"dataframe_to_tree_by_relation","text":"<pre><code>dataframe_to_tree_by_relation(\n    data,\n    child_col=\"\",\n    parent_col=\"\",\n    attribute_cols=[],\n    allow_duplicates=False,\n    node_type=Node,\n)\n</code></pre> <p>Construct tree from pandas DataFrame using parent and child names, return root of tree.</p> <p>Since tree is created from parent-child names, only names of leaf nodes may be repeated. Error will be thrown if names of intermediate nodes are repeated as there will be confusion. This error can be ignored by setting <code>allow_duplicates</code> to be True.</p> <p><code>child_col</code> and <code>parent_col</code> specify columns for child name and parent name to construct tree. <code>attribute_cols</code> specify columns for node attribute for child name. If columns are not specified, <code>child_col</code> takes first column, <code>parent_col</code> takes second column, and all other columns are <code>attribute_cols</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from bigtree import dataframe_to_tree_by_relation\n&gt;&gt;&gt; relation_data = pd.DataFrame([\n...     [\"a\", None, 90],\n...     [\"b\", \"a\", 65],\n...     [\"c\", \"a\", 60],\n...     [\"d\", \"b\", 40],\n...     [\"e\", \"b\", 35],\n...     [\"f\", \"c\", 38],\n...     [\"g\", \"e\", 10],\n...     [\"h\", \"e\", 6],\n... ],\n...     columns=[\"child\", \"parent\", \"age\"]\n... )\n&gt;&gt;&gt; root = dataframe_to_tree_by_relation(relation_data)\n&gt;&gt;&gt; root.show(attr_list=[\"age\"])\na [age=90]\n\u251c\u2500\u2500 b [age=65]\n\u2502   \u251c\u2500\u2500 d [age=40]\n\u2502   \u2514\u2500\u2500 e [age=35]\n\u2502       \u251c\u2500\u2500 g [age=10]\n\u2502       \u2514\u2500\u2500 h [age=6]\n\u2514\u2500\u2500 c [age=60]\n    \u2514\u2500\u2500 f [age=38]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>data containing path and node attribute information</p> required <code>child_col</code> <code>str</code> <p>column of data containing child name information, defaults to None if not set, it will take the first column of data</p> <code>''</code> <code>parent_col</code> <code>str</code> <p>column of data containing parent name information, defaults to None if not set, it will take the second column of data</p> <code>''</code> <code>attribute_cols</code> <code>List[str]</code> <p>columns of data containing node attribute information, if not set, it will take all columns of data except <code>child_col</code> and <code>parent_col</code></p> <code>[]</code> <code>allow_duplicates</code> <code>bool</code> <p>allow duplicate intermediate nodes such that child node will be tagged to multiple parent nodes, defaults to False</p> <code>False</code> <code>node_type</code> <code>Type[Node]</code> <p>node type of tree to be created, defaults to <code>Node</code></p> <code>Node</code> <p>Returns:</p> Type Description <code>Node</code> <p>(Node)</p>"},{"location":"bigtree/tree/construct/#bigtree.tree.construct.newick_to_tree","title":"newick_to_tree","text":"<pre><code>newick_to_tree(\n    tree_string,\n    length_attr=\"length\",\n    attr_prefix=\"&amp;&amp;NHX:\",\n    node_type=Node,\n)\n</code></pre> <p>Construct tree from Newick notation, return root of tree.</p> <p>In the Newick Notation (or New Hampshire Notation)</p> <ul> <li>Tree is represented in round brackets i.e., <code>(child1,child2,child3)parent</code>.</li> <li>If there are nested tree, they will be in nested round brackets i.e., <code>((grandchild1)child1,(grandchild2,grandchild3)child2)parent</code>.</li> <li>If there is length attribute, they will be beside the name i.e., <code>(child1:0.5,child2:0.1)parent</code>.</li> <li>If there are other attributes, attributes are represented in square brackets i.e., <code>(child1:0.5[S:human],child2:0.1[S:human])parent[S:parent]</code>.</li> </ul> <p>Variations supported</p> <ul> <li>Support special characters (<code>[</code>, <code>]</code>, <code>(</code>, <code>)</code>, <code>:</code>, <code>,</code>) in node name, attribute name, and attribute values if     they are enclosed in single quotes i.e., '(name:!)'.</li> <li>If there are no node names, it will be auto-filled with convention <code>nodeN</code> with N representing a number.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import newick_to_tree\n&gt;&gt;&gt; root = newick_to_tree(\"((d,e)b,c)a\")\n&gt;&gt;&gt; root.show()\na\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 d\n\u2502   \u2514\u2500\u2500 e\n\u2514\u2500\u2500 c\n</code></pre> <pre><code>&gt;&gt;&gt; root = newick_to_tree(\"((d:40,e:35)b:65,c:60)a\", length_attr=\"age\")\n&gt;&gt;&gt; root.show(attr_list=[\"age\"])\na\n\u251c\u2500\u2500 b [age=65]\n\u2502   \u251c\u2500\u2500 d [age=40]\n\u2502   \u2514\u2500\u2500 e [age=35]\n\u2514\u2500\u2500 c [age=60]\n</code></pre> <pre><code>&gt;&gt;&gt; root = newick_to_tree(\n...     \"((d:40[&amp;&amp;NHX:species=human],e:35[&amp;&amp;NHX:species=human])b:65[&amp;&amp;NHX:species=human],c:60[&amp;&amp;NHX:species=human])a[&amp;&amp;NHX:species=human]\",\n...     length_attr=\"age\",\n... )\n&gt;&gt;&gt; root.show(all_attrs=True)\na [species=human]\n\u251c\u2500\u2500 b [age=65, species=human]\n\u2502   \u251c\u2500\u2500 d [age=40, species=human]\n\u2502   \u2514\u2500\u2500 e [age=35, species=human]\n\u2514\u2500\u2500 c [age=60, species=human]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree_string</code> <code>str</code> <p>Newick notation to construct tree</p> required <code>length_attr</code> <code>str</code> <p>attribute name to store node length, optional, defaults to 'length'</p> <code>'length'</code> <code>attr_prefix</code> <code>str</code> <p>prefix before all attributes, within square bracket, used to detect attributes, defaults to \"&amp;&amp;NHX:\"</p> <code>'&amp;&amp;NHX:'</code> <code>node_type</code> <code>Type[Node]</code> <p>node type of tree to be created, defaults to <code>Node</code></p> <code>Node</code> <p>Returns:</p> Type Description <code>Node</code> <p>(Node)</p>"},{"location":"bigtree/tree/export/","title":"\ud83d\udd28 Export","text":""},{"location":"bigtree/tree/export/#tree-export-methods","title":"Tree Export Methods","text":"<p>Export Tree to list, dictionary, and pandas DataFrame.</p> Export Tree to Method Command Line / Others <code>print_tree</code>, <code>yield_tree</code>, <code>hprint_tree</code>, <code>hyield_tree</code> String <code>tree_to_newick</code> Dictionary <code>tree_to_dict</code>, <code>tree_to_nested_dict</code> DataFrame <code>tree_to_dataframe</code> Dot (for .dot, .png, .svg, .jpeg, etc.) <code>tree_to_dot</code> Pillow (for .png, .jpg, .jpeg, etc.) <code>tree_to_mermaid</code> Mermaid Markdown (for .md) <code>tree_to_mermaid</code>"},{"location":"bigtree/tree/export/#tree-export-customizations","title":"Tree Export Customizations","text":"<p>While exporting to another data type, methods can take in arguments to determine what information to extract.</p> Method Extract node attributes Specify maximum depth Skip depth Extract leaves only Others <code>print_tree</code> Yes with <code>attr_list</code> or <code>all_attrs</code> Yes with <code>max_depth</code> No, but can specify subtree No Tree style <code>yield_tree</code> No, returns node Yes with <code>max_depth</code> No, but can specify subtree No Tree style <code>tree_to_newick</code> Yes with <code>attr_list</code> No No No Length separator and attribute prefix and separator <code>tree_to_dict</code> Yes with <code>attr_dict</code> or <code>all_attrs</code> Yes with <code>max_depth</code> Yes with <code>skip_depth</code> Yes with <code>leaf_only</code> Dict key for parent <code>tree_to_nested_dict</code> Yes with <code>attr_dict</code> or <code>all_attrs</code> Yes with <code>max_depth</code> No No Dict key for node name and node children <code>tree_to_dataframe</code> Yes with <code>attr_dict</code> or <code>all_attrs</code> Yes with <code>max_depth</code> Yes with <code>skip_depth</code> Yes with <code>leaf_only</code> Column name for path, node name, node parent <code>tree_to_dot</code> No No No No Graph attributes, background, node, edge colour, etc. <code>tree_to_pillow</code> No Yes, using keyword arguments similar to <code>yield_tree</code> No No Font (family, size, colour), background colour, etc. <code>tree_to_mermaid</code> No Yes, using keyword arguments similar to <code>yield_tree</code> No No Node shape, node fill, edge arrow, edge label etc."},{"location":"bigtree/tree/export/#bigtree.tree.export","title":"bigtree.tree.export","text":""},{"location":"bigtree/tree/export/#bigtree.tree.export.print_tree","title":"print_tree","text":"<pre><code>print_tree(\n    tree,\n    node_name_or_path=\"\",\n    max_depth=0,\n    all_attrs=False,\n    attr_list=[],\n    attr_omit_null=False,\n    attr_bracket=[\"[\", \"]\"],\n    style=\"const\",\n    custom_style=[],\n)\n</code></pre> <p>Print tree to console, starting from <code>tree</code>.</p> <ul> <li>Able to select which node to print from, resulting in a subtree, using <code>node_name_or_path</code></li> <li>Able to customize for maximum depth to print, using <code>max_depth</code></li> <li>Able to choose which attributes to show or show all attributes, using <code>attr_name_filter</code> and <code>all_attrs</code></li> <li>Able to omit showing of attributes if it is null, using <code>attr_omit_null</code></li> <li>Able to customize open and close brackets if attributes are shown, using <code>attr_bracket</code></li> <li>Able to customize style, to choose from <code>ansi</code>, <code>ascii</code>, <code>const</code>, <code>const_bold</code>, <code>rounded</code>, <code>double</code>, and <code>custom</code> style     - Default style is <code>const</code> style     - If style is set to custom, user can choose their own style for stem, branch and final stem icons     - Stem, branch, and final stem symbol should have the same number of characters</li> </ul> <p>Examples:</p> <p>Printing tree</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, print_tree\n&gt;&gt;&gt; root = Node(\"a\", age=90)\n&gt;&gt;&gt; b = Node(\"b\", age=65, parent=root)\n&gt;&gt;&gt; c = Node(\"c\", age=60, parent=root)\n&gt;&gt;&gt; d = Node(\"d\", age=40, parent=b)\n&gt;&gt;&gt; e = Node(\"e\", age=35, parent=b)\n&gt;&gt;&gt; print_tree(root)\na\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 d\n\u2502   \u2514\u2500\u2500 e\n\u2514\u2500\u2500 c\n</code></pre> <p>Printing Sub-tree</p> <pre><code>&gt;&gt;&gt; print_tree(root, node_name_or_path=\"b\")\nb\n\u251c\u2500\u2500 d\n\u2514\u2500\u2500 e\n</code></pre> <pre><code>&gt;&gt;&gt; print_tree(root, max_depth=2)\na\n\u251c\u2500\u2500 b\n\u2514\u2500\u2500 c\n</code></pre> <p>Printing Attributes</p> <pre><code>&gt;&gt;&gt; print_tree(root, attr_list=[\"age\"])\na [age=90]\n\u251c\u2500\u2500 b [age=65]\n\u2502   \u251c\u2500\u2500 d [age=40]\n\u2502   \u2514\u2500\u2500 e [age=35]\n\u2514\u2500\u2500 c [age=60]\n</code></pre> <pre><code>&gt;&gt;&gt; print_tree(root, attr_list=[\"age\"], attr_bracket=[\"*(\", \")\"])\na *(age=90)\n\u251c\u2500\u2500 b *(age=65)\n\u2502   \u251c\u2500\u2500 d *(age=40)\n\u2502   \u2514\u2500\u2500 e *(age=35)\n\u2514\u2500\u2500 c *(age=60)\n</code></pre> <p>Available Styles</p> <pre><code>&gt;&gt;&gt; print_tree(root, style=\"ansi\")\na\n|-- b\n|   |-- d\n|   `-- e\n`-- c\n</code></pre> <pre><code>&gt;&gt;&gt; print_tree(root, style=\"ascii\")\na\n|-- b\n|   |-- d\n|   +-- e\n+-- c\n</code></pre> <pre><code>&gt;&gt;&gt; print_tree(root, style=\"const\")\na\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 d\n\u2502   \u2514\u2500\u2500 e\n\u2514\u2500\u2500 c\n</code></pre> <pre><code>&gt;&gt;&gt; print_tree(root, style=\"const_bold\")\na\n\u2523\u2501\u2501 b\n\u2503   \u2523\u2501\u2501 d\n\u2503   \u2517\u2501\u2501 e\n\u2517\u2501\u2501 c\n</code></pre> <pre><code>&gt;&gt;&gt; print_tree(root, style=\"rounded\")\na\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 d\n\u2502   \u2570\u2500\u2500 e\n\u2570\u2500\u2500 c\n</code></pre> <pre><code>&gt;&gt;&gt; print_tree(root, style=\"double\")\na\n\u2560\u2550\u2550 b\n\u2551   \u2560\u2550\u2550 d\n\u2551   \u255a\u2550\u2550 e\n\u255a\u2550\u2550 c\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>Node</code> <p>tree to print</p> required <code>node_name_or_path</code> <code>str</code> <p>node to print from, becomes the root node of printing</p> <code>''</code> <code>max_depth</code> <code>int</code> <p>maximum depth of tree to print, based on <code>depth</code> attribute, optional</p> <code>0</code> <code>all_attrs</code> <code>bool</code> <p>indicator to show all attributes, defaults to False, overrides <code>attr_list</code> and <code>attr_omit_null</code></p> <code>False</code> <code>attr_list</code> <code>Iterable[str]</code> <p>list of node attributes to print, optional</p> <code>[]</code> <code>attr_omit_null</code> <code>bool</code> <p>indicator whether to omit showing of null attributes, defaults to False</p> <code>False</code> <code>attr_bracket</code> <code>List[str]</code> <p>open and close bracket for <code>all_attrs</code> or <code>attr_list</code></p> <code>['[', ']']</code> <code>style</code> <code>str</code> <p>style of print, defaults to const style</p> <code>'const'</code> <code>custom_style</code> <code>Iterable[str]</code> <p>style of stem, branch and final stem, used when <code>style</code> is set to 'custom'</p> <code>[]</code>"},{"location":"bigtree/tree/export/#bigtree.tree.export.yield_tree","title":"yield_tree","text":"<pre><code>yield_tree(\n    tree,\n    node_name_or_path=\"\",\n    max_depth=0,\n    style=\"const\",\n    custom_style=[],\n)\n</code></pre> <p>Generator method for customizing printing of tree, starting from <code>tree</code>.</p> <ul> <li>Able to select which node to print from, resulting in a subtree, using <code>node_name_or_path</code></li> <li>Able to customize for maximum depth to print, using <code>max_depth</code></li> <li>Able to customize style, to choose from <code>ansi</code>, <code>ascii</code>, <code>const</code>, <code>const_bold</code>, <code>rounded</code>, <code>double</code>, and <code>custom</code> style     - Default style is <code>const</code> style     - If style is set to custom, user can choose their own style for stem, branch and final stem icons     - Stem, branch, and final stem symbol should have the same number of characters</li> </ul> <p>Examples:</p> <p>Yield tree</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, yield_tree\n&gt;&gt;&gt; root = Node(\"a\", age=90)\n&gt;&gt;&gt; b = Node(\"b\", age=65, parent=root)\n&gt;&gt;&gt; c = Node(\"c\", age=60, parent=root)\n&gt;&gt;&gt; d = Node(\"d\", age=40, parent=b)\n&gt;&gt;&gt; e = Node(\"e\", age=35, parent=b)\n&gt;&gt;&gt; for branch, stem, node in yield_tree(root):\n...     print(f\"{branch}{stem}{node.node_name}\")\na\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 d\n\u2502   \u2514\u2500\u2500 e\n\u2514\u2500\u2500 c\n</code></pre> <p>Yield Sub-tree</p> <pre><code>&gt;&gt;&gt; for branch, stem, node in yield_tree(root, node_name_or_path=\"b\"):\n...     print(f\"{branch}{stem}{node.node_name}\")\nb\n\u251c\u2500\u2500 d\n\u2514\u2500\u2500 e\n</code></pre> <pre><code>&gt;&gt;&gt; for branch, stem, node in yield_tree(root, max_depth=2):\n...     print(f\"{branch}{stem}{node.node_name}\")\na\n\u251c\u2500\u2500 b\n\u2514\u2500\u2500 c\n</code></pre> <p>Available Styles</p> <pre><code>&gt;&gt;&gt; for branch, stem, node in yield_tree(root, style=\"ansi\"):\n...     print(f\"{branch}{stem}{node.node_name}\")\na\n|-- b\n|   |-- d\n|   `-- e\n`-- c\n</code></pre> <pre><code>&gt;&gt;&gt; for branch, stem, node in yield_tree(root, style=\"ascii\"):\n...     print(f\"{branch}{stem}{node.node_name}\")\na\n|-- b\n|   |-- d\n|   +-- e\n+-- c\n</code></pre> <pre><code>&gt;&gt;&gt; for branch, stem, node in yield_tree(root, style=\"const\"):\n...     print(f\"{branch}{stem}{node.node_name}\")\na\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 d\n\u2502   \u2514\u2500\u2500 e\n\u2514\u2500\u2500 c\n</code></pre> <pre><code>&gt;&gt;&gt; for branch, stem, node in yield_tree(root, style=\"const_bold\"):\n...     print(f\"{branch}{stem}{node.node_name}\")\na\n\u2523\u2501\u2501 b\n\u2503   \u2523\u2501\u2501 d\n\u2503   \u2517\u2501\u2501 e\n\u2517\u2501\u2501 c\n</code></pre> <pre><code>&gt;&gt;&gt; for branch, stem, node in yield_tree(root, style=\"rounded\"):\n...     print(f\"{branch}{stem}{node.node_name}\")\na\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 d\n\u2502   \u2570\u2500\u2500 e\n\u2570\u2500\u2500 c\n</code></pre> <pre><code>&gt;&gt;&gt; for branch, stem, node in yield_tree(root, style=\"double\"):\n...     print(f\"{branch}{stem}{node.node_name}\")\na\n\u2560\u2550\u2550 b\n\u2551   \u2560\u2550\u2550 d\n\u2551   \u255a\u2550\u2550 e\n\u255a\u2550\u2550 c\n</code></pre> <p>Printing Attributes</p> <pre><code>&gt;&gt;&gt; for branch, stem, node in yield_tree(root, style=\"const\"):\n...     print(f\"{branch}{stem}{node.node_name} [age={node.age}]\")\na [age=90]\n\u251c\u2500\u2500 b [age=65]\n\u2502   \u251c\u2500\u2500 d [age=40]\n\u2502   \u2514\u2500\u2500 e [age=35]\n\u2514\u2500\u2500 c [age=60]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>Node</code> <p>tree to print</p> required <code>node_name_or_path</code> <code>str</code> <p>node to print from, becomes the root node of printing, optional</p> <code>''</code> <code>max_depth</code> <code>int</code> <p>maximum depth of tree to print, based on <code>depth</code> attribute, optional</p> <code>0</code> <code>style</code> <code>str</code> <p>style of print, defaults to const</p> <code>'const'</code> <code>custom_style</code> <code>Iterable[str]</code> <p>style of stem, branch and final stem, used when <code>style</code> is set to 'custom'</p> <code>[]</code>"},{"location":"bigtree/tree/export/#bigtree.tree.export.hprint_tree","title":"hprint_tree","text":"<pre><code>hprint_tree(\n    tree,\n    node_name_or_path=\"\",\n    max_depth=0,\n    intermediate_node_name=True,\n    style=\"const\",\n    custom_style=[],\n)\n</code></pre> <p>Print tree in horizontal orientation to console, starting from <code>tree</code>.</p> <ul> <li>Able to select which node to print from, resulting in a subtree, using <code>node_name_or_path</code></li> <li>Able to customize for maximum depth to print, using <code>max_depth</code></li> <li>Able to customize style, to choose from <code>ansi</code>, <code>ascii</code>, <code>const</code>, <code>const_bold</code>, <code>rounded</code>, <code>double</code>, and <code>custom</code> style     - Default style is <code>const</code> style     - If style is set to custom, user can choose their own style icons     - Style icons should have the same number of characters</li> </ul> <p>Examples:</p> <p>Printing tree</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, hprint_tree\n&gt;&gt;&gt; root = Node(\"a\")\n&gt;&gt;&gt; b = Node(\"b\", parent=root)\n&gt;&gt;&gt; c = Node(\"c\", parent=root)\n&gt;&gt;&gt; d = Node(\"d\", parent=b)\n&gt;&gt;&gt; e = Node(\"e\", parent=b)\n&gt;&gt;&gt; hprint_tree(root)\n           \u250c\u2500 d\n     \u250c\u2500 b \u2500\u2524\n\u2500 a \u2500\u2524     \u2514\u2500 e\n     \u2514\u2500 c\n</code></pre> <p>Printing Sub-tree</p> <pre><code>&gt;&gt;&gt; hprint_tree(root, node_name_or_path=\"b\")\n     \u250c\u2500 d\n\u2500 b \u2500\u2524\n     \u2514\u2500 e\n</code></pre> <pre><code>&gt;&gt;&gt; hprint_tree(root, max_depth=2)\n     \u250c\u2500 b\n\u2500 a \u2500\u2524\n     \u2514\u2500 c\n</code></pre> <p>Available Styles</p> <pre><code>&gt;&gt;&gt; hprint_tree(root, style=\"ansi\")\n           /- d\n     /- b -+\n- a -+     \\- e\n     \\- c\n</code></pre> <pre><code>&gt;&gt;&gt; hprint_tree(root, style=\"ascii\")\n           +- d\n     +- b -+\n- a -+     +- e\n     +- c\n</code></pre> <pre><code>&gt;&gt;&gt; hprint_tree(root, style=\"const\")\n           \u250c\u2500 d\n     \u250c\u2500 b \u2500\u2524\n\u2500 a \u2500\u2524     \u2514\u2500 e\n     \u2514\u2500 c\n</code></pre> <pre><code>&gt;&gt;&gt; hprint_tree(root, style=\"const_bold\")\n           \u250f\u2501 d\n     \u250f\u2501 b \u2501\u252b\n\u2501 a \u2501\u252b     \u2517\u2501 e\n     \u2517\u2501 c\n</code></pre> <pre><code>&gt;&gt;&gt; hprint_tree(root, style=\"rounded\")\n           \u256d\u2500 d\n     \u256d\u2500 b \u2500\u2524\n\u2500 a \u2500\u2524     \u2570\u2500 e\n     \u2570\u2500 c\n</code></pre> <pre><code>&gt;&gt;&gt; hprint_tree(root, style=\"double\")\n           \u2554\u2550 d\n     \u2554\u2550 b \u2550\u2563\n\u2550 a \u2550\u2563     \u255a\u2550 e\n     \u255a\u2550 c\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>Node</code> <p>tree to print</p> required <code>node_name_or_path</code> <code>str</code> <p>node to print from, becomes the root node of printing</p> <code>''</code> <code>max_depth</code> <code>int</code> <p>maximum depth of tree to print, based on <code>depth</code> attribute, optional</p> <code>0</code> <code>intermediate_node_name</code> <code>bool</code> <p>indicator if intermediate nodes have node names, defaults to True</p> <code>True</code> <code>style</code> <code>str</code> <p>style of print, defaults to const style</p> <code>'const'</code> <code>custom_style</code> <code>Iterable[str]</code> <p>style of icons, used when <code>style</code> is set to 'custom'</p> <code>[]</code>"},{"location":"bigtree/tree/export/#bigtree.tree.export.hyield_tree","title":"hyield_tree","text":"<pre><code>hyield_tree(\n    tree,\n    node_name_or_path=\"\",\n    max_depth=0,\n    intermediate_node_name=True,\n    style=\"const\",\n    custom_style=[],\n)\n</code></pre> <p>Yield tree in horizontal orientation to console, starting from <code>tree</code>.</p> <ul> <li>Able to select which node to print from, resulting in a subtree, using <code>node_name_or_path</code></li> <li>Able to customize for maximum depth to print, using <code>max_depth</code></li> <li>Able to customize style, to choose from <code>ansi</code>, <code>ascii</code>, <code>const</code>, <code>const_bold</code>, <code>rounded</code>, <code>double</code>, and <code>custom</code> style     - Default style is <code>const</code> style     - If style is set to custom, user can choose their own style icons     - Style icons should have the same number of characters</li> </ul> <p>Examples:</p> <p>Printing tree</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, hyield_tree\n&gt;&gt;&gt; root = Node(\"a\")\n&gt;&gt;&gt; b = Node(\"b\", parent=root)\n&gt;&gt;&gt; c = Node(\"c\", parent=root)\n&gt;&gt;&gt; d = Node(\"d\", parent=b)\n&gt;&gt;&gt; e = Node(\"e\", parent=b)\n&gt;&gt;&gt; result = hyield_tree(root)\n&gt;&gt;&gt; print(\"\\n\".join(result))\n           \u250c\u2500 d\n     \u250c\u2500 b \u2500\u2524\n\u2500 a \u2500\u2524     \u2514\u2500 e\n     \u2514\u2500 c\n</code></pre> <p>Printing Sub-tree</p> <pre><code>&gt;&gt;&gt; hprint_tree(root, node_name_or_path=\"b\")\n     \u250c\u2500 d\n\u2500 b \u2500\u2524\n     \u2514\u2500 e\n</code></pre> <pre><code>&gt;&gt;&gt; hprint_tree(root, max_depth=2)\n     \u250c\u2500 b\n\u2500 a \u2500\u2524\n     \u2514\u2500 c\n</code></pre> <p>Available Styles</p> <pre><code>&gt;&gt;&gt; hprint_tree(root, style=\"ansi\")\n           /- d\n     /- b -+\n- a -+     \\- e\n     \\- c\n</code></pre> <pre><code>&gt;&gt;&gt; hprint_tree(root, style=\"ascii\")\n           +- d\n     +- b -+\n- a -+     +- e\n     +- c\n</code></pre> <pre><code>&gt;&gt;&gt; hprint_tree(root, style=\"const\")\n           \u250c\u2500 d\n     \u250c\u2500 b \u2500\u2524\n\u2500 a \u2500\u2524     \u2514\u2500 e\n     \u2514\u2500 c\n</code></pre> <pre><code>&gt;&gt;&gt; hprint_tree(root, style=\"const_bold\")\n           \u250f\u2501 d\n     \u250f\u2501 b \u2501\u252b\n\u2501 a \u2501\u252b     \u2517\u2501 e\n     \u2517\u2501 c\n</code></pre> <pre><code>&gt;&gt;&gt; hprint_tree(root, style=\"rounded\")\n           \u256d\u2500 d\n     \u256d\u2500 b \u2500\u2524\n\u2500 a \u2500\u2524     \u2570\u2500 e\n     \u2570\u2500 c\n</code></pre> <pre><code>&gt;&gt;&gt; hprint_tree(root, style=\"double\")\n           \u2554\u2550 d\n     \u2554\u2550 b \u2550\u2563\n\u2550 a \u2550\u2563     \u255a\u2550 e\n     \u255a\u2550 c\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>Node</code> <p>tree to print</p> required <code>node_name_or_path</code> <code>str</code> <p>node to print from, becomes the root node of printing</p> <code>''</code> <code>max_depth</code> <code>int</code> <p>maximum depth of tree to print, based on <code>depth</code> attribute, optional</p> <code>0</code> <code>intermediate_node_name</code> <code>bool</code> <p>indicator if intermediate nodes have node names, defaults to True</p> <code>True</code> <code>style</code> <code>str</code> <p>style of print, defaults to const style</p> <code>'const'</code> <code>custom_style</code> <code>Iterable[str]</code> <p>style of icons, used when <code>style</code> is set to 'custom'</p> <code>[]</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>(List[str])</p>"},{"location":"bigtree/tree/export/#bigtree.tree.export.tree_to_newick","title":"tree_to_newick","text":"<pre><code>tree_to_newick(\n    tree,\n    intermediate_node_name=True,\n    length_attr=\"\",\n    length_sep=NewickCharacter.SEP,\n    attr_list=[],\n    attr_prefix=\"&amp;&amp;NHX:\",\n    attr_sep=NewickCharacter.SEP,\n)\n</code></pre> <p>Export tree to Newick notation. Useful for describing phylogenetic tree.</p> <p>In the Newick Notation (or New Hampshire Notation),   - Tree is represented in round brackets i.e., <code>(child1,child2,child3)parent</code>.   - If there are nested tree, they will be in nested round brackets i.e., <code>((grandchild1)child1,(grandchild2,grandchild3)child2)parent</code>.   - If there is length attribute, they will be beside the name i.e., <code>(child1:0.5,child2:0.1)parent</code>.   - If there are other attributes, attributes are represented in square brackets i.e., <code>(child1:0.5[S:human],child2:0.1[S:human])parent[S:parent]</code>.</p> Customizations include <ul> <li>Omitting names of root and intermediate nodes, default all node names are shown.</li> <li>Changing length separator to other symbol, default is <code>:</code>.</li> <li>Adding an attribute prefix, default is <code>&amp;&amp;NHX:</code>.</li> <li>Changing the attribute separator to other symbol, default is <code>:</code>.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, tree_to_newick\n&gt;&gt;&gt; root = Node(\"a\", species=\"human\")\n&gt;&gt;&gt; b = Node(\"b\", age=65, species=\"human\", parent=root)\n&gt;&gt;&gt; c = Node(\"c\", age=60, species=\"human\", parent=root)\n&gt;&gt;&gt; d = Node(\"d\", age=40, species=\"human\", parent=b)\n&gt;&gt;&gt; e = Node(\"e\", age=35, species=\"human\", parent=b)\n&gt;&gt;&gt; root.show()\na\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 d\n\u2502   \u2514\u2500\u2500 e\n\u2514\u2500\u2500 c\n</code></pre> <pre><code>&gt;&gt;&gt; tree_to_newick(root)\n'((d,e)b,c)a'\n</code></pre> <pre><code>&gt;&gt;&gt; tree_to_newick(root, length_attr=\"age\")\n'((d:40,e:35)b:65,c:60)a'\n</code></pre> <pre><code>&gt;&gt;&gt; tree_to_newick(root, length_attr=\"age\", attr_list=[\"species\"])\n'((d:40[&amp;&amp;NHX:species=human],e:35[&amp;&amp;NHX:species=human])b:65[&amp;&amp;NHX:species=human],c:60[&amp;&amp;NHX:species=human])a[&amp;&amp;NHX:species=human]'\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>Node</code> <p>tree to be exported</p> required <code>intermediate_node_name</code> <code>bool</code> <p>indicator if intermediate nodes have node names, defaults to True</p> <code>True</code> <code>length_attr</code> <code>str</code> <p>node length attribute to extract to beside name, optional</p> <code>''</code> <code>length_sep</code> <code>str</code> <p>separator between node name and length, used if length_attr is non-empty, defaults to \":\"</p> <code>SEP</code> <code>attr_list</code> <code>Iterable[str]</code> <p>list of node attributes to extract into square bracket, optional</p> <code>[]</code> <code>attr_prefix</code> <code>str</code> <p>prefix before all attributes, within square bracket, used if attr_list is non-empty, defaults to \"&amp;&amp;NHX:\"</p> <code>'&amp;&amp;NHX:'</code> <code>attr_sep</code> <code>str</code> <p>separator between attributes, within square brackets, used if attr_list is non-empty, defaults to \":\"</p> <code>SEP</code> <p>Returns:</p> Type Description <code>str</code> <p>(str)</p>"},{"location":"bigtree/tree/export/#bigtree.tree.export.tree_to_dict","title":"tree_to_dict","text":"<pre><code>tree_to_dict(\n    tree,\n    name_key=\"name\",\n    parent_key=\"\",\n    attr_dict={},\n    all_attrs=False,\n    max_depth=0,\n    skip_depth=0,\n    leaf_only=False,\n)\n</code></pre> <p>Export tree to dictionary.</p> <p>All descendants from <code>tree</code> will be exported, <code>tree</code> can be the root node or child node of tree.</p> <p>Exported dictionary will have key as node path, and node attributes as a nested dictionary.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, tree_to_dict\n&gt;&gt;&gt; root = Node(\"a\", age=90)\n&gt;&gt;&gt; b = Node(\"b\", age=65, parent=root)\n&gt;&gt;&gt; c = Node(\"c\", age=60, parent=root)\n&gt;&gt;&gt; d = Node(\"d\", age=40, parent=b)\n&gt;&gt;&gt; e = Node(\"e\", age=35, parent=b)\n&gt;&gt;&gt; tree_to_dict(root, name_key=\"name\", parent_key=\"parent\", attr_dict={\"age\": \"person age\"})\n{'/a': {'name': 'a', 'parent': None, 'person age': 90}, '/a/b': {'name': 'b', 'parent': 'a', 'person age': 65}, '/a/b/d': {'name': 'd', 'parent': 'b', 'person age': 40}, '/a/b/e': {'name': 'e', 'parent': 'b', 'person age': 35}, '/a/c': {'name': 'c', 'parent': 'a', 'person age': 60}}\n</code></pre> <p>For a subset of a tree</p> <pre><code>&gt;&gt;&gt; tree_to_dict(c, name_key=\"name\", parent_key=\"parent\", attr_dict={\"age\": \"person age\"})\n{'/a/c': {'name': 'c', 'parent': 'a', 'person age': 60}}\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>Node</code> <p>tree to be exported</p> required <code>name_key</code> <code>str</code> <p>dictionary key for <code>node.node_name</code>, defaults to 'name'</p> <code>'name'</code> <code>parent_key</code> <code>str</code> <p>dictionary key for <code>node.parent.node_name</code>, optional</p> <code>''</code> <code>attr_dict</code> <code>Dict[str, str]</code> <p>dictionary mapping node attributes to dictionary key, key: node attributes, value: corresponding dictionary key, optional</p> <code>{}</code> <code>all_attrs</code> <code>bool</code> <p>indicator whether to retrieve all <code>Node</code> attributes, overrides <code>attr_dict</code>, defaults to False</p> <code>False</code> <code>max_depth</code> <code>int</code> <p>maximum depth to export tree, optional</p> <code>0</code> <code>skip_depth</code> <code>int</code> <p>number of initial depths to skip, optional</p> <code>0</code> <code>leaf_only</code> <code>bool</code> <p>indicator to retrieve only information from leaf nodes</p> <code>False</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>(Dict[str, Any])</p>"},{"location":"bigtree/tree/export/#bigtree.tree.export.tree_to_nested_dict","title":"tree_to_nested_dict","text":"<pre><code>tree_to_nested_dict(\n    tree,\n    name_key=\"name\",\n    child_key=\"children\",\n    attr_dict={},\n    all_attrs=False,\n    max_depth=0,\n)\n</code></pre> <p>Export tree to nested dictionary.</p> <p>All descendants from <code>tree</code> will be exported, <code>tree</code> can be the root node or child node of tree.</p> <p>Exported dictionary will have key as node attribute names, and children as a nested recursive dictionary.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, tree_to_nested_dict\n&gt;&gt;&gt; root = Node(\"a\", age=90)\n&gt;&gt;&gt; b = Node(\"b\", age=65, parent=root)\n&gt;&gt;&gt; c = Node(\"c\", age=60, parent=root)\n&gt;&gt;&gt; d = Node(\"d\", age=40, parent=b)\n&gt;&gt;&gt; e = Node(\"e\", age=35, parent=b)\n&gt;&gt;&gt; tree_to_nested_dict(root, all_attrs=True)\n{'name': 'a', 'age': 90, 'children': [{'name': 'b', 'age': 65, 'children': [{'name': 'd', 'age': 40}, {'name': 'e', 'age': 35}]}, {'name': 'c', 'age': 60}]}\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>Node</code> <p>tree to be exported</p> required <code>name_key</code> <code>str</code> <p>dictionary key for <code>node.node_name</code>, defaults to 'name'</p> <code>'name'</code> <code>child_key</code> <code>str</code> <p>dictionary key for list of children, optional</p> <code>'children'</code> <code>attr_dict</code> <code>Dict[str, str]</code> <p>dictionary mapping node attributes to dictionary key, key: node attributes, value: corresponding dictionary key, optional</p> <code>{}</code> <code>all_attrs</code> <code>bool</code> <p>indicator whether to retrieve all <code>Node</code> attributes, overrides <code>attr_dict</code>, defaults to False</p> <code>False</code> <code>max_depth</code> <code>int</code> <p>maximum depth to export tree, optional</p> <code>0</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>(Dict[str, Any])</p>"},{"location":"bigtree/tree/export/#bigtree.tree.export.tree_to_dataframe","title":"tree_to_dataframe","text":"<pre><code>tree_to_dataframe(\n    tree,\n    path_col=\"path\",\n    name_col=\"name\",\n    parent_col=\"\",\n    attr_dict={},\n    all_attrs=False,\n    max_depth=0,\n    skip_depth=0,\n    leaf_only=False,\n)\n</code></pre> <p>Export tree to pandas DataFrame.</p> <p>All descendants from <code>tree</code> will be exported, <code>tree</code> can be the root node or child node of tree.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, tree_to_dataframe\n&gt;&gt;&gt; root = Node(\"a\", age=90)\n&gt;&gt;&gt; b = Node(\"b\", age=65, parent=root)\n&gt;&gt;&gt; c = Node(\"c\", age=60, parent=root)\n&gt;&gt;&gt; d = Node(\"d\", age=40, parent=b)\n&gt;&gt;&gt; e = Node(\"e\", age=35, parent=b)\n&gt;&gt;&gt; tree_to_dataframe(root, name_col=\"name\", parent_col=\"parent\", path_col=\"path\", attr_dict={\"age\": \"person age\"})\n     path name parent  person age\n0      /a    a   None          90\n1    /a/b    b      a          65\n2  /a/b/d    d      b          40\n3  /a/b/e    e      b          35\n4    /a/c    c      a          60\n</code></pre> <p>For a subset of a tree.</p> <pre><code>&gt;&gt;&gt; tree_to_dataframe(b, name_col=\"name\", parent_col=\"parent\", path_col=\"path\", attr_dict={\"age\": \"person age\"})\n     path name parent  person age\n0    /a/b    b      a          65\n1  /a/b/d    d      b          40\n2  /a/b/e    e      b          35\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>Node</code> <p>tree to be exported</p> required <code>path_col</code> <code>str</code> <p>column name for <code>node.path_name</code>, defaults to 'path'</p> <code>'path'</code> <code>name_col</code> <code>str</code> <p>column name for <code>node.node_name</code>, defaults to 'name'</p> <code>'name'</code> <code>parent_col</code> <code>str</code> <p>column name for <code>node.parent.node_name</code>, optional</p> <code>''</code> <code>attr_dict</code> <code>Dict[str, str]</code> <p>dictionary mapping node attributes to column name, key: node attributes, value: corresponding column in dataframe, optional</p> <code>{}</code> <code>all_attrs</code> <code>bool</code> <p>indicator whether to retrieve all <code>Node</code> attributes, overrides <code>attr_dict</code>, defaults to False</p> <code>False</code> <code>max_depth</code> <code>int</code> <p>maximum depth to export tree, optional</p> <code>0</code> <code>skip_depth</code> <code>int</code> <p>number of initial depths to skip, optional</p> <code>0</code> <code>leaf_only</code> <code>bool</code> <p>indicator to retrieve only information from leaf nodes</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>(pd.DataFrame)</p>"},{"location":"bigtree/tree/export/#bigtree.tree.export.tree_to_dot","title":"tree_to_dot","text":"<pre><code>tree_to_dot(\n    tree,\n    directed=True,\n    rankdir=\"TB\",\n    bg_colour=\"\",\n    node_colour=\"\",\n    node_shape=\"\",\n    edge_colour=\"\",\n    node_attr=\"\",\n    edge_attr=\"\",\n)\n</code></pre> <p>Export tree or list of trees to image. Possible node attributes include style, fillcolor, shape.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, tree_to_dot\n&gt;&gt;&gt; root = Node(\"a\", age=90)\n&gt;&gt;&gt; b = Node(\"b\", age=65, parent=root)\n&gt;&gt;&gt; c = Node(\"c\", age=60, parent=root)\n&gt;&gt;&gt; d = Node(\"d\", age=40, parent=b)\n&gt;&gt;&gt; e = Node(\"e\", age=35, parent=b)\n&gt;&gt;&gt; graph = tree_to_dot(root)\n</code></pre> <p>Display image directly without saving (requires IPython)</p> <pre><code>&gt;&gt;&gt; from IPython.display import Image, display\n&gt;&gt;&gt; plt = Image(graph.create_png())\n&gt;&gt;&gt; display(plt)\n&lt;IPython.core.display.Image object&gt;\n</code></pre> <p>Export to image, dot file, etc.</p> <pre><code>&gt;&gt;&gt; graph.write_png(\"assets/docstr/tree.png\")\n&gt;&gt;&gt; graph.write_dot(\"assets/docstr/tree.dot\")\n</code></pre> <p>Export to string</p> <pre><code>&gt;&gt;&gt; graph.to_string()\n'strict digraph G {\\nrankdir=TB;\\na0 [label=a];\\nb0 [label=b];\\na0 -&gt; b0;\\nd0 [label=d];\\nb0 -&gt; d0;\\ne0 [label=e];\\nb0 -&gt; e0;\\nc0 [label=c];\\na0 -&gt; c0;\\n}\\n'\n</code></pre> <p>Defining node and edge attributes (using node attribute)</p> <pre><code>&gt;&gt;&gt; class CustomNode(Node):\n...     def __init__(self, name, node_shape=\"\", edge_label=\"\", **kwargs):\n...         super().__init__(name, **kwargs)\n...         self.node_shape = node_shape\n...         self.edge_label = edge_label\n...\n...     @property\n...     def edge_attr(self):\n...         if self.edge_label:\n...             return {\"label\": self.edge_label}\n...         return {}\n...\n...     @property\n...     def node_attr(self):\n...         if self.node_shape:\n...             return {\"shape\": self.node_shape}\n...         return {}\n&gt;&gt;&gt;\n&gt;&gt;&gt;\n&gt;&gt;&gt; root = CustomNode(\"a\", node_shape=\"circle\")\n&gt;&gt;&gt; b = CustomNode(\"b\", edge_label=\"child\", parent=root)\n&gt;&gt;&gt; c = CustomNode(\"c\", edge_label=\"child\", parent=root)\n&gt;&gt;&gt; d = CustomNode(\"d\", node_shape=\"square\", edge_label=\"child\", parent=b)\n&gt;&gt;&gt; e = CustomNode(\"e\", node_shape=\"square\", edge_label=\"child\", parent=b)\n&gt;&gt;&gt; graph = tree_to_dot(root, node_colour=\"gold\", node_shape=\"diamond\", node_attr=\"node_attr\", edge_attr=\"edge_attr\")\n&gt;&gt;&gt; graph.write_png(\"assets/export_tree_dot.png\")\n</code></pre> <p></p> <p>Alternative way to define node and edge attributes (using callable function)</p> <pre><code>&gt;&gt;&gt; def get_node_attribute(node: Node):\n...     if node.is_leaf:\n...         return {\"shape\": \"square\"}\n...     return {\"shape\": \"circle\"}\n&gt;&gt;&gt;\n&gt;&gt;&gt;\n&gt;&gt;&gt; root = CustomNode(\"a\")\n&gt;&gt;&gt; b = CustomNode(\"b\", parent=root)\n&gt;&gt;&gt; c = CustomNode(\"c\", parent=root)\n&gt;&gt;&gt; d = CustomNode(\"d\", parent=b)\n&gt;&gt;&gt; e = CustomNode(\"e\", parent=b)\n&gt;&gt;&gt; graph = tree_to_dot(root, node_colour=\"gold\", node_attr=get_node_attribute)\n&gt;&gt;&gt; graph.write_png(\"assets/export_tree_dot_callable.png\")\n</code></pre> <p></p> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>Node / List[Node]</code> <p>tree or list of trees to be exported</p> required <code>directed</code> <code>bool</code> <p>indicator whether graph should be directed or undirected, defaults to True</p> <code>True</code> <code>rankdir</code> <code>str</code> <p>layout direction, defaults to 'TB' (top to bottom), can be 'BT' (bottom to top), 'LR' (left to right), 'RL' (right to left)</p> <code>'TB'</code> <code>bg_colour</code> <code>str</code> <p>background color of image, defaults to None</p> <code>''</code> <code>node_colour</code> <code>str</code> <p>fill colour of nodes, defaults to None</p> <code>''</code> <code>node_shape</code> <code>str</code> <p>shape of nodes, defaults to None Possible node_shape include \"circle\", \"square\", \"diamond\", \"triangle\"</p> <code>''</code> <code>edge_colour</code> <code>str</code> <p>colour of edges, defaults to None</p> <code>''</code> <code>node_attr</code> <code>str | Callable</code> <p>If string type, it refers to <code>Node</code> attribute for node style. If callable type, it takes in the node itself and returns the node style. This overrides <code>node_colour</code> and <code>node_shape</code> and defaults to None. Possible node styles include {\"style\": \"filled\", \"fillcolor\": \"gold\", \"shape\": \"diamond\"}</p> <code>''</code> <code>edge_attr</code> <code>str | Callable</code> <p>If stirng type, it refers to <code>Node</code> attribute for edge style. If callable type, it takes in the node itself and returns the edge style. This overrides <code>edge_colour</code>, and defaults to None. Possible edge styles include {\"style\": \"bold\", \"label\": \"edge label\", \"color\": \"black\"}</p> <code>''</code> <p>Returns:</p> Type Description <code>Dot</code> <p>(pydot.Dot)</p>"},{"location":"bigtree/tree/export/#bigtree.tree.export.tree_to_pillow","title":"tree_to_pillow","text":"<pre><code>tree_to_pillow(\n    tree,\n    width=0,\n    height=0,\n    start_pos=(10, 10),\n    font_family=\"\",\n    font_size=12,\n    font_colour=\"black\",\n    bg_colour=\"white\",\n    **kwargs\n)\n</code></pre> <p>Export tree to image (JPG, PNG). Image will be similar format as <code>print_tree</code>, accepts additional keyword arguments as input to <code>yield_tree</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, tree_to_pillow\n&gt;&gt;&gt; root = Node(\"a\", age=90)\n&gt;&gt;&gt; b = Node(\"b\", age=65, parent=root)\n&gt;&gt;&gt; c = Node(\"c\", age=60, parent=root)\n&gt;&gt;&gt; d = Node(\"d\", age=40, parent=b)\n&gt;&gt;&gt; e = Node(\"e\", age=35, parent=b)\n&gt;&gt;&gt; pillow_image = tree_to_pillow(root)\n</code></pre> <p>Export to image (PNG, JPG) file, etc.</p> <pre><code>&gt;&gt;&gt; pillow_image.save(\"assets/docstr/tree_pillow.png\")\n&gt;&gt;&gt; pillow_image.save(\"assets/docstr/tree_pillow.jpg\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>Node</code> <p>tree to be exported</p> required <code>width</code> <code>int</code> <p>width of image, optional as width of image is calculated automatically</p> <code>0</code> <code>height</code> <code>int</code> <p>height of image, optional as height of image is calculated automatically</p> <code>0</code> <code>start_pos</code> <code>Tuple[int, int]</code> <p>start position of text, (x-offset, y-offset), defaults to (10, 10)</p> <code>(10, 10)</code> <code>font_family</code> <code>str</code> <p>file path of font family, requires .ttf file, defaults to DejaVuSans</p> <code>''</code> <code>font_size</code> <code>int</code> <p>font size, defaults to 12</p> <code>12</code> <code>font_colour</code> <code>Union[Tuple[int, int, int], str]</code> <p>font colour, accepts tuple of RGB values or string, defaults to black</p> <code>'black'</code> <code>bg_colour</code> <code>Union[Tuple[int, int, int], str]</code> <p>background of image, accepts tuple of RGB values or string, defaults to white</p> <code>'white'</code> <p>Returns:</p> Type Description <code>Image</code> <p>(PIL.Image.Image)</p>"},{"location":"bigtree/tree/export/#bigtree.tree.export.tree_to_mermaid","title":"tree_to_mermaid","text":"<pre><code>tree_to_mermaid(\n    tree,\n    title=\"\",\n    rankdir=\"TB\",\n    line_shape=\"basis\",\n    node_colour=\"\",\n    node_border_colour=\"\",\n    node_border_width=1,\n    node_shape=\"rounded_edge\",\n    node_shape_attr=\"\",\n    edge_arrow=\"normal\",\n    edge_arrow_attr=\"\",\n    edge_label=\"\",\n    node_attr=\"\",\n    **kwargs\n)\n</code></pre> <p>Export tree to mermaid Markdown text. Accepts additional keyword arguments as input to <code>yield_tree</code>.</p> Parameters for customizations that applies to entire flowchart include <ul> <li>Title, <code>title</code></li> <li>Layout direction, <code>rankdir</code></li> <li>Line shape or curvature, <code>line_shape</code></li> <li>Fill colour of nodes, <code>node_colour</code></li> <li>Border colour of nodes, <code>node_border_colour</code></li> <li>Border width of nodes, <code>node_border_width</code></li> <li>Node shape, <code>node_shape</code></li> <li>Edge arrow style, <code>edge_arrow</code></li> </ul> Parameters for customizations that apply to customized nodes <ul> <li>Fill colour of nodes, fill under <code>node_attr</code></li> <li>Border colour of nodes, stroke under <code>node_attr</code></li> <li>Border width of nodes, stroke-width under <code>node_attr</code></li> <li>Node shape, <code>node_shape_attr</code></li> <li>Edge arrow style, <code>edge_arrow_attr</code></li> <li>Edge label, <code>edge_label</code></li> </ul> <p>Accepted Parameter Values</p> Possible rankdir <ul> <li><code>TB</code>: top-to-bottom</li> <li><code>BT</code>: bottom-to-top</li> <li><code>LR</code>: left-to-right</li> <li><code>RL</code>: right-to-left</li> </ul> Possible line_shape <ul> <li><code>basis</code></li> <li><code>bumpX</code>: used in LR or RL direction</li> <li><code>bumpY</code></li> <li><code>cardinal</code>: undirected</li> <li><code>catmullRom</code>: undirected</li> <li><code>linear</code>:</li> <li><code>monotoneX</code>: used in LR or RL direction</li> <li><code>monotoneY</code></li> <li><code>natural</code></li> <li><code>step</code>: used in LR or RL direction</li> <li><code>stepAfter</code></li> <li><code>stepBefore</code>: used in LR or RL direction</li> </ul> Possible node_shape <ul> <li><code>rounded_edge</code>: rectangular with rounded edges</li> <li><code>stadium</code>: (_) shape, rectangular with rounded ends</li> <li><code>subroutine</code>: ||_|| shape, rectangular with additional line at the ends</li> <li><code>cylindrical</code>: database node</li> <li><code>circle</code>: circular</li> <li><code>asymmetric</code>: &gt;_| shape</li> <li><code>rhombus</code>: decision node</li> <li><code>hexagon</code>: &lt;_&gt; shape</li> <li><code>parallelogram</code>: /_/ shape</li> <li><code>parallelogram_alt</code>: \\_\\ shape, inverted parallelogram</li> <li><code>trapezoid</code>: /_\\ shape</li> <li><code>trapezoid_alt</code>: \\_/ shape, inverted trapezoid</li> <li><code>double_circle</code></li> </ul> Possible edge_arrow <ul> <li><code>normal</code>: directed arrow, shaded arrowhead</li> <li><code>bold</code>: bold directed arrow</li> <li><code>dotted</code>: dotted directed arrow</li> <li><code>open</code>: line, undirected arrow</li> <li><code>bold_open</code>: bold line</li> <li><code>dotted_open</code>: dotted line</li> <li><code>invisible</code>: no line</li> <li><code>circle</code>: directed arrow with filled circle arrowhead</li> <li><code>cross</code>: directed arrow with cross arrowhead</li> <li><code>double_normal</code>: bidirectional directed arrow</li> <li><code>double_circle</code>: bidirectional directed arrow with filled circle arrowhead</li> <li><code>double_cross</code>: bidirectional directed arrow with cross arrowhead</li> </ul> <p>Refer to mermaid documentation for more information. Paste the output into any markdown file renderer to view the flowchart, alternatively visit the mermaid playground here.</p> <p>Note</p> <p>Advanced mermaid flowchart functionalities such as subgraphs and interactions (script, click) are not supported.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import tree_to_mermaid\n&gt;&gt;&gt; root = Node(\"a\", node_shape=\"rhombus\")\n&gt;&gt;&gt; b = Node(\"b\", edge_arrow=\"bold\", edge_label=\"Child 1\", parent=root)\n&gt;&gt;&gt; c = Node(\"c\", edge_arrow=\"dotted\", edge_label=\"Child 2\", parent=root)\n&gt;&gt;&gt; d = Node(\"d\", node_style=\"fill:yellow, stroke:black\", parent=b)\n&gt;&gt;&gt; e = Node(\"e\", parent=b)\n&gt;&gt;&gt; graph = tree_to_mermaid(root)\n&gt;&gt;&gt; print(graph)\n```mermaid\n%%{ init: { 'flowchart': { 'curve': 'basis' } } }%%\nflowchart TB\n0(\"a\") --&gt; 0-0(\"b\")\n0-0 --&gt; 0-0-0(\"d\")\n0-0 --&gt; 0-0-1(\"e\")\n0(\"a\") --&gt; 0-1(\"c\")\nclassDef default stroke-width:1\n```\n</code></pre> <p>Customize node shape, edge label, edge arrow, and custom node attributes</p> <pre><code>&gt;&gt;&gt; graph = tree_to_mermaid(root, node_shape_attr=\"node_shape\", edge_label=\"edge_label\", edge_arrow_attr=\"edge_arrow\", node_attr=\"node_style\")\n&gt;&gt;&gt; print(graph)\n```mermaid\n%%{ init: { 'flowchart': { 'curve': 'basis' } } }%%\nflowchart TB\n0{\"a\"} ==&gt;|Child 1| 0-0(\"b\")\n0-0:::class0-0-0 --&gt; 0-0-0(\"d\")\n0-0 --&gt; 0-0-1(\"e\")\n0{\"a\"} -.-&gt;|Child 2| 0-1(\"c\")\nclassDef default stroke-width:1\nclassDef class0-0-0 fill:yellow, stroke:black\n```\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>Node</code> <p>tree to be exported</p> required <code>title</code> <code>str</code> <p>title, defaults to None</p> <code>''</code> <code>rankdir</code> <code>str</code> <p>layout direction, defaults to 'TB' (top to bottom), can be 'BT' (bottom to top), 'LR' (left to right), 'RL' (right to left)</p> <code>'TB'</code> <code>line_shape</code> <code>str</code> <p>line shape or curvature, defaults to 'basis'</p> <code>'basis'</code> <code>node_colour</code> <code>str</code> <p>fill colour of nodes, can be colour name or hexcode, defaults to None</p> <code>''</code> <code>node_border_colour</code> <code>str</code> <p>border colour of nodes, can be colour name or hexcode, defaults to None</p> <code>''</code> <code>node_border_width</code> <code>float</code> <p>width of node border, defaults to 1</p> <code>1</code> <code>node_shape</code> <code>str</code> <p>node shape, sets the shape of every node, defaults to 'rounded_edge'</p> <code>'rounded_edge'</code> <code>node_shape_attr</code> <code>str | Callable</code> <p>If string type, it refers to <code>Node</code> attribute for node shape. If callable type, it takes in the node itself and returns the node shape. This sets the shape of custom nodes, and overrides default <code>node_shape</code>, defaults to None</p> <code>''</code> <code>edge_arrow</code> <code>str</code> <p>edge arrow style from parent to itself, sets the arrow style of every edge, defaults to 'normal'</p> <code>'normal'</code> <code>edge_arrow_attr</code> <code>str | Callable</code> <p>If string type, it refers to <code>Node</code> attribute for edge arrow style. If callable type, it takes in the node itself and returns the edge arrow style. This sets the edge arrow style of custom nodes from parent to itself, and overrides default <code>edge_arrow</code>, defaults to None</p> <code>''</code> <code>edge_label</code> <code>str</code> <p><code>Node</code> attribute for edge label from parent to itself, defaults to None</p> <code>''</code> <code>node_attr</code> <code>str | Callable</code> <p>If string type, it refers to <code>Node</code> attribute for node style. If callable type, it takes in the node itself and returns the node style. This overrides <code>node_colour</code>, <code>node_border_colour</code>, and <code>node_border_width</code>, defaults to None</p> <code>''</code> <p>Returns:</p> Type Description <code>str</code> <p>(str)</p>"},{"location":"bigtree/tree/helper/","title":"\ud83d\udd27 Helper","text":"<p>Helper functions that can come in handy.</p>"},{"location":"bigtree/tree/helper/#bigtree.tree.helper","title":"bigtree.tree.helper","text":""},{"location":"bigtree/tree/helper/#bigtree.tree.helper.clone_tree","title":"clone_tree","text":"<pre><code>clone_tree(tree, node_type)\n</code></pre> <p>Clone tree to another <code>Node</code> type. If the same type is needed, simply do a tree.copy().</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import BaseNode, Node, clone_tree\n&gt;&gt;&gt; root = BaseNode(name=\"a\")\n&gt;&gt;&gt; b = BaseNode(name=\"b\", parent=root)\n&gt;&gt;&gt; clone_tree(root, Node)\nNode(/a, )\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>BaseNode</code> <p>tree to be cloned, must inherit from BaseNode</p> required <code>node_type</code> <code>Type[BaseNode]</code> <p>type of cloned tree</p> required <p>Returns:</p> Type Description <code>BaseNodeT</code> <p>(BaseNode)</p>"},{"location":"bigtree/tree/helper/#bigtree.tree.helper.get_subtree","title":"get_subtree","text":"<pre><code>get_subtree(tree, node_name_or_path='', max_depth=0)\n</code></pre> <p>Get subtree based on node name or node path, and/or maximum depth of tree.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, get_subtree\n&gt;&gt;&gt; root = Node(\"a\")\n&gt;&gt;&gt; b = Node(\"b\", parent=root)\n&gt;&gt;&gt; c = Node(\"c\", parent=b)\n&gt;&gt;&gt; d = Node(\"d\", parent=b)\n&gt;&gt;&gt; e = Node(\"e\", parent=root)\n&gt;&gt;&gt; root.show()\na\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 c\n\u2502   \u2514\u2500\u2500 d\n\u2514\u2500\u2500 e\n</code></pre> <p>Get subtree</p> <pre><code>&gt;&gt;&gt; root_subtree = get_subtree(root, \"b\")\n&gt;&gt;&gt; root_subtree.show()\nb\n\u251c\u2500\u2500 c\n\u2514\u2500\u2500 d\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>Node</code> <p>existing tree</p> required <code>node_name_or_path</code> <code>str</code> <p>node name or path to get subtree, defaults to None</p> <code>''</code> <code>max_depth</code> <code>int</code> <p>maximum depth of subtree, based on <code>depth</code> attribute, defaults to None</p> <code>0</code> <p>Returns:</p> Type Description <code>NodeT</code> <p>(Node)</p>"},{"location":"bigtree/tree/helper/#bigtree.tree.helper.prune_tree","title":"prune_tree","text":"<pre><code>prune_tree(\n    tree, prune_path=\"\", exact=False, sep=\"/\", max_depth=0\n)\n</code></pre> <p>Prune tree by path or depth, returns the root of a copy of the original tree.</p> <p>For pruning by <code>prune_path</code>,</p> <ul> <li>All siblings along the prune path will be removed.</li> <li>If <code>exact=True</code>, all descendants of prune path will be removed.</li> <li>Prune path can be string (only one path) or a list of strings (multiple paths).</li> <li>Prune path name should be unique, can be full path, partial path (trailing part of path), or node name.</li> </ul> <p>For pruning by <code>max_depth</code>,</p> <ul> <li>All nodes that are beyond <code>max_depth</code> will be removed.</li> </ul> <p>Path should contain <code>Node</code> name, separated by <code>sep</code>.</p> <ul> <li>For example: Path string \"a/b\" refers to Node(\"b\") with parent Node(\"a\").</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, prune_tree\n&gt;&gt;&gt; root = Node(\"a\")\n&gt;&gt;&gt; b = Node(\"b\", parent=root)\n&gt;&gt;&gt; c = Node(\"c\", parent=b)\n&gt;&gt;&gt; d = Node(\"d\", parent=b)\n&gt;&gt;&gt; e = Node(\"e\", parent=root)\n&gt;&gt;&gt; root.show()\na\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 c\n\u2502   \u2514\u2500\u2500 d\n\u2514\u2500\u2500 e\n</code></pre> <p>Prune (default is keep descendants)</p> <pre><code>&gt;&gt;&gt; root_pruned = prune_tree(root, \"a/b\")\n&gt;&gt;&gt; root_pruned.show()\na\n\u2514\u2500\u2500 b\n    \u251c\u2500\u2500 c\n    \u2514\u2500\u2500 d\n</code></pre> <p>Prune exact path</p> <pre><code>&gt;&gt;&gt; root_pruned = prune_tree(root, \"a/b\", exact=True)\n&gt;&gt;&gt; root_pruned.show()\na\n\u2514\u2500\u2500 b\n</code></pre> <p>Prune multiple paths</p> <pre><code>&gt;&gt;&gt; root_pruned = prune_tree(root, [\"a/b/d\", \"a/e\"])\n&gt;&gt;&gt; root_pruned.show()\na\n\u251c\u2500\u2500 b\n\u2502   \u2514\u2500\u2500 d\n\u2514\u2500\u2500 e\n</code></pre> <p>Prune by depth</p> <pre><code>&gt;&gt;&gt; root_pruned = prune_tree(root, max_depth=2)\n&gt;&gt;&gt; root_pruned.show()\na\n\u251c\u2500\u2500 b\n\u2514\u2500\u2500 e\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>Union[BinaryNode, Node]</code> <p>existing tree</p> required <code>prune_path</code> <code>List[str] | str</code> <p>prune path(s), all siblings along the prune path(s) will be removed</p> <code>''</code> <code>exact</code> <code>bool</code> <p>prune path(s) to be exactly the path, defaults to False (descendants of the path are retained)</p> <code>False</code> <code>sep</code> <code>str</code> <p>path separator of <code>prune_path</code></p> <code>'/'</code> <code>max_depth</code> <code>int</code> <p>maximum depth of pruned tree, based on <code>depth</code> attribute, defaults to None</p> <code>0</code> <p>Returns:</p> Type Description <code>Union[BinaryNodeT, NodeT]</code> <p>(Union[BinaryNode, Node])</p>"},{"location":"bigtree/tree/helper/#bigtree.tree.helper.get_tree_diff","title":"get_tree_diff","text":"<pre><code>get_tree_diff(\n    tree, other_tree, only_diff=True, attr_list=[]\n)\n</code></pre> <p>Get difference of <code>tree</code> to <code>other_tree</code>, changes are relative to <code>tree</code>.</p> <p>Compares the difference in tree structure (default), but can also compare tree attributes using <code>attr_list</code>. Function can return only the differences (default), or all original tree nodes and differences.</p> <p>Comparing tree structure:</p> <ul> <li>(+) and (-) will be added to node name relative to <code>tree</code>.</li> <li>For example: (+) refers to nodes that are in <code>other_tree</code> but not <code>tree</code>.</li> <li>For example: (-) refers to nodes that are in <code>tree</code> but not <code>other_tree</code>.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Create original tree\n&gt;&gt;&gt; from bigtree import Node, get_tree_diff, list_to_tree\n&gt;&gt;&gt; root = list_to_tree([\"Downloads/Pictures/photo1.jpg\", \"Downloads/file1.doc\", \"Downloads/photo2.jpg\"])\n&gt;&gt;&gt; root.show()\nDownloads\n\u251c\u2500\u2500 Pictures\n\u2502   \u2514\u2500\u2500 photo1.jpg\n\u251c\u2500\u2500 file1.doc\n\u2514\u2500\u2500 photo2.jpg\n</code></pre> <pre><code>&gt;&gt;&gt; # Create other tree\n&gt;&gt;&gt; root_other = list_to_tree([\"Downloads/Pictures/photo1.jpg\", \"Downloads/Pictures/photo2.jpg\", \"Downloads/file1.doc\"])\n&gt;&gt;&gt; root_other.show()\nDownloads\n\u251c\u2500\u2500 Pictures\n\u2502   \u251c\u2500\u2500 photo1.jpg\n\u2502   \u2514\u2500\u2500 photo2.jpg\n\u2514\u2500\u2500 file1.doc\n</code></pre> <pre><code>&gt;&gt;&gt; # Get tree differences\n&gt;&gt;&gt; tree_diff = get_tree_diff(root, root_other)\n&gt;&gt;&gt; tree_diff.show()\nDownloads\n\u251c\u2500\u2500 photo2.jpg (-)\n\u2514\u2500\u2500 Pictures\n    \u2514\u2500\u2500 photo2.jpg (+)\n</code></pre> <pre><code>&gt;&gt;&gt; tree_diff = get_tree_diff(root, root_other, only_diff=False)\n&gt;&gt;&gt; tree_diff.show()\nDownloads\n\u251c\u2500\u2500 Pictures\n\u2502   \u251c\u2500\u2500 photo1.jpg\n\u2502   \u2514\u2500\u2500 photo2.jpg (+)\n\u251c\u2500\u2500 file1.doc\n\u2514\u2500\u2500 photo2.jpg (-)\n</code></pre> <p>Comparing tree attributes</p> <ul> <li>(~) will be added to node name if there are differences in tree attributes defined in <code>attr_list</code>.</li> <li>The node's attributes will be a list of [value in <code>tree</code>, value in <code>other_tree</code>]</li> </ul> <pre><code>&gt;&gt;&gt; # Create original tree\n&gt;&gt;&gt; root = Node(\"Downloads\")\n&gt;&gt;&gt; picture_folder = Node(\"Pictures\", parent=root)\n&gt;&gt;&gt; photo2 = Node(\"photo1.jpg\", tags=\"photo1\", parent=picture_folder)\n&gt;&gt;&gt; file1 = Node(\"file1.doc\", tags=\"file1\", parent=root)\n&gt;&gt;&gt; root.show(attr_list=[\"tags\"])\nDownloads\n\u251c\u2500\u2500 Pictures\n\u2502   \u2514\u2500\u2500 photo1.jpg [tags=photo1]\n\u2514\u2500\u2500 file1.doc [tags=file1]\n</code></pre> <pre><code>&gt;&gt;&gt; # Create other tree\n&gt;&gt;&gt; root_other = Node(\"Downloads\")\n&gt;&gt;&gt; picture_folder = Node(\"Pictures\", parent=root_other)\n&gt;&gt;&gt; photo1 = Node(\"photo1.jpg\", tags=\"photo1-edited\", parent=picture_folder)\n&gt;&gt;&gt; photo2 = Node(\"photo2.jpg\", tags=\"photo2-new\", parent=picture_folder)\n&gt;&gt;&gt; file1 = Node(\"file1.doc\", tags=\"file1\", parent=root_other)\n&gt;&gt;&gt; root_other.show(attr_list=[\"tags\"])\nDownloads\n\u251c\u2500\u2500 Pictures\n\u2502   \u251c\u2500\u2500 photo1.jpg [tags=photo1-edited]\n\u2502   \u2514\u2500\u2500 photo2.jpg [tags=photo2-new]\n\u2514\u2500\u2500 file1.doc [tags=file1]\n</code></pre> <pre><code>&gt;&gt;&gt; # Get tree differences\n&gt;&gt;&gt; tree_diff = get_tree_diff(root, root_other, attr_list=[\"tags\"])\n&gt;&gt;&gt; tree_diff.show(attr_list=[\"tags\"])\nDownloads\n\u2514\u2500\u2500 Pictures\n    \u251c\u2500\u2500 photo1.jpg (~) [tags=('photo1', 'photo1-edited')]\n    \u2514\u2500\u2500 photo2.jpg (+)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>Node</code> <p>tree to be compared against</p> required <code>other_tree</code> <code>Node</code> <p>tree to be compared with</p> required <code>only_diff</code> <code>bool</code> <p>indicator to show all nodes or only nodes that are different (+/-), defaults to True</p> <code>True</code> <code>attr_list</code> <code>List[str]</code> <p>tree attributes to check for difference, defaults to empty list</p> <code>[]</code> <p>Returns:</p> Type Description <code>Node</code> <p>(Node)</p>"},{"location":"bigtree/tree/modify/","title":"\ud83d\udcdd Modify","text":"<p>There are two types of modification available</p> <ol> <li>Non-replacing scenario: Shift or copy nodes within same tree or between two trees using <code>from_paths</code> (list of paths) and <code>to_paths</code> (list of paths).</li> <li>Replacing scenario: Shift or copy nodes within same tree or between two trees while replacing the to-node using <code>from_paths</code> (list of paths) and <code>to_paths</code> (list of paths).</li> </ol>"},{"location":"bigtree/tree/modify/#available-configurations-for-customization","title":"Available Configurations for Customization","text":"<p>In non-replacing scenario, there are several configurations available for customization.</p> Configuration Description Default Value <code>copy</code> Indicates whether it is to shift the nodes, or copy the nodes False (nodes are shifted, not copied) <code>to_tree</code> Indicates whether shifting/copying is within the same tree, or between different trees None (nodes are shifted/copied within the same tree) <code>skippable</code> Skip shifting/copying of nodes if from_path cannot be found False (from-node must be found) <code>overriding</code> Override existing node if it exists False (to-node must not exist) <code>merge_children</code> Shift/copy children of from-node and remove intermediate parent node False (children are not merged) <code>merge_leaves</code> Shift/copy leaves of from-node and remove all intermediate nodes False (leaves are not merged) <code>delete_children</code> Shift/copy node only and delete its children False (nodes are shifted/copied together with children) <p>In replacing scenario, all the configurations are also available except <code>overriding</code>, <code>merge_children</code>, and <code>merge_leaves</code> as it is doing a one-to-one replacement. It is by default overriding, and there is nothing to merge.</p> <p>Note</p> <p><code>merge_children</code> and <code>merge_leaves</code> cannot be simultaneously set to <code>True</code>.</p> <p>Note</p> <p>Error will always be thrown if multiple from-nodes are found, paths in <code>from_paths</code> must be unique.</p>"},{"location":"bigtree/tree/modify/#tree-modification-permutations","title":"Tree Modification Permutations","text":"<p>There are several ways you can mix and match the tree modification methods. If you know all the parameters to choose, feel free to use <code>copy_or_shift_logic</code> or <code>replace_logic</code> methods as they are the most customizable. All other methods calls these 2 methods directly.</p> Shift / Copy? Same tree / Between two trees? Replace destination node? Method to use Shift Same tree No <code>shift_nodes</code> Copy Same tree No <code>copy_nodes</code> Copy Between two trees No <code>copy_nodes_from_tree_to_tree</code> Any Any No <code>copy_or_shift_logic</code> Shift Same tree Yes <code>shift_and_replace_nodes</code> Copy Between two trees Yes <code>copy_and_replace_nodes_from_tree_to_tree</code> Any Any Yes <code>replace_logic</code>"},{"location":"bigtree/tree/modify/#tree-modification-illustration","title":"Tree Modification Illustration","text":""},{"location":"bigtree/tree/modify/#sample-tree-modification-shift-copy-delete","title":"Sample Tree Modification (Shift, Copy, Delete)","text":"Setting Sample path in <code>from_paths</code> Sample path in <code>to_paths</code> Description Default \"/a/c\" \"/a/b/c\" Shift/copy node <code>c</code> Default \"/c\" \"/a/b/c\" Shift/copy node <code>c</code> Default \"c\" \"/a/b/c\" Shift/copy node <code>c</code> Default \"/a/e\" None Delete node <code>e</code> skippable \"/a/c\" \"/a/b/c\" Shift/copy node <code>c</code>, skip if \"/a/c\" cannot be found"},{"location":"bigtree/tree/modify/#sample-tree-modification-advanced","title":"Sample Tree Modification (Advanced)","text":"Setting Sample path in <code>from_paths</code> Sample path in <code>to_paths</code> Description overriding \"a/b/c\" \"a/d/c\" Shift/copy node <code>c</code>, override if \"a/d/c\" exists merge_children \"a/b/c\" \"a/d/c\" If path not present: Shift/copy children of node <code>c</code> to be children of node <code>d</code>, removing node <code>c</code>If path present: Shift/copy children of node <code>c</code> to be merged with existing \"a/d/c\" children merge_children + overriding \"a/b/c\" \"a/d/c\" If path not present: Behaves like merge_childrenIf path present: Behaves like overriding merge_leaves \"a/b/c\" \"a/d/c\" If path not present: Shift/copy leaves of node <code>c</code> to be children of node <code>d</code>If path present: Shift/copy leaves of node <code>c</code> to be merged with existing \"a/d/c\" children - merge_leaves + overriding \"a/b/c\" \"a/d/c\" If path not present: Behaves like merge_leavesIf path present: Behaves like overriding, but original node <code>c</code> remains delete_children \"a/b\" \"a/d/b\" Shift/copy node <code>b</code> only without any node <code>b</code> children"},{"location":"bigtree/tree/modify/#bigtree.tree.modify","title":"bigtree.tree.modify","text":""},{"location":"bigtree/tree/modify/#bigtree.tree.modify.shift_nodes","title":"shift_nodes","text":"<pre><code>shift_nodes(\n    tree,\n    from_paths,\n    to_paths,\n    sep=\"/\",\n    skippable=False,\n    overriding=False,\n    merge_children=False,\n    merge_leaves=False,\n    delete_children=False,\n    with_full_path=False,\n)\n</code></pre> <p>Shift nodes from <code>from_paths</code> to <code>to_paths</code> in-place.</p> <ul> <li>Creates intermediate nodes if to path is not present</li> <li>Able to skip nodes if from path is not found, defaults to False (from-nodes must be found; not skippable).</li> <li>Able to override existing node if it exists, defaults to False (to-nodes must not exist; not overridden).</li> <li>Able to merge children and remove intermediate parent node, defaults to False (nodes are shifted; not merged).</li> <li>Able to merge only leaf nodes and remove all intermediate nodes, defaults to False (nodes are shifted; not merged)</li> <li>Able to shift node only and delete children, defaults to False (nodes are shifted together with children).</li> </ul> <p>For paths in <code>from_paths</code> and <code>to_paths</code>,</p> <ul> <li>Path name can be with or without leading tree path separator symbol.</li> </ul> <p>For paths in <code>from_paths</code>,</p> <ul> <li>Path name can be partial path (trailing part of path) or node name.</li> <li>If <code>with_full_path=True</code>, path name must be full path.</li> <li>Path name must be unique to one node.</li> </ul> <p>For paths in <code>to_paths</code>,</p> <ul> <li>Path name must be full path.</li> <li>Can set to empty string or None to delete the path in <code>from_paths</code>, note that <code>copy</code> must be set to False.</li> </ul> <p>If <code>merge_children=True</code>,</p> <ul> <li>If <code>to_path</code> is not present, it shifts children of <code>from_path</code>.</li> <li>If <code>to_path</code> is present, and <code>overriding=False</code>, original and new children are merged.</li> <li>If <code>to_path</code> is present and <code>overriding=True</code>, it behaves like overriding and only new children are retained.</li> </ul> <p>If <code>merge_leaves=True</code>,</p> <ul> <li>If <code>to_path</code> is not present, it shifts leaves of <code>from_path</code>.</li> <li>If <code>to_path</code> is present, and <code>overriding=False</code>, original children and leaves are merged.</li> <li>If <code>to_path</code> is present and <code>overriding=True</code>, it behaves like overriding and only new leaves are retained,     original non-leaf nodes in <code>from_path</code> are retained.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import list_to_tree, str_to_tree, shift_nodes\n&gt;&gt;&gt; root = list_to_tree([\"Downloads/photo1.jpg\", \"Downloads/file1.doc\"])\n&gt;&gt;&gt; root.show()\nDownloads\n\u251c\u2500\u2500 photo1.jpg\n\u2514\u2500\u2500 file1.doc\n</code></pre> <pre><code>&gt;&gt;&gt; shift_nodes(\n...     tree=root,\n...     from_paths=[\"Downloads/photo1.jpg\", \"Downloads/file1.doc\"],\n...     to_paths=[\"Downloads/Pictures/photo1.jpg\", \"Downloads/Files/file1.doc\"],\n... )\n&gt;&gt;&gt; root.show()\nDownloads\n\u251c\u2500\u2500 Pictures\n\u2502   \u2514\u2500\u2500 photo1.jpg\n\u2514\u2500\u2500 Files\n    \u2514\u2500\u2500 file1.doc\n</code></pre> <p>To delete node,</p> <pre><code>&gt;&gt;&gt; root = list_to_tree([\"Downloads/photo1.jpg\", \"Downloads/file1.doc\"])\n&gt;&gt;&gt; root.show()\nDownloads\n\u251c\u2500\u2500 photo1.jpg\n\u2514\u2500\u2500 file1.doc\n</code></pre> <pre><code>&gt;&gt;&gt; shift_nodes(root, [\"Downloads/photo1.jpg\"], [None])\n&gt;&gt;&gt; root.show()\nDownloads\n\u2514\u2500\u2500 file1.doc\n</code></pre> <p>In overriding case,</p> <pre><code>&gt;&gt;&gt; root = str_to_tree(\n... \"Downloads\\n\"\n... \"\u251c\u2500\u2500 Misc\\n\"\n... \"\u2502   \u2514\u2500\u2500 Pictures\\n\"\n... \"\u2502       \u2514\u2500\u2500 photo1.jpg\\n\"\n... \"\u2514\u2500\u2500 Pictures\\n\"\n... \"    \u2514\u2500\u2500 photo2.jpg\"\n... )\n&gt;&gt;&gt; root.show()\nDownloads\n\u251c\u2500\u2500 Misc\n\u2502   \u2514\u2500\u2500 Pictures\n\u2502       \u2514\u2500\u2500 photo1.jpg\n\u2514\u2500\u2500 Pictures\n    \u2514\u2500\u2500 photo2.jpg\n</code></pre> <pre><code>&gt;&gt;&gt; shift_nodes(root, [\"Downloads/Misc/Pictures\"], [\"Downloads/Pictures\"], overriding=True)\n&gt;&gt;&gt; root.show()\nDownloads\n\u251c\u2500\u2500 Misc\n\u2514\u2500\u2500 Pictures\n    \u2514\u2500\u2500 photo1.jpg\n</code></pre> <p>In <code>merge_children=True</code> case, child nodes are shifted instead of the parent node.</p> <ul> <li>If the path already exists, child nodes are merged with existing children.</li> <li>If same node is shifted, the child nodes of the node are merged with the node's parent.</li> </ul> <pre><code>&gt;&gt;&gt; root = str_to_tree(\n... \"Downloads\\n\"\n... \"\u251c\u2500\u2500 Misc\\n\"\n... \"\u2502   \u251c\u2500\u2500 Pictures\\n\"\n... \"\u2502   \u2502   \u2514\u2500\u2500 photo2.jpg\\n\"\n... \"\u2502   \u2514\u2500\u2500 Applications\\n\"\n... \"\u2502       \u2514\u2500\u2500 Chrome.exe\\n\"\n... \"\u251c\u2500\u2500 Pictures\\n\"\n... \"\u2502   \u2514\u2500\u2500 photo1.jpg\\n\"\n... \"\u2514\u2500\u2500 dummy\\n\"\n... \"    \u2514\u2500\u2500 Files\\n\"\n... \"        \u2514\u2500\u2500 file1.doc\"\n... )\n&gt;&gt;&gt; root.show()\nDownloads\n\u251c\u2500\u2500 Misc\n\u2502   \u251c\u2500\u2500 Pictures\n\u2502   \u2502   \u2514\u2500\u2500 photo2.jpg\n\u2502   \u2514\u2500\u2500 Applications\n\u2502       \u2514\u2500\u2500 Chrome.exe\n\u251c\u2500\u2500 Pictures\n\u2502   \u2514\u2500\u2500 photo1.jpg\n\u2514\u2500\u2500 dummy\n    \u2514\u2500\u2500 Files\n        \u2514\u2500\u2500 file1.doc\n</code></pre> <pre><code>&gt;&gt;&gt; shift_nodes(\n...     root,\n...     [\"Downloads/Misc/Pictures\", \"Applications\", \"Downloads/dummy\"],\n...     [\"Downloads/Pictures\", \"Downloads/Applications\", \"Downloads/dummy\"],\n...     merge_children=True,\n... )\n&gt;&gt;&gt; root.show()\nDownloads\n\u251c\u2500\u2500 Misc\n\u251c\u2500\u2500 Pictures\n\u2502   \u251c\u2500\u2500 photo1.jpg\n\u2502   \u2514\u2500\u2500 photo2.jpg\n\u251c\u2500\u2500 Chrome.exe\n\u2514\u2500\u2500 Files\n    \u2514\u2500\u2500 file1.doc\n</code></pre> <p>In <code>merge_leaves=True</code> case, leaf nodes are copied instead of the parent node.</p> <ul> <li>If the path already exists, leaf nodes are merged with existing children.</li> <li>If same node is copied, the leaf nodes of the node are merged with the node's parent.</li> </ul> <pre><code>&gt;&gt;&gt; root = str_to_tree(\n... \"Downloads\\n\"\n... \"\u251c\u2500\u2500 Misc\\n\"\n... \"\u2502   \u251c\u2500\u2500 Pictures\\n\"\n... \"\u2502   \u2502   \u2514\u2500\u2500 photo2.jpg\\n\"\n... \"\u2502   \u2514\u2500\u2500 Applications\\n\"\n... \"\u2502       \u2514\u2500\u2500 Chrome.exe\\n\"\n... \"\u251c\u2500\u2500 Pictures\\n\"\n... \"\u2502   \u2514\u2500\u2500 photo1.jpg\\n\"\n... \"\u2514\u2500\u2500 dummy\\n\"\n... \"    \u2514\u2500\u2500 Files\\n\"\n... \"        \u2514\u2500\u2500 file1.doc\"\n... )\n&gt;&gt;&gt; root.show()\nDownloads\n\u251c\u2500\u2500 Misc\n\u2502   \u251c\u2500\u2500 Pictures\n\u2502   \u2502   \u2514\u2500\u2500 photo2.jpg\n\u2502   \u2514\u2500\u2500 Applications\n\u2502       \u2514\u2500\u2500 Chrome.exe\n\u251c\u2500\u2500 Pictures\n\u2502   \u2514\u2500\u2500 photo1.jpg\n\u2514\u2500\u2500 dummy\n    \u2514\u2500\u2500 Files\n        \u2514\u2500\u2500 file1.doc\n</code></pre> <pre><code>&gt;&gt;&gt; shift_nodes(\n...     root,\n...     [\"Downloads/Misc/Pictures\", \"Applications\", \"Downloads/dummy\"],\n...     [\"Downloads/Pictures\", \"Downloads/Applications\", \"Downloads/dummy\"],\n...     merge_leaves=True,\n... )\n&gt;&gt;&gt; root.show()\nDownloads\n\u251c\u2500\u2500 Misc\n\u2502   \u251c\u2500\u2500 Pictures\n\u2502   \u2514\u2500\u2500 Applications\n\u251c\u2500\u2500 Pictures\n\u2502   \u251c\u2500\u2500 photo1.jpg\n\u2502   \u2514\u2500\u2500 photo2.jpg\n\u251c\u2500\u2500 dummy\n\u2502   \u2514\u2500\u2500 Files\n\u251c\u2500\u2500 Chrome.exe\n\u2514\u2500\u2500 file1.doc\n</code></pre> <p>In <code>delete_children=True</code> case, only the node is shifted without its accompanying children/descendants.</p> <pre><code>&gt;&gt;&gt; root = str_to_tree(\n... \"Downloads\\n\"\n... \"\u251c\u2500\u2500 Misc\\n\"\n... \"\u2502   \u2514\u2500\u2500 Applications\\n\"\n... \"\u2502       \u2514\u2500\u2500 Chrome.exe\\n\"\n... \"\u2514\u2500\u2500 Pictures\\n\"\n... \"    \u2514\u2500\u2500 photo1.jpg\"\n... )\n&gt;&gt;&gt; root.show()\nDownloads\n\u251c\u2500\u2500 Misc\n\u2502   \u2514\u2500\u2500 Applications\n\u2502       \u2514\u2500\u2500 Chrome.exe\n\u2514\u2500\u2500 Pictures\n    \u2514\u2500\u2500 photo1.jpg\n</code></pre> <pre><code>&gt;&gt;&gt; shift_nodes(root, [\"Applications\"], [\"Downloads/Applications\"], delete_children=True)\n&gt;&gt;&gt; root.show()\nDownloads\n\u251c\u2500\u2500 Misc\n\u251c\u2500\u2500 Pictures\n\u2502   \u2514\u2500\u2500 photo1.jpg\n\u2514\u2500\u2500 Applications\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>Node</code> <p>tree to modify</p> required <code>from_paths</code> <code>List[str]</code> <p>original paths to shift nodes from</p> required <code>to_paths</code> <code>List[str]</code> <p>new paths to shift nodes to</p> required <code>sep</code> <code>str</code> <p>path separator for input paths, applies to <code>from_path</code> and <code>to_path</code></p> <code>'/'</code> <code>skippable</code> <code>bool</code> <p>indicator to skip if from path is not found, defaults to False</p> <code>False</code> <code>overriding</code> <code>bool</code> <p>indicator to override existing to path if there is clashes, defaults to False</p> <code>False</code> <code>merge_children</code> <code>bool</code> <p>indicator to merge children and remove intermediate parent node, defaults to False</p> <code>False</code> <code>merge_leaves</code> <code>bool</code> <p>indicator to merge leaf nodes and remove intermediate parent node(s), defaults to False</p> <code>False</code> <code>delete_children</code> <code>bool</code> <p>indicator to shift node only without children, defaults to False</p> <code>False</code> <code>with_full_path</code> <code>bool</code> <p>indicator to shift/copy node with full path in <code>from_paths</code>, results in faster search, defaults to False</p> <code>False</code>"},{"location":"bigtree/tree/modify/#bigtree.tree.modify.copy_nodes","title":"copy_nodes","text":"<pre><code>copy_nodes(\n    tree,\n    from_paths,\n    to_paths,\n    sep=\"/\",\n    skippable=False,\n    overriding=False,\n    merge_children=False,\n    merge_leaves=False,\n    delete_children=False,\n    with_full_path=False,\n)\n</code></pre> <p>Copy nodes from <code>from_paths</code> to <code>to_paths</code> in-place.</p> <ul> <li>Creates intermediate nodes if to path is not present</li> <li>Able to skip nodes if from path is not found, defaults to False (from-nodes must be found; not skippable).</li> <li>Able to override existing node if it exists, defaults to False (to-nodes must not exist; not overridden).</li> <li>Able to merge children and remove intermediate parent node, defaults to False (nodes are shifted; not merged).</li> <li>Able to merge only leaf nodes and remove all intermediate nodes, defaults to False (nodes are shifted; not merged)</li> <li>Able to copy node only and delete children, defaults to False (nodes are copied together with children).</li> </ul> <p>For paths in <code>from_paths</code> and <code>to_paths</code>,</p> <ul> <li>Path name can be with or without leading tree path separator symbol.</li> </ul> <p>For paths in <code>from_paths</code>,</p> <ul> <li>Path name can be partial path (trailing part of path) or node name.</li> <li>If <code>with_full_path=True</code>, path name must be full path.</li> <li>Path name must be unique to one node.</li> </ul> <p>For paths in <code>to_paths</code>,</p> <ul> <li>Path name must be full path.</li> </ul> <p>If <code>merge_children=True</code>,</p> <ul> <li>If <code>to_path</code> is not present, it copies children of <code>from_path</code>.</li> <li>If <code>to_path</code> is present, and <code>overriding=False</code>, original and new children are merged.</li> <li>If <code>to_path</code> is present and <code>overriding=True</code>, it behaves like overriding and only new children are retained.</li> </ul> <p>If <code>merge_leaves=True</code>,</p> <ul> <li>If <code>to_path</code> is not present, it copies leaves of <code>from_path</code>.</li> <li>If <code>to_path</code> is present, and <code>overriding=False</code>, original children and leaves are merged.</li> <li>If <code>to_path</code> is present and <code>overriding=True</code>, it behaves like overriding and only new leaves are retained.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import list_to_tree, str_to_tree, copy_nodes\n&gt;&gt;&gt; root = list_to_tree([\"Downloads/Pictures\", \"Downloads/photo1.jpg\", \"Downloads/file1.doc\"])\n&gt;&gt;&gt; root.show()\nDownloads\n\u251c\u2500\u2500 Pictures\n\u251c\u2500\u2500 photo1.jpg\n\u2514\u2500\u2500 file1.doc\n</code></pre> <pre><code>&gt;&gt;&gt; copy_nodes(\n...     tree=root,\n...     from_paths=[\"Downloads/photo1.jpg\", \"Downloads/file1.doc\"],\n...     to_paths=[\"Downloads/Pictures/photo1.jpg\", \"Downloads/Files/file1.doc\"],\n... )\n&gt;&gt;&gt; root.show()\nDownloads\n\u251c\u2500\u2500 Pictures\n\u2502   \u2514\u2500\u2500 photo1.jpg\n\u251c\u2500\u2500 photo1.jpg\n\u251c\u2500\u2500 file1.doc\n\u2514\u2500\u2500 Files\n    \u2514\u2500\u2500 file1.doc\n</code></pre> <p>In overriding case,</p> <pre><code>&gt;&gt;&gt; root = str_to_tree(\n... \"Downloads\\n\"\n... \"\u251c\u2500\u2500 Misc\\n\"\n... \"\u2502   \u2514\u2500\u2500 Pictures\\n\"\n... \"\u2502       \u2514\u2500\u2500 photo1.jpg\\n\"\n... \"\u2514\u2500\u2500 Pictures\\n\"\n... \"    \u2514\u2500\u2500 photo2.jpg\"\n... )\n&gt;&gt;&gt; root.show()\nDownloads\n\u251c\u2500\u2500 Misc\n\u2502   \u2514\u2500\u2500 Pictures\n\u2502       \u2514\u2500\u2500 photo1.jpg\n\u2514\u2500\u2500 Pictures\n    \u2514\u2500\u2500 photo2.jpg\n</code></pre> <pre><code>&gt;&gt;&gt; copy_nodes(root, [\"Downloads/Misc/Pictures\"], [\"Downloads/Pictures\"], overriding=True)\n&gt;&gt;&gt; root.show()\nDownloads\n\u251c\u2500\u2500 Misc\n\u2502   \u2514\u2500\u2500 Pictures\n\u2502       \u2514\u2500\u2500 photo1.jpg\n\u2514\u2500\u2500 Pictures\n    \u2514\u2500\u2500 photo1.jpg\n</code></pre> <p>In <code>merge_children=True</code> case, child nodes are copied instead of the parent node.</p> <ul> <li>If the path already exists, child nodes are merged with existing children.</li> <li>If same node is copied, the child nodes of the node are merged with the node's parent.</li> </ul> <pre><code>&gt;&gt;&gt; root = str_to_tree(\n... \"Downloads\\n\"\n... \"\u251c\u2500\u2500 Misc\\n\"\n... \"\u2502   \u251c\u2500\u2500 Pictures\\n\"\n... \"\u2502   \u2502   \u2514\u2500\u2500 photo2.jpg\\n\"\n... \"\u2502   \u2514\u2500\u2500 Applications\\n\"\n... \"\u2502       \u2514\u2500\u2500 Chrome.exe\\n\"\n... \"\u251c\u2500\u2500 Pictures\\n\"\n... \"\u2502   \u2514\u2500\u2500 photo1.jpg\\n\"\n... \"\u2514\u2500\u2500 dummy\\n\"\n... \"    \u2514\u2500\u2500 Files\\n\"\n... \"        \u2514\u2500\u2500 file1.doc\"\n... )\n&gt;&gt;&gt; root.show()\nDownloads\n\u251c\u2500\u2500 Misc\n\u2502   \u251c\u2500\u2500 Pictures\n\u2502   \u2502   \u2514\u2500\u2500 photo2.jpg\n\u2502   \u2514\u2500\u2500 Applications\n\u2502       \u2514\u2500\u2500 Chrome.exe\n\u251c\u2500\u2500 Pictures\n\u2502   \u2514\u2500\u2500 photo1.jpg\n\u2514\u2500\u2500 dummy\n    \u2514\u2500\u2500 Files\n        \u2514\u2500\u2500 file1.doc\n</code></pre> <pre><code>&gt;&gt;&gt; copy_nodes(\n...     root,\n...     [\"Downloads/Misc/Pictures\", \"Applications\", \"Downloads/dummy\"],\n...     [\"Downloads/Pictures\", \"Downloads/Applications\", \"Downloads/dummy\"],\n...     merge_children=True,\n... )\n&gt;&gt;&gt; root.show()\nDownloads\n\u251c\u2500\u2500 Misc\n\u2502   \u251c\u2500\u2500 Pictures\n\u2502   \u2502   \u2514\u2500\u2500 photo2.jpg\n\u2502   \u2514\u2500\u2500 Applications\n\u2502       \u2514\u2500\u2500 Chrome.exe\n\u251c\u2500\u2500 Pictures\n\u2502   \u251c\u2500\u2500 photo1.jpg\n\u2502   \u2514\u2500\u2500 photo2.jpg\n\u251c\u2500\u2500 Chrome.exe\n\u2514\u2500\u2500 Files\n    \u2514\u2500\u2500 file1.doc\n</code></pre> <p>In <code>merge_leaves=True</code> case, leaf nodes are copied instead of the parent node.</p> <ul> <li>If the path already exists, leaf nodes are merged with existing children.</li> <li>If same node is copied, the leaf nodes of the node are merged with the node's parent.</li> </ul> <pre><code>&gt;&gt;&gt; root = str_to_tree(\n... \"Downloads\\n\"\n... \"\u251c\u2500\u2500 Misc\\n\"\n... \"\u2502   \u251c\u2500\u2500 Pictures\\n\"\n... \"\u2502   \u2502   \u2514\u2500\u2500 photo2.jpg\\n\"\n... \"\u2502   \u2514\u2500\u2500 Applications\\n\"\n... \"\u2502       \u2514\u2500\u2500 Chrome.exe\\n\"\n... \"\u251c\u2500\u2500 Pictures\\n\"\n... \"\u2502   \u2514\u2500\u2500 photo1.jpg\\n\"\n... \"\u2514\u2500\u2500 dummy\\n\"\n... \"    \u2514\u2500\u2500 Files\\n\"\n... \"        \u2514\u2500\u2500 file1.doc\"\n... )\n&gt;&gt;&gt; root.show()\nDownloads\n\u251c\u2500\u2500 Misc\n\u2502   \u251c\u2500\u2500 Pictures\n\u2502   \u2502   \u2514\u2500\u2500 photo2.jpg\n\u2502   \u2514\u2500\u2500 Applications\n\u2502       \u2514\u2500\u2500 Chrome.exe\n\u251c\u2500\u2500 Pictures\n\u2502   \u2514\u2500\u2500 photo1.jpg\n\u2514\u2500\u2500 dummy\n    \u2514\u2500\u2500 Files\n        \u2514\u2500\u2500 file1.doc\n</code></pre> <pre><code>&gt;&gt;&gt; copy_nodes(\n...     root,\n...     [\"Downloads/Misc/Pictures\", \"Applications\", \"Downloads/dummy\"],\n...     [\"Downloads/Pictures\", \"Downloads/Applications\", \"Downloads/dummy\"],\n...     merge_leaves=True,\n... )\n&gt;&gt;&gt; root.show()\nDownloads\n\u251c\u2500\u2500 Misc\n\u2502   \u251c\u2500\u2500 Pictures\n\u2502   \u2502   \u2514\u2500\u2500 photo2.jpg\n\u2502   \u2514\u2500\u2500 Applications\n\u2502       \u2514\u2500\u2500 Chrome.exe\n\u251c\u2500\u2500 Pictures\n\u2502   \u251c\u2500\u2500 photo1.jpg\n\u2502   \u2514\u2500\u2500 photo2.jpg\n\u251c\u2500\u2500 dummy\n\u2502   \u2514\u2500\u2500 Files\n\u2502       \u2514\u2500\u2500 file1.doc\n\u251c\u2500\u2500 Chrome.exe\n\u2514\u2500\u2500 file1.doc\n</code></pre> <p>In <code>delete_children=True</code> case, only the node is copied without its accompanying children/descendants.</p> <pre><code>&gt;&gt;&gt; root = str_to_tree(\n... \"Downloads\\n\"\n... \"\u251c\u2500\u2500 Misc\\n\"\n... \"\u2502   \u2514\u2500\u2500 Applications\\n\"\n... \"\u2502       \u2514\u2500\u2500 Chrome.exe\\n\"\n... \"\u2514\u2500\u2500 Pictures\\n\"\n... \"    \u2514\u2500\u2500 photo1.jpg\"\n... )\n&gt;&gt;&gt; root.show()\nDownloads\n\u251c\u2500\u2500 Misc\n\u2502   \u2514\u2500\u2500 Applications\n\u2502       \u2514\u2500\u2500 Chrome.exe\n\u2514\u2500\u2500 Pictures\n    \u2514\u2500\u2500 photo1.jpg\n</code></pre> <pre><code>&gt;&gt;&gt; copy_nodes(root, [\"Applications\"], [\"Downloads/Applications\"], delete_children=True)\n&gt;&gt;&gt; root.show()\nDownloads\n\u251c\u2500\u2500 Misc\n\u2502   \u2514\u2500\u2500 Applications\n\u2502       \u2514\u2500\u2500 Chrome.exe\n\u251c\u2500\u2500 Pictures\n\u2502   \u2514\u2500\u2500 photo1.jpg\n\u2514\u2500\u2500 Applications\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>Node</code> <p>tree to modify</p> required <code>from_paths</code> <code>List[str]</code> <p>original paths to shift nodes from</p> required <code>to_paths</code> <code>List[str]</code> <p>new paths to shift nodes to</p> required <code>sep</code> <code>str</code> <p>path separator for input paths, applies to <code>from_path</code> and <code>to_path</code></p> <code>'/'</code> <code>skippable</code> <code>bool</code> <p>indicator to skip if from path is not found, defaults to False</p> <code>False</code> <code>overriding</code> <code>bool</code> <p>indicator to override existing to path if there is clashes, defaults to False</p> <code>False</code> <code>merge_children</code> <code>bool</code> <p>indicator to merge children and remove intermediate parent node, defaults to False</p> <code>False</code> <code>merge_leaves</code> <code>bool</code> <p>indicator to merge leaf nodes and remove intermediate parent node(s), defaults to False</p> <code>False</code> <code>delete_children</code> <code>bool</code> <p>indicator to copy node only without children, defaults to False</p> <code>False</code> <code>with_full_path</code> <code>bool</code> <p>indicator to shift/copy node with full path in <code>from_paths</code>, results in faster search, defaults to False</p> <code>False</code>"},{"location":"bigtree/tree/modify/#bigtree.tree.modify.shift_and_replace_nodes","title":"shift_and_replace_nodes","text":"<pre><code>shift_and_replace_nodes(\n    tree,\n    from_paths,\n    to_paths,\n    sep=\"/\",\n    skippable=False,\n    delete_children=False,\n    with_full_path=False,\n)\n</code></pre> <p>Shift nodes from <code>from_paths</code> to replace <code>to_paths</code> in-place.</p> <ul> <li>Creates intermediate nodes if to path is not present</li> <li>Able to skip nodes if from path is not found, defaults to False (from-nodes must be found; not skippable).</li> <li>Able to shift node only and delete children, defaults to False (nodes are shifted together with children).</li> </ul> <p>For paths in <code>from_paths</code> and <code>to_paths</code>,</p> <ul> <li>Path name can be with or without leading tree path separator symbol.</li> </ul> <p>For paths in <code>from_paths</code>,</p> <ul> <li>Path name can be partial path (trailing part of path) or node name.</li> <li>If <code>with_full_path=True</code>, path name must be full path.</li> <li>Path name must be unique to one node.</li> </ul> <p>For paths in <code>to_paths</code>,</p> <ul> <li>Path name must be full path.</li> <li>Path must exist, node-to-be-replaced must be present.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import str_to_tree, shift_and_replace_nodes\n&gt;&gt;&gt; root = str_to_tree(\n... \"Downloads\\n\"\n... \"\u251c\u2500\u2500 Pictures\\n\"\n... \"\u2502   \u2514\u2500\u2500 photo1.jpg\\n\"\n... \"\u2514\u2500\u2500 Misc\\n\"\n... \"    \u2514\u2500\u2500 dummy\"\n... )\n&gt;&gt;&gt; root.show()\nDownloads\n\u251c\u2500\u2500 Pictures\n\u2502   \u2514\u2500\u2500 photo1.jpg\n\u2514\u2500\u2500 Misc\n    \u2514\u2500\u2500 dummy\n</code></pre> <pre><code>&gt;&gt;&gt; shift_and_replace_nodes(root, [\"Downloads/Pictures\"], [\"Downloads/Misc/dummy\"])\n&gt;&gt;&gt; root.show()\nDownloads\n\u2514\u2500\u2500 Misc\n    \u2514\u2500\u2500 Pictures\n        \u2514\u2500\u2500 photo1.jpg\n</code></pre> <p>In <code>delete_children=True</code> case, only the node is shifted without its accompanying children/descendants.</p> <pre><code>&gt;&gt;&gt; root = str_to_tree(\n... \"Downloads\\n\"\n... \"\u251c\u2500\u2500 Pictures\\n\"\n... \"\u2502   \u2514\u2500\u2500 photo1.jpg\\n\"\n... \"\u2514\u2500\u2500 Misc\\n\"\n... \"    \u2514\u2500\u2500 dummy\"\n... )\n&gt;&gt;&gt; root.show()\nDownloads\n\u251c\u2500\u2500 Pictures\n\u2502   \u2514\u2500\u2500 photo1.jpg\n\u2514\u2500\u2500 Misc\n    \u2514\u2500\u2500 dummy\n</code></pre> <pre><code>&gt;&gt;&gt; shift_and_replace_nodes(root, [\"Downloads/Pictures\"], [\"Downloads/Misc/dummy\"], delete_children=True)\n&gt;&gt;&gt; root.show()\nDownloads\n\u2514\u2500\u2500 Misc\n    \u2514\u2500\u2500 Pictures\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>Node</code> <p>tree to modify</p> required <code>from_paths</code> <code>List[str]</code> <p>original paths to shift nodes from</p> required <code>to_paths</code> <code>List[str]</code> <p>new paths to shift nodes to</p> required <code>sep</code> <code>str</code> <p>path separator for input paths, applies to <code>from_path</code> and <code>to_path</code></p> <code>'/'</code> <code>skippable</code> <code>bool</code> <p>indicator to skip if from path is not found, defaults to False</p> <code>False</code> <code>delete_children</code> <code>bool</code> <p>indicator to shift node only without children, defaults to False</p> <code>False</code> <code>with_full_path</code> <code>bool</code> <p>indicator to shift/copy node with full path in <code>from_paths</code>, results in faster search, defaults to False</p> <code>False</code>"},{"location":"bigtree/tree/modify/#bigtree.tree.modify.copy_nodes_from_tree_to_tree","title":"copy_nodes_from_tree_to_tree","text":"<pre><code>copy_nodes_from_tree_to_tree(\n    from_tree,\n    to_tree,\n    from_paths,\n    to_paths,\n    sep=\"/\",\n    skippable=False,\n    overriding=False,\n    merge_children=False,\n    merge_leaves=False,\n    delete_children=False,\n    with_full_path=False,\n)\n</code></pre> <p>Copy nodes from <code>from_paths</code> to <code>to_paths</code> in-place.</p> <ul> <li>Creates intermediate nodes if to path is not present</li> <li>Able to skip nodes if from path is not found, defaults to False (from-nodes must be found; not skippable).</li> <li>Able to override existing node if it exists, defaults to False (to-nodes must not exist; not overridden).</li> <li>Able to merge children and remove intermediate parent node, defaults to False (nodes are shifted; not merged).</li> <li>Able to merge only leaf nodes and remove all intermediate nodes, defaults to False (nodes are shifted; not merged)</li> <li>Able to copy node only and delete children, defaults to False (nodes are copied together with children).</li> </ul> <p>For paths in <code>from_paths</code> and <code>to_paths</code>,</p> <ul> <li>Path name can be with or without leading tree path separator symbol.</li> </ul> <p>For paths in <code>from_paths</code>,</p> <ul> <li>Path name can be partial path (trailing part of path) or node name.</li> <li>If <code>with_full_path=True</code>, path name must be full path.</li> <li>Path name must be unique to one node.</li> </ul> <p>For paths in <code>to_paths</code>,</p> <ul> <li>Path name must be full path.</li> </ul> <p>If <code>merge_children=True</code>,</p> <ul> <li>If <code>to_path</code> is not present, it copies children of <code>from_path</code></li> <li>If <code>to_path</code> is present, and <code>overriding=False</code>, original and new children are merged</li> <li>If <code>to_path</code> is present and <code>overriding=True</code>, it behaves like overriding and only new leaves are retained.</li> </ul> <p>If <code>merge_leaves=True</code>,</p> <ul> <li>If <code>to_path</code> is not present, it copies leaves of <code>from_path</code>.</li> <li>If <code>to_path</code> is present, and <code>overriding=False</code>, original children and leaves are merged.</li> <li>If <code>to_path</code> is present and <code>overriding=True</code>, it behaves like overriding and only new leaves are retained.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, str_to_tree, copy_nodes_from_tree_to_tree\n&gt;&gt;&gt; root = str_to_tree(\n... \"Downloads\\n\"\n... \"\u251c\u2500\u2500 file1.doc\\n\"\n... \"\u251c\u2500\u2500 Pictures\\n\"\n... \"\u2502   \u2514\u2500\u2500 photo1.jpg\\n\"\n... \"\u2514\u2500\u2500 Misc\\n\"\n... \"    \u2514\u2500\u2500 dummy\\n\"\n... \"        \u2514\u2500\u2500 photo2.jpg\"\n... )\n&gt;&gt;&gt; root.show()\nDownloads\n\u251c\u2500\u2500 file1.doc\n\u251c\u2500\u2500 Pictures\n\u2502   \u2514\u2500\u2500 photo1.jpg\n\u2514\u2500\u2500 Misc\n    \u2514\u2500\u2500 dummy\n        \u2514\u2500\u2500 photo2.jpg\n</code></pre> <pre><code>&gt;&gt;&gt; root_other = Node(\"Documents\")\n&gt;&gt;&gt; copy_nodes_from_tree_to_tree(\n...     from_tree=root,\n...     to_tree=root_other,\n...     from_paths=[\"Downloads/Pictures\", \"Downloads/Misc\"],\n...     to_paths=[\"Documents/Pictures\", \"Documents/New Misc/Misc\"],\n... )\n&gt;&gt;&gt; root_other.show()\nDocuments\n\u251c\u2500\u2500 Pictures\n\u2502   \u2514\u2500\u2500 photo1.jpg\n\u2514\u2500\u2500 New Misc\n    \u2514\u2500\u2500 Misc\n        \u2514\u2500\u2500 dummy\n            \u2514\u2500\u2500 photo2.jpg\n</code></pre> <p>In overriding case,</p> <pre><code>&gt;&gt;&gt; root_other = str_to_tree(\n... \"Documents\\n\"\n... \"\u2514\u2500\u2500 Pictures\\n\"\n... \"    \u2514\u2500\u2500 photo3.jpg\"\n... )\n&gt;&gt;&gt; root_other.show()\nDocuments\n\u2514\u2500\u2500 Pictures\n    \u2514\u2500\u2500 photo3.jpg\n</code></pre> <pre><code>&gt;&gt;&gt; copy_nodes_from_tree_to_tree(\n...     root,\n...     root_other,\n...     [\"Downloads/Pictures\", \"Downloads/Misc\"],\n...     [\"Documents/Pictures\", \"Documents/Misc\"],\n...     overriding=True,\n... )\n&gt;&gt;&gt; root_other.show()\nDocuments\n\u251c\u2500\u2500 Pictures\n\u2502   \u2514\u2500\u2500 photo1.jpg\n\u2514\u2500\u2500 Misc\n    \u2514\u2500\u2500 dummy\n        \u2514\u2500\u2500 photo2.jpg\n</code></pre> <p>In <code>merge_children=True</code> case, child nodes are copied instead of the parent node.</p> <ul> <li>If the path already exists, child nodes are merged with existing children.</li> </ul> <pre><code>&gt;&gt;&gt; root_other = str_to_tree(\n... \"Documents\\n\"\n... \"\u2514\u2500\u2500 Pictures\\n\"\n... \"    \u2514\u2500\u2500 photo3.jpg\"\n... )\n&gt;&gt;&gt; root_other.show()\nDocuments\n\u2514\u2500\u2500 Pictures\n    \u2514\u2500\u2500 photo3.jpg\n</code></pre> <pre><code>&gt;&gt;&gt; copy_nodes_from_tree_to_tree(\n...     root,\n...     root_other,\n...     [\"Downloads/Pictures\", \"Downloads/Misc\"],\n...     [\"Documents/Pictures\", \"Documents/Misc\"],\n...     merge_children=True,\n... )\n&gt;&gt;&gt; root_other.show()\nDocuments\n\u251c\u2500\u2500 Pictures\n\u2502   \u251c\u2500\u2500 photo3.jpg\n\u2502   \u2514\u2500\u2500 photo1.jpg\n\u2514\u2500\u2500 dummy\n    \u2514\u2500\u2500 photo2.jpg\n</code></pre> <p>In <code>merge_leaves=True</code> case, leaf nodes are copied instead of the parent node.</p> <ul> <li>If the path already exists, leaf nodes are merged with existing children.</li> </ul> <pre><code>&gt;&gt;&gt; root_other = str_to_tree(\n... \"Documents\\n\"\n... \"\u2514\u2500\u2500 Pictures\\n\"\n... \"    \u2514\u2500\u2500 photo3.jpg\"\n... )\n&gt;&gt;&gt; root_other.show()\nDocuments\n\u2514\u2500\u2500 Pictures\n    \u2514\u2500\u2500 photo3.jpg\n</code></pre> <pre><code>&gt;&gt;&gt; copy_nodes_from_tree_to_tree(\n...     root,\n...     root_other,\n...     [\"Downloads/Pictures\", \"Downloads/Misc\"],\n...     [\"Documents/Pictures\", \"Documents/Misc\"],\n...     merge_leaves=True,\n... )\n&gt;&gt;&gt; root_other.show()\nDocuments\n\u251c\u2500\u2500 Pictures\n\u2502   \u251c\u2500\u2500 photo3.jpg\n\u2502   \u2514\u2500\u2500 photo1.jpg\n\u2514\u2500\u2500 photo2.jpg\n</code></pre> <p>In <code>delete_children=True</code> case, only the node is copied without its accompanying children/descendants.</p> <pre><code>&gt;&gt;&gt; root_other = Node(\"Documents\")\n&gt;&gt;&gt; root_other.show()\nDocuments\n</code></pre> <pre><code>&gt;&gt;&gt; copy_nodes_from_tree_to_tree(\n...     root,\n...     root_other,\n...     [\"Downloads/Pictures\", \"Downloads/Misc\"],\n...     [\"Documents/Pictures\", \"Documents/Misc\"],\n...     delete_children=True,\n... )\n&gt;&gt;&gt; root_other.show()\nDocuments\n\u251c\u2500\u2500 Pictures\n\u2514\u2500\u2500 Misc\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>from_tree</code> <code>Node</code> <p>tree to copy nodes from</p> required <code>to_tree</code> <code>Node</code> <p>tree to copy nodes to</p> required <code>from_paths</code> <code>List[str]</code> <p>original paths to shift nodes from</p> required <code>to_paths</code> <code>List[str]</code> <p>new paths to shift nodes to</p> required <code>sep</code> <code>str</code> <p>path separator for input paths, applies to <code>from_path</code> and <code>to_path</code></p> <code>'/'</code> <code>skippable</code> <code>bool</code> <p>indicator to skip if from path is not found, defaults to False</p> <code>False</code> <code>overriding</code> <code>bool</code> <p>indicator to override existing to path if there is clashes, defaults to False</p> <code>False</code> <code>merge_children</code> <code>bool</code> <p>indicator to merge children and remove intermediate parent node, defaults to False</p> <code>False</code> <code>merge_leaves</code> <code>bool</code> <p>indicator to merge leaf nodes and remove intermediate parent node(s), defaults to False</p> <code>False</code> <code>delete_children</code> <code>bool</code> <p>indicator to copy node only without children, defaults to False</p> <code>False</code> <code>with_full_path</code> <code>bool</code> <p>indicator to shift/copy node with full path in <code>from_paths</code>, results in faster search, defaults to False</p> <code>False</code>"},{"location":"bigtree/tree/modify/#bigtree.tree.modify.copy_and_replace_nodes_from_tree_to_tree","title":"copy_and_replace_nodes_from_tree_to_tree","text":"<pre><code>copy_and_replace_nodes_from_tree_to_tree(\n    from_tree,\n    to_tree,\n    from_paths,\n    to_paths,\n    sep=\"/\",\n    skippable=False,\n    delete_children=False,\n    with_full_path=False,\n)\n</code></pre> <p>Copy nodes from <code>from_paths</code> to replace <code>to_paths</code> in-place.</p> <ul> <li>Creates intermediate nodes if to path is not present</li> <li>Able to skip nodes if from path is not found, defaults to False (from-nodes must be found; not skippable).</li> <li>Able to copy node only and delete children, defaults to False (nodes are copied together with children).</li> </ul> <p>For paths in <code>from_paths</code> and <code>to_paths</code>,</p> <ul> <li>Path name can be with or without leading tree path separator symbol.</li> </ul> <p>For paths in <code>from_paths</code>,</p> <ul> <li>Path name can be partial path (trailing part of path) or node name.</li> <li>If <code>with_full_path=True</code>, path name must be full path.</li> <li>Path name must be unique to one node.</li> </ul> <p>For paths in <code>to_paths</code>,</p> <ul> <li>Path name must be full path.</li> <li>Path must exist, node-to-be-replaced must be present.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import str_to_tree, copy_and_replace_nodes_from_tree_to_tree\n&gt;&gt;&gt; root = str_to_tree(\n... \"Downloads\\n\"\n... \"\u251c\u2500\u2500 file1.doc\\n\"\n... \"\u251c\u2500\u2500 Pictures\\n\"\n... \"\u2502   \u2514\u2500\u2500 photo1.jpg\\n\"\n... \"\u2514\u2500\u2500 Misc\\n\"\n... \"    \u2514\u2500\u2500 dummy\\n\"\n... \"        \u2514\u2500\u2500 photo2.jpg\"\n... )\n&gt;&gt;&gt; root.show()\nDownloads\n\u251c\u2500\u2500 file1.doc\n\u251c\u2500\u2500 Pictures\n\u2502   \u2514\u2500\u2500 photo1.jpg\n\u2514\u2500\u2500 Misc\n    \u2514\u2500\u2500 dummy\n        \u2514\u2500\u2500 photo2.jpg\n</code></pre> <pre><code>&gt;&gt;&gt; root_other = str_to_tree(\n... \"Documents\\n\"\n... \"\u251c\u2500\u2500 Pictures2\\n\"\n... \"\u2502   \u2514\u2500\u2500 photo2.jpg\\n\"\n... \"\u2514\u2500\u2500 Misc2\"\n... )\n&gt;&gt;&gt; root_other.show()\nDocuments\n\u251c\u2500\u2500 Pictures2\n\u2502   \u2514\u2500\u2500 photo2.jpg\n\u2514\u2500\u2500 Misc2\n</code></pre> <pre><code>&gt;&gt;&gt; copy_and_replace_nodes_from_tree_to_tree(\n...     from_tree=root,\n...     to_tree=root_other,\n...     from_paths=[\"Downloads/Pictures\", \"Downloads/Misc\"],\n...     to_paths=[\"Documents/Pictures2/photo2.jpg\", \"Documents/Misc2\"],\n... )\n&gt;&gt;&gt; root_other.show()\nDocuments\n\u251c\u2500\u2500 Pictures2\n\u2502   \u2514\u2500\u2500 Pictures\n\u2502       \u2514\u2500\u2500 photo1.jpg\n\u2514\u2500\u2500 Misc\n    \u2514\u2500\u2500 dummy\n        \u2514\u2500\u2500 photo2.jpg\n</code></pre> <p>In <code>delete_children=True</code> case, only the node is copied without its accompanying children/descendants.</p> <pre><code>&gt;&gt;&gt; root_other = str_to_tree(\n... \"Documents\\n\"\n... \"\u251c\u2500\u2500 Pictures2\\n\"\n... \"\u2502   \u2514\u2500\u2500 photo2.jpg\\n\"\n... \"\u2514\u2500\u2500 Misc2\"\n... )\n&gt;&gt;&gt; root_other.show()\nDocuments\n\u251c\u2500\u2500 Pictures2\n\u2502   \u2514\u2500\u2500 photo2.jpg\n\u2514\u2500\u2500 Misc2\n</code></pre> <pre><code>&gt;&gt;&gt; copy_and_replace_nodes_from_tree_to_tree(\n...     from_tree=root,\n...     to_tree=root_other,\n...     from_paths=[\"Downloads/Pictures\", \"Downloads/Misc\"],\n...     to_paths=[\"Documents/Pictures2/photo2.jpg\", \"Documents/Misc2\"],\n...     delete_children=True,\n... )\n&gt;&gt;&gt; root_other.show()\nDocuments\n\u251c\u2500\u2500 Pictures2\n\u2502   \u2514\u2500\u2500 Pictures\n\u2514\u2500\u2500 Misc\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>from_tree</code> <code>Node</code> <p>tree to copy nodes from</p> required <code>to_tree</code> <code>Node</code> <p>tree to copy nodes to</p> required <code>from_paths</code> <code>List[str]</code> <p>original paths to shift nodes from</p> required <code>to_paths</code> <code>List[str]</code> <p>new paths to shift nodes to</p> required <code>sep</code> <code>str</code> <p>path separator for input paths, applies to <code>from_path</code> and <code>to_path</code></p> <code>'/'</code> <code>skippable</code> <code>bool</code> <p>indicator to skip if from path is not found, defaults to False</p> <code>False</code> <code>delete_children</code> <code>bool</code> <p>indicator to copy node only without children, defaults to False</p> <code>False</code> <code>with_full_path</code> <code>bool</code> <p>indicator to shift/copy node with full path in <code>from_paths</code>, results in faster search, defaults to False</p> <code>False</code>"},{"location":"bigtree/tree/modify/#bigtree.tree.modify.copy_or_shift_logic","title":"copy_or_shift_logic","text":"<pre><code>copy_or_shift_logic(\n    tree,\n    from_paths,\n    to_paths,\n    sep=\"/\",\n    copy=False,\n    skippable=False,\n    overriding=False,\n    merge_children=False,\n    merge_leaves=False,\n    delete_children=False,\n    to_tree=None,\n    with_full_path=False,\n)\n</code></pre> <p>Shift or copy nodes from <code>from_paths</code> to <code>to_paths</code> in-place.</p> <ul> <li>Creates intermediate nodes if to path is not present</li> <li>Able to copy node, defaults to False (nodes are shifted; not copied).</li> <li>Able to skip nodes if from path is not found, defaults to False (from-nodes must be found; not skippable)</li> <li>Able to override existing node if it exists, defaults to False (to-nodes must not exist; not overridden)</li> <li>Able to merge children and remove intermediate parent node, defaults to False (nodes are shifted; not merged)</li> <li>Able to merge only leaf nodes and remove all intermediate nodes, defaults to False (nodes are shifted; not merged)</li> <li>Able to shift/copy node only and delete children, defaults to False (nodes are shifted/copied together with children).</li> <li>Able to shift/copy nodes from one tree to another tree, defaults to None (shifting/copying happens within same tree)</li> </ul> <p>For paths in <code>from_paths</code> and <code>to_paths</code>,</p> <ul> <li>Path name can be with or without leading tree path separator symbol.</li> </ul> <p>For paths in <code>from_paths</code>,</p> <ul> <li>Path name can be partial path (trailing part of path) or node name.</li> <li>If <code>with_full_path=True</code>, path name must be full path.</li> <li>Path name must be unique to one node.</li> </ul> <p>For paths in <code>to_paths</code>,</p> <ul> <li>Path name must be full path.</li> <li>Can set to empty string or None to delete the path in <code>from_paths</code>, note that <code>copy</code> must be set to False.</li> </ul> <p>If <code>merge_children=True</code>,</p> <ul> <li>If <code>to_path</code> is not present, it shifts/copies children of <code>from_path</code>.</li> <li>If <code>to_path</code> is present, and <code>overriding=False</code>, original and new children are merged.</li> <li>If <code>to_path</code> is present and <code>overriding=True</code>, it behaves like overriding and only new children are retained.</li> </ul> <p>If <code>merge_leaves=True</code>,</p> <ul> <li>If <code>to_path</code> is not present, it shifts/copies leaves of <code>from_path</code>.</li> <li>If <code>to_path</code> is present, and <code>overriding=False</code>, original children and leaves are merged.</li> <li>If <code>to_path</code> is present and <code>overriding=True</code>, it behaves like overriding and only new leaves are retained,     original non-leaf nodes in <code>from_path</code> are retained.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>Node</code> <p>tree to modify</p> required <code>from_paths</code> <code>List[str]</code> <p>original paths to shift nodes from</p> required <code>to_paths</code> <code>List[str]</code> <p>new paths to shift nodes to</p> required <code>sep</code> <code>str</code> <p>path separator for input paths, applies to <code>from_path</code> and <code>to_path</code></p> <code>'/'</code> <code>copy</code> <code>bool</code> <p>indicator to copy node, defaults to False</p> <code>False</code> <code>skippable</code> <code>bool</code> <p>indicator to skip if from path is not found, defaults to False</p> <code>False</code> <code>overriding</code> <code>bool</code> <p>indicator to override existing to path if there is clashes, defaults to False</p> <code>False</code> <code>merge_children</code> <code>bool</code> <p>indicator to merge children and remove intermediate parent node, defaults to False</p> <code>False</code> <code>merge_leaves</code> <code>bool</code> <p>indicator to merge leaf nodes and remove intermediate parent node(s), defaults to False</p> <code>False</code> <code>delete_children</code> <code>bool</code> <p>indicator to shift/copy node only without children, defaults to False</p> <code>False</code> <code>to_tree</code> <code>Node</code> <p>tree to copy to, defaults to None</p> <code>None</code> <code>with_full_path</code> <code>bool</code> <p>indicator to shift/copy node with full path in <code>from_paths</code>, results in faster search, defaults to False</p> <code>False</code>"},{"location":"bigtree/tree/modify/#bigtree.tree.modify.replace_logic","title":"replace_logic","text":"<pre><code>replace_logic(\n    tree,\n    from_paths,\n    to_paths,\n    sep=\"/\",\n    copy=False,\n    skippable=False,\n    delete_children=False,\n    to_tree=None,\n    with_full_path=False,\n)\n</code></pre> <p>Shift or copy nodes from <code>from_paths</code> to replace <code>to_paths</code> in-place.</p> <ul> <li>Creates intermediate nodes if to path is not present</li> <li>Able to copy node, defaults to False (nodes are shifted; not copied).</li> <li>Able to skip nodes if from path is not found, defaults to False (from-nodes must be found; not skippable)</li> <li>Able to replace node only and delete children, defaults to False (nodes are shifted/copied together with children).</li> <li>Able to shift/copy nodes from one tree to another tree, defaults to None (shifting/copying happens within same tree)</li> </ul> <p>For paths in <code>from_paths</code> and <code>to_paths</code>,</p> <ul> <li>Path name can be with or without leading tree path separator symbol.</li> </ul> <p>For paths in <code>from_paths</code>,</p> <ul> <li>Path name can be partial path (trailing part of path) or node name.</li> <li>If <code>with_full_path=True</code>, path name must be full path.</li> <li>Path name must be unique to one node.</li> </ul> <p>For paths in <code>to_paths</code>,</p> <ul> <li>Path name must be full path.</li> <li>Path must exist, node-to-be-replaced must be present.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>Node</code> <p>tree to modify</p> required <code>from_paths</code> <code>List[str]</code> <p>original paths to shift nodes from</p> required <code>to_paths</code> <code>List[str]</code> <p>new paths to shift nodes to</p> required <code>sep</code> <code>str</code> <p>path separator for input paths, applies to <code>from_path</code> and <code>to_path</code></p> <code>'/'</code> <code>copy</code> <code>bool</code> <p>indicator to copy node, defaults to False</p> <code>False</code> <code>skippable</code> <code>bool</code> <p>indicator to skip if from path is not found, defaults to False</p> <code>False</code> <code>delete_children</code> <code>bool</code> <p>indicator to shift/copy node only without children, defaults to False</p> <code>False</code> <code>to_tree</code> <code>Node</code> <p>tree to copy to, defaults to None</p> <code>None</code> <code>with_full_path</code> <code>bool</code> <p>indicator to shift/copy node with full path in <code>from_paths</code>, results in faster search, defaults to False</p> <code>False</code>"},{"location":"bigtree/tree/search/","title":"\ud83d\udd0d Search","text":"<p>Search methods for Trees.</p> Search by One node One or more nodes General method <code>find</code>, <code>find_child</code> <code>findall</code>, <code>find_children</code> Node name <code>find_name</code>, <code>find_child_by_name</code> <code>find_names</code> Node path <code>find_path</code>, <code>find_full_path</code>, <code>find_relative_path</code> <code>find_paths</code>, <code>find_relative_path</code> Node attributes <code>find_attr</code> <code>find_attrs</code>"},{"location":"bigtree/tree/search/#bigtree.tree.search","title":"bigtree.tree.search","text":""},{"location":"bigtree/tree/search/#bigtree.tree.search.findall","title":"findall","text":"<pre><code>findall(\n    tree, condition, max_depth=0, min_count=0, max_count=0\n)\n</code></pre> <p>Search tree for nodes matching condition (callable function).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, findall\n&gt;&gt;&gt; root = Node(\"a\", age=90)\n&gt;&gt;&gt; b = Node(\"b\", age=65, parent=root)\n&gt;&gt;&gt; c = Node(\"c\", age=60, parent=root)\n&gt;&gt;&gt; d = Node(\"d\", age=40, parent=c)\n&gt;&gt;&gt; findall(root, lambda node: node.age &gt; 62)\n(Node(/a, age=90), Node(/a/b, age=65))\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>BaseNode</code> <p>tree to search</p> required <code>condition</code> <code>Callable</code> <p>function that takes in node as argument, returns node if condition evaluates to <code>True</code></p> required <code>max_depth</code> <code>int</code> <p>maximum depth to search for, based on the <code>depth</code> attribute, defaults to None</p> <code>0</code> <code>min_count</code> <code>int</code> <p>checks for minimum number of occurrences, raise SearchError if the number of results do not meet min_count, defaults to None</p> <code>0</code> <code>max_count</code> <code>int</code> <p>checks for maximum number of occurrences, raise SearchError if the number of results do not meet min_count, defaults to None</p> <code>0</code> <p>Returns:</p> Type Description <code>Tuple[T, ...]</code> <p>(Tuple[BaseNode, ...])</p>"},{"location":"bigtree/tree/search/#bigtree.tree.search.find","title":"find","text":"<pre><code>find(tree, condition, max_depth=0)\n</code></pre> <p>Search tree for single node matching condition (callable function).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, find\n&gt;&gt;&gt; root = Node(\"a\", age=90)\n&gt;&gt;&gt; b = Node(\"b\", age=65, parent=root)\n&gt;&gt;&gt; c = Node(\"c\", age=60, parent=root)\n&gt;&gt;&gt; d = Node(\"d\", age=40, parent=c)\n&gt;&gt;&gt; find(root, lambda node: node.age == 65)\nNode(/a/b, age=65)\n&gt;&gt;&gt; find(root, lambda node: node.age &gt; 5)\nTraceback (most recent call last):\n    ...\nbigtree.utils.exceptions.SearchError: Expected less than 1 element(s), found 4 elements\n(Node(/a, age=90), Node(/a/b, age=65), Node(/a/c, age=60), Node(/a/c/d, age=40))\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>BaseNode</code> <p>tree to search</p> required <code>condition</code> <code>Callable</code> <p>function that takes in node as argument, returns node if condition evaluates to <code>True</code></p> required <code>max_depth</code> <code>int</code> <p>maximum depth to search for, based on the <code>depth</code> attribute, defaults to None</p> <code>0</code> <p>Returns:</p> Type Description <code>T</code> <p>(BaseNode)</p>"},{"location":"bigtree/tree/search/#bigtree.tree.search.find_name","title":"find_name","text":"<pre><code>find_name(tree, name, max_depth=0)\n</code></pre> <p>Search tree for single node matching name attribute.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, find_name\n&gt;&gt;&gt; root = Node(\"a\", age=90)\n&gt;&gt;&gt; b = Node(\"b\", age=65, parent=root)\n&gt;&gt;&gt; c = Node(\"c\", age=60, parent=root)\n&gt;&gt;&gt; d = Node(\"d\", age=40, parent=c)\n&gt;&gt;&gt; find_name(root, \"c\")\nNode(/a/c, age=60)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>Node</code> <p>tree to search</p> required <code>name</code> <code>str</code> <p>value to match for name attribute</p> required <code>max_depth</code> <code>int</code> <p>maximum depth to search for, based on the <code>depth</code> attribute, defaults to None</p> <code>0</code> <p>Returns:</p> Type Description <code>NodeT</code> <p>(Node)</p>"},{"location":"bigtree/tree/search/#bigtree.tree.search.find_names","title":"find_names","text":"<pre><code>find_names(tree, name, max_depth=0)\n</code></pre> <p>Search tree for multiple node(s) matching name attribute.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, find_names\n&gt;&gt;&gt; root = Node(\"a\", age=90)\n&gt;&gt;&gt; b = Node(\"b\", age=65, parent=root)\n&gt;&gt;&gt; c = Node(\"c\", age=60, parent=root)\n&gt;&gt;&gt; d = Node(\"b\", age=40, parent=c)\n&gt;&gt;&gt; find_names(root, \"c\")\n(Node(/a/c, age=60),)\n&gt;&gt;&gt; find_names(root, \"b\")\n(Node(/a/b, age=65), Node(/a/c/b, age=40))\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>Node</code> <p>tree to search</p> required <code>name</code> <code>str</code> <p>value to match for name attribute</p> required <code>max_depth</code> <code>int</code> <p>maximum depth to search for, based on the <code>depth</code> attribute, defaults to None</p> <code>0</code> <p>Returns:</p> Type Description <code>Iterable[NodeT]</code> <p>(Iterable[Node])</p>"},{"location":"bigtree/tree/search/#bigtree.tree.search.find_relative_path","title":"find_relative_path","text":"<pre><code>find_relative_path(tree, path_name)\n</code></pre> <p>Search tree for single node matching relative path attribute.</p> <ul> <li>Supports unix folder expression for relative path, i.e., '../../node_name'</li> <li>Supports wildcards, i.e., '*/node_name'</li> <li>If path name starts with leading separator symbol, it will start at root node.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, find_relative_path\n&gt;&gt;&gt; root = Node(\"a\", age=90)\n&gt;&gt;&gt; b = Node(\"b\", age=65, parent=root)\n&gt;&gt;&gt; c = Node(\"c\", age=60, parent=root)\n&gt;&gt;&gt; d = Node(\"d\", age=40, parent=c)\n&gt;&gt;&gt; find_relative_path(d, \"..\")\n(Node(/a/c, age=60),)\n&gt;&gt;&gt; find_relative_path(d, \"../../b\")\n(Node(/a/b, age=65),)\n&gt;&gt;&gt; find_relative_path(d, \"../../*\")\n(Node(/a/b, age=65), Node(/a/c, age=60))\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>Node</code> <p>tree to search</p> required <code>path_name</code> <code>str</code> <p>value to match (relative path) of path_name attribute</p> required <p>Returns:</p> Type Description <code>Iterable[NodeT]</code> <p>(Iterable[Node])</p>"},{"location":"bigtree/tree/search/#bigtree.tree.search.find_full_path","title":"find_full_path","text":"<pre><code>find_full_path(tree, path_name)\n</code></pre> <p>Search tree for single node matching path attribute.</p> <ul> <li>Path name can be with or without leading tree path separator symbol.</li> <li>Path name must be full path, works similar to <code>find_path</code> but faster.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, find_full_path\n&gt;&gt;&gt; root = Node(\"a\", age=90)\n&gt;&gt;&gt; b = Node(\"b\", age=65, parent=root)\n&gt;&gt;&gt; c = Node(\"c\", age=60, parent=root)\n&gt;&gt;&gt; d = Node(\"d\", age=40, parent=c)\n&gt;&gt;&gt; find_full_path(root, \"/a/c/d\")\nNode(/a/c/d, age=40)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>Node</code> <p>tree to search</p> required <code>path_name</code> <code>str</code> <p>value to match (full path) of path_name attribute</p> required <p>Returns:</p> Type Description <code>NodeT</code> <p>(Node)</p>"},{"location":"bigtree/tree/search/#bigtree.tree.search.find_path","title":"find_path","text":"<pre><code>find_path(tree, path_name)\n</code></pre> <p>Search tree for single node matching path attribute.</p> <ul> <li>Path name can be with or without leading tree path separator symbol.</li> <li>Path name can be full path or partial path (trailing part of path) or node name.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, find_path\n&gt;&gt;&gt; root = Node(\"a\", age=90)\n&gt;&gt;&gt; b = Node(\"b\", age=65, parent=root)\n&gt;&gt;&gt; c = Node(\"c\", age=60, parent=root)\n&gt;&gt;&gt; d = Node(\"d\", age=40, parent=c)\n&gt;&gt;&gt; find_path(root, \"c\")\nNode(/a/c, age=60)\n&gt;&gt;&gt; find_path(root, \"/c\")\nNode(/a/c, age=60)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>Node</code> <p>tree to search</p> required <code>path_name</code> <code>str</code> <p>value to match (full path) or trailing part (partial path) of path_name attribute</p> required <p>Returns:</p> Type Description <code>NodeT</code> <p>(Node)</p>"},{"location":"bigtree/tree/search/#bigtree.tree.search.find_paths","title":"find_paths","text":"<pre><code>find_paths(tree, path_name)\n</code></pre> <p>Search tree for multiple nodes matching path attribute.</p> <ul> <li>Path name can be with or without leading tree path separator symbol.</li> <li>Path name can be partial path (trailing part of path) or node name.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, find_paths\n&gt;&gt;&gt; root = Node(\"a\", age=90)\n&gt;&gt;&gt; b = Node(\"b\", age=65, parent=root)\n&gt;&gt;&gt; c = Node(\"c\", age=60, parent=root)\n&gt;&gt;&gt; d = Node(\"c\", age=40, parent=c)\n&gt;&gt;&gt; find_paths(root, \"/a/c\")\n(Node(/a/c, age=60),)\n&gt;&gt;&gt; find_paths(root, \"/c\")\n(Node(/a/c, age=60), Node(/a/c/c, age=40))\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>Node</code> <p>tree to search</p> required <code>path_name</code> <code>str</code> <p>value to match (full path) or trailing part (partial path) of path_name attribute</p> required <p>Returns:</p> Type Description <code>Tuple[NodeT, ...]</code> <p>(Tuple[Node, ...])</p>"},{"location":"bigtree/tree/search/#bigtree.tree.search.find_attr","title":"find_attr","text":"<pre><code>find_attr(tree, attr_name, attr_value, max_depth=0)\n</code></pre> <p>Search tree for single node matching custom attribute.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, find_attr\n&gt;&gt;&gt; root = Node(\"a\", age=90)\n&gt;&gt;&gt; b = Node(\"b\", age=65, parent=root)\n&gt;&gt;&gt; c = Node(\"c\", age=60, parent=root)\n&gt;&gt;&gt; d = Node(\"d\", age=40, parent=c)\n&gt;&gt;&gt; find_attr(root, \"age\", 65)\nNode(/a/b, age=65)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>BaseNode</code> <p>tree to search</p> required <code>attr_name</code> <code>str</code> <p>attribute name to perform matching</p> required <code>attr_value</code> <code>Any</code> <p>value to match for attr_name attribute</p> required <code>max_depth</code> <code>int</code> <p>maximum depth to search for, based on the <code>depth</code> attribute, defaults to None</p> <code>0</code> <p>Returns:</p> Type Description <code>BaseNode</code> <p>(BaseNode)</p>"},{"location":"bigtree/tree/search/#bigtree.tree.search.find_attrs","title":"find_attrs","text":"<pre><code>find_attrs(tree, attr_name, attr_value, max_depth=0)\n</code></pre> <p>Search tree for node(s) matching custom attribute.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, find_attrs\n&gt;&gt;&gt; root = Node(\"a\", age=90)\n&gt;&gt;&gt; b = Node(\"b\", age=65, parent=root)\n&gt;&gt;&gt; c = Node(\"c\", age=65, parent=root)\n&gt;&gt;&gt; d = Node(\"d\", age=40, parent=c)\n&gt;&gt;&gt; find_attrs(root, \"age\", 65)\n(Node(/a/b, age=65), Node(/a/c, age=65))\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>BaseNode</code> <p>tree to search</p> required <code>attr_name</code> <code>str</code> <p>attribute name to perform matching</p> required <code>attr_value</code> <code>Any</code> <p>value to match for attr_name attribute</p> required <code>max_depth</code> <code>int</code> <p>maximum depth to search for, based on the <code>depth</code> attribute, defaults to None</p> <code>0</code> <p>Returns:</p> Type Description <code>Tuple[BaseNode, ...]</code> <p>(Tuple[BaseNode, ...])</p>"},{"location":"bigtree/tree/search/#bigtree.tree.search.find_children","title":"find_children","text":"<pre><code>find_children(tree, condition, min_count=0, max_count=0)\n</code></pre> <p>Search children for nodes matching condition (callable function).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, find_children\n&gt;&gt;&gt; root = Node(\"a\", age=90)\n&gt;&gt;&gt; b = Node(\"b\", age=65, parent=root)\n&gt;&gt;&gt; c = Node(\"c\", age=60, parent=root)\n&gt;&gt;&gt; d = Node(\"d\", age=40, parent=c)\n&gt;&gt;&gt; find_children(root, lambda node: node.age &gt; 30)\n(Node(/a/b, age=65), Node(/a/c, age=60))\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>BaseNode / DAGNode</code> <p>tree to search for its children</p> required <code>condition</code> <code>Callable</code> <p>function that takes in node as argument, returns node if condition evaluates to <code>True</code></p> required <code>min_count</code> <code>int</code> <p>checks for minimum number of occurrences, raise SearchError if the number of results do not meet min_count, defaults to None</p> <code>0</code> <code>max_count</code> <code>int</code> <p>checks for maximum number of occurrences, raise SearchError if the number of results do not meet min_count, defaults to None</p> <code>0</code> <p>Returns:</p> Type Description <code>Tuple[Union[T, DAGNodeT], ...]</code> <p>(BaseNode/DAGNode)</p>"},{"location":"bigtree/tree/search/#bigtree.tree.search.find_child","title":"find_child","text":"<pre><code>find_child(tree, condition)\n</code></pre> <p>Search children for single node matching condition (callable function).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, find_child\n&gt;&gt;&gt; root = Node(\"a\", age=90)\n&gt;&gt;&gt; b = Node(\"b\", age=65, parent=root)\n&gt;&gt;&gt; c = Node(\"c\", age=60, parent=root)\n&gt;&gt;&gt; d = Node(\"d\", age=40, parent=c)\n&gt;&gt;&gt; find_child(root, lambda node: node.age &gt; 62)\nNode(/a/b, age=65)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>BaseNode / DAGNode</code> <p>tree to search for its child</p> required <code>condition</code> <code>Callable</code> <p>function that takes in node as argument, returns node if condition evaluates to <code>True</code></p> required <p>Returns:</p> Type Description <code>Union[T, DAGNodeT]</code> <p>(BaseNode/DAGNode)</p>"},{"location":"bigtree/tree/search/#bigtree.tree.search.find_child_by_name","title":"find_child_by_name","text":"<pre><code>find_child_by_name(tree, name)\n</code></pre> <p>Search tree for single node matching name attribute.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, find_child_by_name\n&gt;&gt;&gt; root = Node(\"a\", age=90)\n&gt;&gt;&gt; b = Node(\"b\", age=65, parent=root)\n&gt;&gt;&gt; c = Node(\"c\", age=60, parent=root)\n&gt;&gt;&gt; d = Node(\"d\", age=40, parent=c)\n&gt;&gt;&gt; find_child_by_name(root, \"c\")\nNode(/a/c, age=60)\n&gt;&gt;&gt; find_child_by_name(c, \"d\")\nNode(/a/c/d, age=40)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>Node / DAGNode</code> <p>tree to search, parent node</p> required <code>name</code> <code>str</code> <p>value to match for name attribute, child node</p> required <p>Returns:</p> Type Description <code>Union[NodeT, DAGNodeT]</code> <p>(Node/DAGNode)</p>"},{"location":"bigtree/utils/","title":"\ud83d\udd27 Utils","text":""},{"location":"bigtree/utils/iterators/","title":"\u27b0 Iterators","text":"<p>Iterator methods for Trees and DAGs.</p>"},{"location":"bigtree/utils/iterators/#iterator-methods","title":"Iterator Methods","text":"Data Structure Algorithm Description Binary Tree In-order Traversal Depth-First Search, LNR Tree Pre-order Traversal Depth-First Search, NLR Tree Post-Order Traversal Depth-First Search, LRN Tree Level-Order Traversal Breadth-First Search Tree ZigZag Traversal Breadth-First Search Tree ZigZag Group Traversal Breadth-First Search DAG General Depth-First Search"},{"location":"bigtree/utils/iterators/#bigtree.utils.iterators","title":"bigtree.utils.iterators","text":""},{"location":"bigtree/utils/iterators/#bigtree.utils.iterators.inorder_iter","title":"inorder_iter","text":"<pre><code>inorder_iter(tree, filter_condition=None, max_depth=0)\n</code></pre> <p>Iterate through all children of a tree.</p> <p>In-Order Iteration Algorithm, LNR     1. Recursively traverse the current node's left subtree.     2. Visit the current node.     3. Recursively traverse the current node's right subtree.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import BinaryNode, list_to_binarytree, inorder_iter\n&gt;&gt;&gt; num_list = [1, 2, 3, 4, 5, 6, 7, 8]\n&gt;&gt;&gt; root = list_to_binarytree(num_list)\n&gt;&gt;&gt; root.show()\n1\n\u251c\u2500\u2500 2\n\u2502   \u251c\u2500\u2500 4\n\u2502   \u2502   \u2514\u2500\u2500 8\n\u2502   \u2514\u2500\u2500 5\n\u2514\u2500\u2500 3\n    \u251c\u2500\u2500 6\n    \u2514\u2500\u2500 7\n</code></pre> <pre><code>&gt;&gt;&gt; [node.node_name for node in inorder_iter(root)]\n['8', '4', '2', '5', '1', '6', '3', '7']\n</code></pre> <pre><code>&gt;&gt;&gt; [node.node_name for node in inorder_iter(root, filter_condition=lambda x: x.node_name in [\"1\", \"4\", \"3\", \"6\", \"7\"])]\n['4', '1', '6', '3', '7']\n</code></pre> <pre><code>&gt;&gt;&gt; [node.node_name for node in inorder_iter(root, max_depth=3)]\n['4', '2', '5', '1', '6', '3', '7']\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>BinaryNode</code> <p>input tree</p> required <code>filter_condition</code> <code>Optional[Callable[[BinaryNode], bool]]</code> <p>function that takes in node as argument, optional Return node if condition evaluates to <code>True</code></p> <code>None</code> <code>max_depth</code> <code>int</code> <p>maximum depth of iteration, based on <code>depth</code> attribute, optional</p> <code>0</code> <p>Returns:</p> Type Description <code>Iterable[BinaryNodeT]</code> <p>(Iterable[BinaryNode])</p>"},{"location":"bigtree/utils/iterators/#bigtree.utils.iterators.preorder_iter","title":"preorder_iter","text":"<pre><code>preorder_iter(\n    tree,\n    filter_condition=None,\n    stop_condition=None,\n    max_depth=0,\n)\n</code></pre> <p>Iterate through all children of a tree.</p> <p>Pre-Order Iteration Algorithm, NLR     1. Visit the current node.     2. Recursively traverse the current node's left subtree.     3. Recursively traverse the current node's right subtree.</p> <p>It is topologically sorted because a parent node is processed before its child nodes.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, list_to_tree, preorder_iter\n&gt;&gt;&gt; path_list = [\"a/b/d\", \"a/b/e/g\", \"a/b/e/h\", \"a/c/f\"]\n&gt;&gt;&gt; root = list_to_tree(path_list)\n&gt;&gt;&gt; root.show()\na\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 d\n\u2502   \u2514\u2500\u2500 e\n\u2502       \u251c\u2500\u2500 g\n\u2502       \u2514\u2500\u2500 h\n\u2514\u2500\u2500 c\n    \u2514\u2500\u2500 f\n</code></pre> <pre><code>&gt;&gt;&gt; [node.node_name for node in preorder_iter(root)]\n['a', 'b', 'd', 'e', 'g', 'h', 'c', 'f']\n</code></pre> <pre><code>&gt;&gt;&gt; [node.node_name for node in preorder_iter(root, filter_condition=lambda x: x.node_name in [\"a\", \"d\", \"e\", \"f\", \"g\"])]\n['a', 'd', 'e', 'g', 'f']\n</code></pre> <pre><code>&gt;&gt;&gt; [node.node_name for node in preorder_iter(root, stop_condition=lambda x: x.node_name == \"e\")]\n['a', 'b', 'd', 'c', 'f']\n</code></pre> <pre><code>&gt;&gt;&gt; [node.node_name for node in preorder_iter(root, max_depth=3)]\n['a', 'b', 'd', 'e', 'c', 'f']\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>Union[BaseNode, DAGNode]</code> <p>input tree</p> required <code>filter_condition</code> <code>Optional[Callable[[T], bool]]</code> <p>function that takes in node as argument, optional Return node if condition evaluates to <code>True</code></p> <code>None</code> <code>stop_condition</code> <code>Optional[Callable[[T], bool]]</code> <p>function that takes in node as argument, optional Stops iteration if condition evaluates to <code>True</code></p> <code>None</code> <code>max_depth</code> <code>int</code> <p>maximum depth of iteration, based on <code>depth</code> attribute, optional</p> <code>0</code> <p>Returns:</p> Type Description <code>Iterable[T]</code> <p>(Union[Iterable[BaseNode], Iterable[DAGNode]])</p>"},{"location":"bigtree/utils/iterators/#bigtree.utils.iterators.postorder_iter","title":"postorder_iter","text":"<pre><code>postorder_iter(\n    tree,\n    filter_condition=None,\n    stop_condition=None,\n    max_depth=0,\n)\n</code></pre> <p>Iterate through all children of a tree.</p> <p>Post-Order Iteration Algorithm, LRN     1. Recursively traverse the current node's left subtree.     2. Recursively traverse the current node's right subtree.     3. Visit the current node.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, list_to_tree, postorder_iter\n&gt;&gt;&gt; path_list = [\"a/b/d\", \"a/b/e/g\", \"a/b/e/h\", \"a/c/f\"]\n&gt;&gt;&gt; root = list_to_tree(path_list)\n&gt;&gt;&gt; root.show()\na\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 d\n\u2502   \u2514\u2500\u2500 e\n\u2502       \u251c\u2500\u2500 g\n\u2502       \u2514\u2500\u2500 h\n\u2514\u2500\u2500 c\n    \u2514\u2500\u2500 f\n</code></pre> <pre><code>&gt;&gt;&gt; [node.node_name for node in postorder_iter(root)]\n['d', 'g', 'h', 'e', 'b', 'f', 'c', 'a']\n</code></pre> <pre><code>&gt;&gt;&gt; [node.node_name for node in postorder_iter(root, filter_condition=lambda x: x.node_name in [\"a\", \"d\", \"e\", \"f\", \"g\"])]\n['d', 'g', 'e', 'f', 'a']\n</code></pre> <pre><code>&gt;&gt;&gt; [node.node_name for node in postorder_iter(root, stop_condition=lambda x: x.node_name == \"e\")]\n['d', 'b', 'f', 'c', 'a']\n</code></pre> <pre><code>&gt;&gt;&gt; [node.node_name for node in postorder_iter(root, max_depth=3)]\n['d', 'e', 'b', 'f', 'c', 'a']\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>BaseNode</code> <p>input tree</p> required <code>filter_condition</code> <code>Optional[Callable[[BaseNode], bool]]</code> <p>function that takes in node as argument, optional Return node if condition evaluates to <code>True</code></p> <code>None</code> <code>stop_condition</code> <code>Optional[Callable[[BaseNode], bool]]</code> <p>function that takes in node as argument, optional Stops iteration if condition evaluates to <code>True</code></p> <code>None</code> <code>max_depth</code> <code>int</code> <p>maximum depth of iteration, based on <code>depth</code> attribute, optional</p> <code>0</code> <p>Returns:</p> Type Description <code>Iterable[BaseNodeT]</code> <p>(Iterable[BaseNode])</p>"},{"location":"bigtree/utils/iterators/#bigtree.utils.iterators.levelorder_iter","title":"levelorder_iter","text":"<pre><code>levelorder_iter(\n    tree,\n    filter_condition=None,\n    stop_condition=None,\n    max_depth=0,\n)\n</code></pre> <p>Iterate through all children of a tree.</p> <p>Level-Order Iteration Algorithm     1. Recursively traverse the nodes on same level.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, list_to_tree, levelorder_iter\n&gt;&gt;&gt; path_list = [\"a/b/d\", \"a/b/e/g\", \"a/b/e/h\", \"a/c/f\"]\n&gt;&gt;&gt; root = list_to_tree(path_list)\n&gt;&gt;&gt; root.show()\na\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 d\n\u2502   \u2514\u2500\u2500 e\n\u2502       \u251c\u2500\u2500 g\n\u2502       \u2514\u2500\u2500 h\n\u2514\u2500\u2500 c\n    \u2514\u2500\u2500 f\n</code></pre> <pre><code>&gt;&gt;&gt; [node.node_name for node in levelorder_iter(root)]\n['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']\n</code></pre> <pre><code>&gt;&gt;&gt; [node.node_name for node in levelorder_iter(root, filter_condition=lambda x: x.node_name in [\"a\", \"d\", \"e\", \"f\", \"g\"])]\n['a', 'd', 'e', 'f', 'g']\n</code></pre> <pre><code>&gt;&gt;&gt; [node.node_name for node in levelorder_iter(root, stop_condition=lambda x: x.node_name == \"e\")]\n['a', 'b', 'c', 'd', 'f']\n</code></pre> <pre><code>&gt;&gt;&gt; [node.node_name for node in levelorder_iter(root, max_depth=3)]\n['a', 'b', 'c', 'd', 'e', 'f']\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>BaseNode</code> <p>input tree</p> required <code>filter_condition</code> <code>Optional[Callable[[BaseNode], bool]]</code> <p>function that takes in node as argument, optional Return node if condition evaluates to <code>True</code></p> <code>None</code> <code>stop_condition</code> <code>Optional[Callable[[BaseNode], bool]]</code> <p>function that takes in node as argument, optional Stops iteration if condition evaluates to <code>True</code></p> <code>None</code> <code>max_depth</code> <code>int</code> <p>maximum depth of iteration, based on <code>depth</code> attribute, defaults to None</p> <code>0</code> <p>Returns:</p> Type Description <code>Iterable[BaseNodeT]</code> <p>(Iterable[BaseNode])</p>"},{"location":"bigtree/utils/iterators/#bigtree.utils.iterators.levelordergroup_iter","title":"levelordergroup_iter","text":"<pre><code>levelordergroup_iter(\n    tree,\n    filter_condition=None,\n    stop_condition=None,\n    max_depth=0,\n)\n</code></pre> <p>Iterate through all children of a tree.</p> <p>Level-Order Group Iteration Algorithm     1. Recursively traverse the nodes on same level, returns nodes level by level in a nested list.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, list_to_tree, levelordergroup_iter\n&gt;&gt;&gt; path_list = [\"a/b/d\", \"a/b/e/g\", \"a/b/e/h\", \"a/c/f\"]\n&gt;&gt;&gt; root = list_to_tree(path_list)\n&gt;&gt;&gt; root.show()\na\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 d\n\u2502   \u2514\u2500\u2500 e\n\u2502       \u251c\u2500\u2500 g\n\u2502       \u2514\u2500\u2500 h\n\u2514\u2500\u2500 c\n    \u2514\u2500\u2500 f\n</code></pre> <pre><code>&gt;&gt;&gt; [[node.node_name for node in group] for group in levelordergroup_iter(root)]\n[['a'], ['b', 'c'], ['d', 'e', 'f'], ['g', 'h']]\n</code></pre> <pre><code>&gt;&gt;&gt; [[node.node_name for node in group] for group in levelordergroup_iter(root, filter_condition=lambda x: x.node_name in [\"a\", \"d\", \"e\", \"f\", \"g\"])]\n[['a'], [], ['d', 'e', 'f'], ['g']]\n</code></pre> <pre><code>&gt;&gt;&gt; [[node.node_name for node in group] for group in levelordergroup_iter(root, stop_condition=lambda x: x.node_name == \"e\")]\n[['a'], ['b', 'c'], ['d', 'f']]\n</code></pre> <pre><code>&gt;&gt;&gt; [[node.node_name for node in group] for group in levelordergroup_iter(root, max_depth=3)]\n[['a'], ['b', 'c'], ['d', 'e', 'f']]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>BaseNode</code> <p>input tree</p> required <code>filter_condition</code> <code>Optional[Callable[[BaseNode], bool]]</code> <p>function that takes in node as argument, optional Return node if condition evaluates to <code>True</code></p> <code>None</code> <code>stop_condition</code> <code>Optional[Callable[[BaseNode], bool]]</code> <p>function that takes in node as argument, optional Stops iteration if condition evaluates to <code>True</code></p> <code>None</code> <code>max_depth</code> <code>int</code> <p>maximum depth of iteration, based on <code>depth</code> attribute, defaults to None</p> <code>0</code> <p>Returns:</p> Type Description <code>Iterable[Iterable[BaseNodeT]]</code> <p>(Iterable[Iterable[BaseNode]])</p>"},{"location":"bigtree/utils/iterators/#bigtree.utils.iterators.zigzag_iter","title":"zigzag_iter","text":"<pre><code>zigzag_iter(\n    tree,\n    filter_condition=None,\n    stop_condition=None,\n    max_depth=0,\n)\n</code></pre> <p>Iterate through all children of a tree.</p> <p>ZigZag Iteration Algorithm     1. Recursively traverse the nodes on same level, in a zigzag manner across different levels.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, list_to_tree, zigzag_iter\n&gt;&gt;&gt; path_list = [\"a/b/d\", \"a/b/e/g\", \"a/b/e/h\", \"a/c/f\"]\n&gt;&gt;&gt; root = list_to_tree(path_list)\n&gt;&gt;&gt; root.show()\na\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 d\n\u2502   \u2514\u2500\u2500 e\n\u2502       \u251c\u2500\u2500 g\n\u2502       \u2514\u2500\u2500 h\n\u2514\u2500\u2500 c\n    \u2514\u2500\u2500 f\n</code></pre> <pre><code>&gt;&gt;&gt; [node.node_name for node in zigzag_iter(root)]\n['a', 'c', 'b', 'd', 'e', 'f', 'h', 'g']\n</code></pre> <pre><code>&gt;&gt;&gt; [node.node_name for node in zigzag_iter(root, filter_condition=lambda x: x.node_name in [\"a\", \"d\", \"e\", \"f\", \"g\"])]\n['a', 'd', 'e', 'f', 'g']\n</code></pre> <pre><code>&gt;&gt;&gt; [node.node_name for node in zigzag_iter(root, stop_condition=lambda x: x.node_name == \"e\")]\n['a', 'c', 'b', 'd', 'f']\n</code></pre> <pre><code>&gt;&gt;&gt; [node.node_name for node in zigzag_iter(root, max_depth=3)]\n['a', 'c', 'b', 'd', 'e', 'f']\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>BaseNode</code> <p>input tree</p> required <code>filter_condition</code> <code>Optional[Callable[[BaseNode], bool]]</code> <p>function that takes in node as argument, optional Return node if condition evaluates to <code>True</code></p> <code>None</code> <code>stop_condition</code> <code>Optional[Callable[[BaseNode], bool]]</code> <p>function that takes in node as argument, optional Stops iteration if condition evaluates to <code>True</code></p> <code>None</code> <code>max_depth</code> <code>int</code> <p>maximum depth of iteration, based on <code>depth</code> attribute, defaults to None</p> <code>0</code> <p>Returns:</p> Type Description <code>Iterable[BaseNodeT]</code> <p>(Iterable[BaseNode])</p>"},{"location":"bigtree/utils/iterators/#bigtree.utils.iterators.zigzaggroup_iter","title":"zigzaggroup_iter","text":"<pre><code>zigzaggroup_iter(\n    tree,\n    filter_condition=None,\n    stop_condition=None,\n    max_depth=0,\n)\n</code></pre> <p>Iterate through all children of a tree.</p> <p>ZigZag Group Iteration Algorithm     1. Recursively traverse the nodes on same level, in a zigzag manner across different levels,         returns nodes level by level in a nested list.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import Node, list_to_tree, zigzaggroup_iter\n&gt;&gt;&gt; path_list = [\"a/b/d\", \"a/b/e/g\", \"a/b/e/h\", \"a/c/f\"]\n&gt;&gt;&gt; root = list_to_tree(path_list)\n&gt;&gt;&gt; root.show()\na\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 d\n\u2502   \u2514\u2500\u2500 e\n\u2502       \u251c\u2500\u2500 g\n\u2502       \u2514\u2500\u2500 h\n\u2514\u2500\u2500 c\n    \u2514\u2500\u2500 f\n</code></pre> <pre><code>&gt;&gt;&gt; [[node.node_name for node in group] for group in zigzaggroup_iter(root)]\n[['a'], ['c', 'b'], ['d', 'e', 'f'], ['h', 'g']]\n</code></pre> <pre><code>&gt;&gt;&gt; [[node.node_name for node in group] for group in zigzaggroup_iter(root, filter_condition=lambda x: x.node_name in [\"a\", \"d\", \"e\", \"f\", \"g\"])]\n[['a'], [], ['d', 'e', 'f'], ['g']]\n</code></pre> <pre><code>&gt;&gt;&gt; [[node.node_name for node in group] for group in zigzaggroup_iter(root, stop_condition=lambda x: x.node_name == \"e\")]\n[['a'], ['c', 'b'], ['d', 'f']]\n</code></pre> <pre><code>&gt;&gt;&gt; [[node.node_name for node in group] for group in zigzaggroup_iter(root, max_depth=3)]\n[['a'], ['c', 'b'], ['d', 'e', 'f']]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>BaseNode</code> <p>input tree</p> required <code>filter_condition</code> <code>Optional[Callable[[BaseNode], bool]]</code> <p>function that takes in node as argument, optional Return node if condition evaluates to <code>True</code></p> <code>None</code> <code>stop_condition</code> <code>Optional[Callable[[BaseNode], bool]]</code> <p>function that takes in node as argument, optional Stops iteration if condition evaluates to <code>True</code></p> <code>None</code> <code>max_depth</code> <code>int</code> <p>maximum depth of iteration, based on <code>depth</code> attribute, defaults to None</p> <code>0</code> <p>Returns:</p> Type Description <code>Iterable[Iterable[BaseNodeT]]</code> <p>(Iterable[Iterable[BaseNode]])</p>"},{"location":"bigtree/utils/iterators/#bigtree.utils.iterators.dag_iterator","title":"dag_iterator","text":"<pre><code>dag_iterator(dag)\n</code></pre> <p>Iterate through all nodes of a Directed Acyclic Graph (DAG). Note that node names must be unique. Note that DAG must at least have two nodes to be shown on graph.</p> <ol> <li>Visit the current node.</li> <li>Recursively traverse the current node's parents.</li> <li>Recursively traverse the current node's children.</li> </ol> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import DAGNode, dag_iterator\n&gt;&gt;&gt; a = DAGNode(\"a\", step=1)\n&gt;&gt;&gt; b = DAGNode(\"b\", step=1)\n&gt;&gt;&gt; c = DAGNode(\"c\", step=2, parents=[a, b])\n&gt;&gt;&gt; d = DAGNode(\"d\", step=2, parents=[a, c])\n&gt;&gt;&gt; e = DAGNode(\"e\", step=3, parents=[d])\n&gt;&gt;&gt; [(parent.node_name, child.node_name) for parent, child in dag_iterator(a)]\n[('a', 'c'), ('a', 'd'), ('b', 'c'), ('c', 'd'), ('d', 'e')]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>dag</code> <code>DAGNode</code> <p>input dag</p> required <p>Returns:</p> Type Description <code>Iterable[Tuple[DAGNodeT, DAGNodeT]]</code> <p>(Iterable[Tuple[DAGNode, DAGNode]])</p>"},{"location":"bigtree/utils/plot/","title":"\ud83d\udcca Plot","text":"<p>Plotting methods for Trees.</p>"},{"location":"bigtree/utils/plot/#bigtree.utils.plot","title":"bigtree.utils.plot","text":""},{"location":"bigtree/utils/plot/#bigtree.utils.plot.reingold_tilford","title":"reingold_tilford","text":"<pre><code>reingold_tilford(\n    tree_node,\n    sibling_separation=1.0,\n    subtree_separation=1.0,\n    level_separation=1.0,\n    x_offset=0.0,\n    y_offset=0.0,\n)\n</code></pre> <p>Algorithm for drawing tree structure, retrieves <code>(x, y)</code> coordinates for a tree structure. Adds <code>x</code> and <code>y</code> attributes to every node in the tree. Modifies tree in-place.</p> <p>This algorithm[1] is an improvement over Reingold Tilford algorithm[2].</p> <p>According to Reingold Tilford's paper, a tree diagram should satisfy the following aesthetic rules,</p> <ol> <li>Nodes at the same depth should lie along a straight line, and the straight lines defining the depths should be parallel.</li> <li>A left child should be positioned to the left of its parent node and a right child to the right.</li> <li>A parent should be centered over their children.</li> <li>A tree and its mirror image should produce drawings that are reflections of one another; a subtree should be drawn the same way regardless of where it occurs in the tree.</li> </ol> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bigtree import reingold_tilford, list_to_tree\n&gt;&gt;&gt; path_list = [\"a/b/d\", \"a/b/e/g\", \"a/b/e/h\", \"a/c/f\"]\n&gt;&gt;&gt; root = list_to_tree(path_list)\n&gt;&gt;&gt; root.show()\na\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 d\n\u2502   \u2514\u2500\u2500 e\n\u2502       \u251c\u2500\u2500 g\n\u2502       \u2514\u2500\u2500 h\n\u2514\u2500\u2500 c\n    \u2514\u2500\u2500 f\n</code></pre> <pre><code>&gt;&gt;&gt; reingold_tilford(root)\n&gt;&gt;&gt; root.show(attr_list=[\"x\", \"y\"])\na [x=1.25, y=3.0]\n\u251c\u2500\u2500 b [x=0.5, y=2.0]\n\u2502   \u251c\u2500\u2500 d [x=0.0, y=1.0]\n\u2502   \u2514\u2500\u2500 e [x=1.0, y=1.0]\n\u2502       \u251c\u2500\u2500 g [x=0.5, y=0.0]\n\u2502       \u2514\u2500\u2500 h [x=1.5, y=0.0]\n\u2514\u2500\u2500 c [x=2.0, y=2.0]\n    \u2514\u2500\u2500 f [x=2.0, y=1.0]\n</code></pre> <p>References</p> <ul> <li>[1] Walker, J. (1991). Positioning Nodes for General Trees. https://www.drdobbs.com/positioning-nodes-for-general-trees/184402320?pgno=4</li> <li>[2] Reingold, E., Tilford, J. (1981). Tidier Drawings of Trees. IEEE Transactions on Software Engineering. https://reingold.co/tidier-drawings.pdf</li> </ul> <p>Parameters:</p> Name Type Description Default <code>tree_node</code> <code>BaseNode</code> <p>tree to compute (x, y) coordinate</p> required <code>sibling_separation</code> <code>float</code> <p>minimum distance between adjacent siblings of the tree</p> <code>1.0</code> <code>subtree_separation</code> <code>float</code> <p>minimum distance between adjacent subtrees of the tree</p> <code>1.0</code> <code>level_separation</code> <code>float</code> <p>fixed distance between adjacent levels of the tree</p> <code>1.0</code> <code>x_offset</code> <code>float</code> <p>graph offset of x-coordinates</p> <code>0.0</code> <code>y_offset</code> <code>float</code> <p>graph offset of y-coordinates</p> <code>0.0</code>"},{"location":"bigtree/workflows/","title":"\ud83d\udc77 Workflows","text":""},{"location":"bigtree/workflows/app_calendar/","title":"\ud83d\udcc6 Calendar App","text":""},{"location":"bigtree/workflows/app_calendar/#bigtree.workflows.app_calendar","title":"bigtree.workflows.app_calendar","text":""},{"location":"bigtree/workflows/app_calendar/#bigtree.workflows.app_calendar.Calendar","title":"Calendar","text":"<pre><code>Calendar(name)\n</code></pre> <p>Calendar Implementation with Big Tree.   - Calendar has four levels - year, month, day, and event name (with event attributes)</p> <p>Examples:</p> <p>Initializing and Adding Events</p> <pre><code>&gt;&gt;&gt; from bigtree import Calendar\n&gt;&gt;&gt; calendar = Calendar(\"My Calendar\")\n&gt;&gt;&gt; calendar.add_event(\"Gym\", \"2023-01-01 18:00\")\n&gt;&gt;&gt; calendar.add_event(\"Dinner\", \"2023-01-01\", date_format=\"%Y-%m-%d\", budget=20)\n&gt;&gt;&gt; calendar.add_event(\"Gym\", \"2023-01-02 18:00\")\n&gt;&gt;&gt; calendar.show()\nMy Calendar\n2023-01-01 00:00:00 - Dinner (budget: 20)\n2023-01-01 18:00:00 - Gym\n2023-01-02 18:00:00 - Gym\n</code></pre> <p>Search for Events</p> <pre><code>&gt;&gt;&gt; calendar.find_event(\"Gym\")\n2023-01-01 18:00:00 - Gym\n2023-01-02 18:00:00 - Gym\n</code></pre> <p>Removing Events</p> <pre><code>&gt;&gt;&gt; import datetime as dt\n&gt;&gt;&gt; calendar.delete_event(\"Gym\", dt.date(2023, 1, 1))\n&gt;&gt;&gt; calendar.show()\nMy Calendar\n2023-01-01 00:00:00 - Dinner (budget: 20)\n2023-01-02 18:00:00 - Gym\n</code></pre> <p>Export Calendar</p> <pre><code>&gt;&gt;&gt; calendar.to_dataframe()\n                             path    name        date      time  budget\n0  /My Calendar/2023/01/01/Dinner  Dinner  2023-01-01  00:00:00    20.0\n1     /My Calendar/2023/01/02/Gym     Gym  2023-01-02  18:00:00     NaN\n</code></pre>"},{"location":"bigtree/workflows/app_calendar/#bigtree.workflows.app_calendar.Calendar.add_event","title":"add_event","text":"<pre><code>add_event(\n    event_name,\n    event_datetime,\n    date_format=\"%Y-%m-%d %H:%M\",\n    **kwargs\n)\n</code></pre> <p>Add event to calendar</p> <p>Parameters:</p> Name Type Description Default <code>event_name</code> <code>str</code> <p>event name to be added</p> required <code>event_datetime</code> <code>Union[str, datetime]</code> <p>event date and time</p> required <code>date_format</code> <code>str</code> <p>specify datetime format if event_datetime is str</p> <code>'%Y-%m-%d %H:%M'</code>"},{"location":"bigtree/workflows/app_calendar/#bigtree.workflows.app_calendar.Calendar.delete_event","title":"delete_event","text":"<pre><code>delete_event(event_name, event_date=None)\n</code></pre> <p>Delete event from calendar</p> <p>Parameters:</p> Name Type Description Default <code>event_name</code> <code>str</code> <p>event name to be deleted</p> required <code>event_date</code> <code>date</code> <p>event date to be deleted</p> <code>None</code>"},{"location":"bigtree/workflows/app_calendar/#bigtree.workflows.app_calendar.Calendar.find_event","title":"find_event","text":"<pre><code>find_event(event_name)\n</code></pre> <p>Find event by name, prints result to console</p> <p>Parameters:</p> Name Type Description Default <code>event_name</code> <code>str</code> <p>event name</p> required"},{"location":"bigtree/workflows/app_calendar/#bigtree.workflows.app_calendar.Calendar.show","title":"show","text":"<pre><code>show()\n</code></pre> <p>Show calendar, prints result to console</p>"},{"location":"bigtree/workflows/app_calendar/#bigtree.workflows.app_calendar.Calendar.to_dataframe","title":"to_dataframe","text":"<pre><code>to_dataframe()\n</code></pre> <p>Export calendar to DataFrame</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>(pd.DataFrame)</p>"},{"location":"bigtree/workflows/app_todo/","title":"\u2714\ufe0f To Do App","text":""},{"location":"bigtree/workflows/app_todo/#bigtree.workflows.app_todo","title":"bigtree.workflows.app_todo","text":""},{"location":"bigtree/workflows/app_todo/#bigtree.workflows.app_todo.AppToDo","title":"AppToDo","text":"<pre><code>AppToDo(app_name='')\n</code></pre> <p>To-Do List Implementation with Big Tree.   - To-Do List has three levels - app name, list name, and item name.   - If list name is not given, item will be assigned to a <code>General</code> list.</p> <p>Examples:</p> <p>Initializing and Adding Items</p> <pre><code>&gt;&gt;&gt; from bigtree import AppToDo\n&gt;&gt;&gt; app = AppToDo(\"To Do App\")\n&gt;&gt;&gt; app.add_item(item_name=\"Homework 1\", list_name=\"School\")\n&gt;&gt;&gt; app.add_item(item_name=[\"Milk\", \"Bread\"], list_name=\"Groceries\", description=\"Urgent\")\n&gt;&gt;&gt; app.add_item(item_name=\"Cook\")\n&gt;&gt;&gt; app.show()\nTo Do App\n\u251c\u2500\u2500 School\n\u2502   \u2514\u2500\u2500 Homework 1\n\u251c\u2500\u2500 Groceries\n\u2502   \u251c\u2500\u2500 Milk [description=Urgent]\n\u2502   \u2514\u2500\u2500 Bread [description=Urgent]\n\u2514\u2500\u2500 General\n    \u2514\u2500\u2500 Cook\n</code></pre> <p>Reorder List and Item</p> <pre><code>&gt;&gt;&gt; app.prioritize_list(list_name=\"General\")\n&gt;&gt;&gt; app.show()\nTo Do App\n\u251c\u2500\u2500 General\n\u2502   \u2514\u2500\u2500 Cook\n\u251c\u2500\u2500 School\n\u2502   \u2514\u2500\u2500 Homework 1\n\u2514\u2500\u2500 Groceries\n    \u251c\u2500\u2500 Milk [description=Urgent]\n    \u2514\u2500\u2500 Bread [description=Urgent]\n</code></pre> <pre><code>&gt;&gt;&gt; app.prioritize_item(item_name=\"Bread\")\n&gt;&gt;&gt; app.show()\nTo Do App\n\u251c\u2500\u2500 General\n\u2502   \u2514\u2500\u2500 Cook\n\u251c\u2500\u2500 School\n\u2502   \u2514\u2500\u2500 Homework 1\n\u2514\u2500\u2500 Groceries\n    \u251c\u2500\u2500 Bread [description=Urgent]\n    \u2514\u2500\u2500 Milk [description=Urgent]\n</code></pre> <p>Removing Items</p> <pre><code>&gt;&gt;&gt; app.remove_item(\"Homework 1\")\n&gt;&gt;&gt; app.show()\nTo Do App\n\u251c\u2500\u2500 General\n\u2502   \u2514\u2500\u2500 Cook\n\u2514\u2500\u2500 Groceries\n    \u251c\u2500\u2500 Bread [description=Urgent]\n    \u2514\u2500\u2500 Milk [description=Urgent]\n</code></pre> <p>Exporting and Importing List</p> <pre><code>&gt;&gt;&gt; app.save(\"assets/docstr/list.json\")\n&gt;&gt;&gt; app2 = AppToDo.load(\"assets/docstr/list.json\")\n&gt;&gt;&gt; app2.show()\nTo Do App\n\u251c\u2500\u2500 General\n\u2502   \u2514\u2500\u2500 Cook\n\u2514\u2500\u2500 Groceries\n    \u251c\u2500\u2500 Bread [description=Urgent]\n    \u2514\u2500\u2500 Milk [description=Urgent]\n</code></pre> <p>Initialize To-Do app</p> <p>Parameters:</p> Name Type Description Default <code>app_name</code> <code>str</code> <p>name of to-do app, optional</p> <code>''</code>"},{"location":"bigtree/workflows/app_todo/#bigtree.workflows.app_todo.AppToDo.add_list","title":"add_list","text":"<pre><code>add_list(list_name, **kwargs)\n</code></pre> <p>Add list to app</p> <p>If list is present, return list node, else a new list will be created</p> <p>Parameters:</p> Name Type Description Default <code>list_name</code> <code>str</code> <p>name of list</p> required <p>Returns:</p> Type Description <code>Node</code> <p>(Node)</p>"},{"location":"bigtree/workflows/app_todo/#bigtree.workflows.app_todo.AppToDo.prioritize_list","title":"prioritize_list","text":"<pre><code>prioritize_list(list_name)\n</code></pre> <p>Prioritize list in app, shift it to be the first list</p> <p>Parameters:</p> Name Type Description Default <code>list_name</code> <code>str</code> <p>name of list</p> required"},{"location":"bigtree/workflows/app_todo/#bigtree.workflows.app_todo.AppToDo.add_item","title":"add_item","text":"<pre><code>add_item(item_name, list_name='', **kwargs)\n</code></pre> <p>Add items to list</p> <p>Parameters:</p> Name Type Description Default <code>item_name</code> <code>str / List[str]</code> <p>items to be added</p> required <code>list_name</code> <code>str</code> <p>list to add items to, optional</p> <code>''</code>"},{"location":"bigtree/workflows/app_todo/#bigtree.workflows.app_todo.AppToDo.remove_item","title":"remove_item","text":"<pre><code>remove_item(item_name, list_name='')\n</code></pre> <p>Remove items from list</p> <p>Parameters:</p> Name Type Description Default <code>item_name</code> <code>str / List[str]</code> <p>items to be added</p> required <code>list_name</code> <code>str</code> <p>list to add items to, optional</p> <code>''</code>"},{"location":"bigtree/workflows/app_todo/#bigtree.workflows.app_todo.AppToDo.prioritize_item","title":"prioritize_item","text":"<pre><code>prioritize_item(item_name)\n</code></pre> <p>Prioritize item in list, shift it to be the first item in list</p> <p>Parameters:</p> Name Type Description Default <code>item_name</code> <code>str</code> <p>name of item</p> required"},{"location":"bigtree/workflows/app_todo/#bigtree.workflows.app_todo.AppToDo.show","title":"show","text":"<pre><code>show(**kwargs)\n</code></pre> <p>Print tree to console</p>"},{"location":"bigtree/workflows/app_todo/#bigtree.workflows.app_todo.AppToDo.load","title":"load  <code>staticmethod</code>","text":"<pre><code>load(json_path)\n</code></pre> <p>Load To-Do app from json</p> <p>Parameters:</p> Name Type Description Default <code>json_path</code> <code>str</code> <p>json load path</p> required <p>Returns:</p> Type Description <code>AppToDo</code> <p>(Self)</p>"},{"location":"bigtree/workflows/app_todo/#bigtree.workflows.app_todo.AppToDo.save","title":"save","text":"<pre><code>save(json_path)\n</code></pre> <p>Save To-Do app as json</p> <p>Parameters:</p> Name Type Description Default <code>json_path</code> <code>str</code> <p>json save path</p> required"},{"location":"demo/","title":"\ud83d\udccb Getting Started","text":""},{"location":"demo/binarytree/","title":"\ud83d\udccb Binary Tree Demonstration","text":"<p>Compared to nodes in tree, nodes in Binary Tree are only allowed maximum of 2 children. Since BinaryNode extends from Node, construct, traverse, search, export methods from Node are applicable to Binary Tree as well.</p>"},{"location":"demo/binarytree/#construct-binary-tree","title":"Construct Binary Tree","text":""},{"location":"demo/binarytree/#1-from-binarynode","title":"1. From BinaryNode","text":"<p>BinaryNode can be linked to each other with <code>parent</code>, <code>children</code>, <code>left</code>, and <code>right</code> setter methods, or using bitshift operator with the convention <code>parent_node &gt;&gt; child_node</code> or <code>child_node &lt;&lt; parent_node</code>.</p> <pre><code>from bigtree import BinaryNode, tree_to_dot\n\ne = BinaryNode(5)\nd = BinaryNode(4)\nc = BinaryNode(3)\nb = BinaryNode(2, left=d, right=e)\na = BinaryNode(1, children=[b, c])\nf = BinaryNode(6, parent=c)\ng = BinaryNode(7, parent=c)\nh = BinaryNode(8, parent=d)\n\ngraph = tree_to_dot(a, node_colour=\"gold\")\ngraph.write_png(\"assets/demo/binarytree.png\")\n</code></pre> <p></p>"},{"location":"demo/binarytree/#2-from-list","title":"2. From list","text":"<p>Construct nodes only, list has similar format as <code>heapq</code> list.</p> <pre><code>from bigtree import list_to_binarytree\n\nnums_list = [1, 2, 3, 4, 5, 6, 7, 8]\nroot = list_to_binarytree(nums_list)\nroot.show()\n# 1\n# \u251c\u2500\u2500 2\n# \u2502   \u251c\u2500\u2500 4\n# \u2502   \u2502   \u2514\u2500\u2500 8\n# \u2502   \u2514\u2500\u2500 5\n# \u2514\u2500\u2500 3\n#     \u251c\u2500\u2500 6\n#     \u2514\u2500\u2500 7\n</code></pre>"},{"location":"demo/binarytree/#traverse-binary-tree","title":"Traverse Binary Tree","text":"<p>In addition to the traversal methods in the usual tree, binary tree includes in-order traversal method.</p> <pre><code>from bigtree import (\n    inorder_iter,\n    levelorder_iter,\n    levelordergroup_iter,\n    list_to_binarytree,\n    postorder_iter,\n    preorder_iter,\n    zigzag_iter,\n    zigzaggroup_iter,\n)\n\nnums_list = [1, 2, 3, 4, 5, 6, 7, 8]\nroot = list_to_binarytree(nums_list)\nroot.show()\n# 1\n# \u251c\u2500\u2500 2\n# \u2502   \u251c\u2500\u2500 4\n# \u2502   \u2502   \u2514\u2500\u2500 8\n# \u2502   \u2514\u2500\u2500 5\n# \u2514\u2500\u2500 3\n#     \u251c\u2500\u2500 6\n#     \u2514\u2500\u2500 7\n\n[node.name for node in inorder_iter(root)]\n# ['8', '4', '2', '5', '1', '6', '3', '7']\n\n[node.name for node in preorder_iter(root)]\n# ['1', '2', '4', '8', '5', '3', '6', '7']\n\n[node.name for node in postorder_iter(root)]\n# ['8', '4', '5', '2', '6', '7', '3', '1']\n\n[node.name for node in levelorder_iter(root)]\n# ['1', '2', '3', '4', '5', '6', '7', '8']\n\n[[node.name for node in node_group] for node_group in levelordergroup_iter(root)]\n# [['1'], ['2', '3'], ['4', '5', '6', '7'], ['8']]\n\n[node.name for node in zigzag_iter(root)]\n# ['1', '3', '2', '4', '5', '6', '7', '8']\n\n[[node.name for node in node_group] for node_group in zigzaggroup_iter(root)]\n# [['1'], ['3', '2'], ['4', '5', '6', '7'], ['8']]\n</code></pre>"},{"location":"demo/dag/","title":"\ud83d\udccb DAG Demonstration","text":"<p>Compared to nodes in tree, nodes in DAG are able to have multiple parents.</p>"},{"location":"demo/dag/#construct-dag","title":"Construct DAG","text":""},{"location":"demo/dag/#1-from-dagnode","title":"1. From DAGNode","text":"<p>DAGNodes can be linked to each other in the following ways:</p> <ul> <li>Using <code>parents</code> and <code>children</code> setter methods</li> <li>Directly passing <code>parents</code> or <code>children</code> argument</li> <li>Using bitshift operator with the convention <code>parent_node &gt;&gt; child_node</code> or <code>child_node &lt;&lt; parent_node</code></li> </ul> <pre><code>from bigtree import DAGNode, dag_to_dot\n\na = DAGNode(\"a\")\nb = DAGNode(\"b\")\nc = DAGNode(\"c\", parents=[a, b])\nd = DAGNode(\"d\", parents=[a, c])\ne = DAGNode(\"e\", parents=[d])\nf = DAGNode(\"f\", parents=[c, d])\nh = DAGNode(\"h\")\ng = DAGNode(\"g\", parents=[c], children=[h])\n\ngraph = dag_to_dot(a, node_colour=\"gold\")\ngraph.write_png(\"assets/demo/dag.png\")\n</code></pre> <p></p>"},{"location":"demo/dag/#2-from-list","title":"2. From list","text":"<p>Construct nodes only, list contains parent-child tuples.</p> <pre><code>from bigtree import list_to_dag, dag_iterator\n\nrelations_list = [(\"a\", \"c\"), (\"a\", \"d\"), (\"b\", \"c\"), (\"c\", \"d\"), (\"d\", \"e\")]\ndag = list_to_dag(relations_list)\n\nprint([(parent.node_name, child.node_name) for parent, child in dag_iterator(dag)])\n# [('a', 'd'), ('c', 'd'), ('d', 'e'), ('a', 'c'), ('b', 'c')]\n</code></pre>"},{"location":"demo/dag/#3-from-nested-dictionary","title":"3. From nested dictionary","text":"<p>Construct nodes with attributes, <code>key</code>: child name, <code>value</code>: dict of parent name, child node attributes.</p> <pre><code>from bigtree import dict_to_dag, dag_iterator\n\nrelation_dict = {\n    \"a\": {\"step\": 1},\n    \"b\": {\"step\": 1},\n    \"c\": {\"parents\": [\"a\", \"b\"], \"step\": 2},\n    \"d\": {\"parents\": [\"a\", \"c\"], \"step\": 2},\n    \"e\": {\"parents\": [\"d\"], \"step\": 3},\n}\ndag = dict_to_dag(relation_dict, parent_key=\"parents\")\n\nprint([(parent.node_name, child.node_name) for parent, child in dag_iterator(dag)])\n# [('a', 'd'), ('c', 'd'), ('d', 'e'), ('a', 'c'), ('b', 'c')]\n</code></pre>"},{"location":"demo/dag/#4-from-pandas-dataframe","title":"4. From pandas DataFrame","text":"<p>Construct nodes with attributes, pandas DataFrame contains child column, parent column, and attribute columns.</p> <pre><code>import pandas as pd\nfrom bigtree import dataframe_to_dag, dag_iterator\n\npath_data = pd.DataFrame(\n    [\n        [\"a\", None, 1],\n        [\"b\", None, 1],\n        [\"c\", \"a\", 2],\n        [\"c\", \"b\", 2],\n        [\"d\", \"a\", 2],\n        [\"d\", \"c\", 2],\n        [\"e\", \"d\", 3],\n    ],\n    columns=[\"child\", \"parent\", \"step\"],\n)\ndag = dataframe_to_dag(path_data)\n\nprint([(parent.node_name, child.node_name) for parent, child in dag_iterator(dag)])\n# [('a', 'd'), ('c', 'd'), ('d', 'e'), ('a', 'c'), ('b', 'c')]\n</code></pre>"},{"location":"demo/dag/#dag-attributes-and-operations","title":"DAG Attributes and Operations","text":"<p>Note that using <code>DAGNode</code> as superclass inherits the default class attributes (properties) and operations (methods).</p> <pre><code>from bigtree import list_to_dag\n\nrelations_list = [(\"a\", \"c\"), (\"a\", \"d\"), (\"b\", \"c\"), (\"c\", \"d\"), (\"d\", \"e\")]\ndag = list_to_dag(relations_list)\ndag\n# DAGNode(d, )\n\n# Accessing children\nnode_e = dag[\"e\"]\nnode_a = dag.parents[0]\n</code></pre> <p>Below are the tables of attributes available to <code>DAGNode</code> class.</p> Attributes wrt self Code Returns Check if root <code>node_a.is_root</code> True Check if leaf node <code>dag.is_leaf</code> False Get node name (only for <code>Node</code>) <code>dag.node_name</code> 'd' Attributes wrt structure Code Returns Get child/children <code>node_a.children</code> (DAGNode(c, ), DAGNode(d, )) Get parents <code>dag.parents</code> (DAGNode(a, ), DAGNode(c, )) Get siblings <code>dag.siblings</code> (DAGNode(c, ),) Get ancestors <code>dag.ancestors</code> [DAGNode(a, ), DAGNode(b, ), DAGNode(c, )] Get descendants <code>dag.descendants</code> [DAGNode(e, )] <p>Below is the table of operations available to <code>DAGNode</code> class.</p> Operations Code Returns Get node information <code>dag.describe(exclude_prefix=\"_\")</code> [('name', 'd')] Find path(s) from one node to another <code>node_a.go_to(dag)</code> [[DAGNode(a, ), DAGNode(c, ), DAGNode(d, description=dag-tag)], [DAGNode(a, ), DAGNode(d, description=dag-tag)]] Set attribute(s) <code>dag.set_attrs({\"description\": \"dag-tag\"})</code> None Get attribute <code>dag.get_attr(\"description\")</code> 'dag-tag' Copy DAG <code>dag.copy()</code> None"},{"location":"demo/tree/","title":"\ud83d\udccb Tree Demonstration","text":"<p>Here are some codes to get started.</p>"},{"location":"demo/tree/#construct-tree","title":"Construct Tree","text":"<p>Nodes can have attributes if they are initialized from <code>Node</code>, dictionary, or pandas DataFrame.</p>"},{"location":"demo/tree/#1-from-node","title":"1. From Node","text":"<p>Nodes can be linked to each other in the following ways:</p> <ul> <li>Using <code>parent</code> and <code>children</code> setter methods</li> <li>Directly passing <code>parent</code> or <code>children</code> argument</li> <li>Using bitshift operator with the convention <code>parent &gt;&gt; child</code> or <code>child &lt;&lt; parent</code></li> <li>Using <code>.append(child)</code> or <code>.extend([child1, child2])</code> methods</li> </ul> <code>parent</code> and <code>children</code> setter methods<code>parent</code> or <code>children</code> argumentBitshift operator<code>append</code> and <code>extend</code> <pre><code>from bigtree import Node, tree_to_dot\n\nroot = Node(\"a\")\nb = Node(\"b\")\nc = Node(\"c\")\nd = Node(\"d\")\n\nroot.children = [b, c]\nd.parent = b\n\nroot.show()\n# a\n# \u251c\u2500\u2500 b\n# \u2502   \u2514\u2500\u2500 d\n# \u2514\u2500\u2500 c\n\nroot.hshow()\n#      \u250c\u2500 b \u2500\u2500\u2500 d\n# \u2500 a \u2500\u2524\n#      \u2514\u2500 c\n\ngraph = tree_to_dot(root, node_colour=\"gold\")\ngraph.write_png(\"assets/demo/tree.png\")\n</code></pre> <pre><code>from bigtree import Node\n\nb = Node(\"b\")\nc = Node(\"c\")\nd = Node(\"d\", parent=b)\nroot = Node(\"a\", children=[b, c])\n</code></pre> <pre><code>from bigtree import Node\n\nroot = Node(\"a\")\nb = Node(\"b\")\nc = Node(\"c\")\nd = Node(\"d\")\n\nroot &gt;&gt; b\nroot &gt;&gt; c\nd &lt;&lt; b\n</code></pre> <pre><code>from bigtree import Node\n\nroot = Node(\"a\")\nb = Node(\"b\")\nc = Node(\"c\")\nd = Node(\"d\")\n\nroot.extend([b, c])\nb.append(d)\n</code></pre> <p></p>"},{"location":"demo/tree/#2-from-str","title":"2. From str","text":"<p>Construct nodes only. Newick string notation supports parsing attributes.</p> Tree stringNewick string <pre><code>from bigtree import str_to_tree\n\ntree_str = \"\"\"\na\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 d\n\u2502   \u2514\u2500\u2500 e\n\u2502       \u251c\u2500\u2500 g\n\u2502       \u2514\u2500\u2500 h\n\u2514\u2500\u2500 c\n    \u2514\u2500\u2500 f\n\"\"\"\nroot = str_to_tree(tree_str)\n\nroot.show()\n# a\n# \u251c\u2500\u2500 b\n# \u2502   \u251c\u2500\u2500 d\n# \u2502   \u2514\u2500\u2500 e\n# \u2502       \u251c\u2500\u2500 g\n# \u2502       \u2514\u2500\u2500 h\n# \u2514\u2500\u2500 c\n#     \u2514\u2500\u2500 f\n</code></pre> <pre><code>from bigtree import newick_to_tree\n\nnewick_str = \"((d,(g,h)e)b,(f)c)a\"\nroot = newick_to_tree(newick_str)\n\nroot.show()\n# a\n# \u251c\u2500\u2500 b\n# \u2502   \u251c\u2500\u2500 d\n# \u2502   \u2514\u2500\u2500 e\n# \u2502       \u251c\u2500\u2500 g\n# \u2502       \u2514\u2500\u2500 h\n# \u2514\u2500\u2500 c\n#     \u2514\u2500\u2500 f\n</code></pre>"},{"location":"demo/tree/#3-from-list","title":"3. From list","text":"<p>Construct nodes only. List can contain either full paths or tuples of parent-child names.</p> Full pathsParent-child names <pre><code>from bigtree import list_to_tree\n\nroot = list_to_tree([\"a/b/d\", \"a/c\"])\n\nroot.show()\n# a\n# \u251c\u2500\u2500 b\n# \u2502   \u2514\u2500\u2500 d\n# \u2514\u2500\u2500 c\n</code></pre> <pre><code>from bigtree import list_to_tree_by_relation\n\nroot = list_to_tree_by_relation([(\"a\", \"b\"), (\"a\", \"c\"), (\"b\", \"d\")])\n\nroot.show()\n# a\n# \u251c\u2500\u2500 b\n# \u2502   \u2514\u2500\u2500 d\n# \u2514\u2500\u2500 c\n</code></pre>"},{"location":"demo/tree/#4-from-nested-dictionary","title":"4. From nested dictionary","text":"<p>Construct nodes with attributes. Dictionary can be in a flat structure where <code>key</code> is path and <code>value</code> is dictionary of node attribute names and values, or in a recursive structure where <code>key</code> is node attribute names and <code>value</code> is node attribute values, and list of children (recursive).</p> Flat structureRecursive structure <pre><code>from bigtree import dict_to_tree\n\npath_dict = {\n   \"a\": {\"age\": 90},\n   \"a/b\": {\"age\": 65},\n   \"a/c\": {\"age\": 60},\n   \"a/b/d\": {\"age\": 40},\n}\nroot = dict_to_tree(path_dict)\n\nroot.show(attr_list=[\"age\"])\n# a [age=90]\n# \u251c\u2500\u2500 b [age=65]\n# \u2502   \u2514\u2500\u2500 d [age=40]\n# \u2514\u2500\u2500 c [age=60]\n</code></pre> <pre><code>from bigtree import nested_dict_to_tree\n\npath_dict = {\n   \"name\": \"a\",\n   \"age\": 90,\n   \"children\": [\n      {\n         \"name\": \"b\",\n         \"age\": 65,\n         \"children\": [\n            {\"name\": \"d\", \"age\": 40},\n         ],\n      },\n      {\"name\": \"c\", \"age\": 60},\n   ],\n}\nroot = nested_dict_to_tree(path_dict)\n\nroot.show(attr_list=[\"age\"])\n# a [age=90]\n# \u251c\u2500\u2500 b [age=65]\n# \u2502   \u2514\u2500\u2500 d [age=40]\n# \u2514\u2500\u2500 c [age=60]\n</code></pre>"},{"location":"demo/tree/#5-from-pandas-dataframe","title":"5. From pandas DataFrame","text":"<p>Construct nodes with attributes. Pandas DataFrame can contain either path column or parent-child columns. Other columns can be used to specify attributes.</p> Path columnParent-child columns <pre><code>import pandas as pd\n\nfrom bigtree import dataframe_to_tree\n\ndata = pd.DataFrame(\n   [\n      [\"a\", 90],\n      [\"a/b\", 65],\n      [\"a/c\", 60],\n      [\"a/b/d\", 40],\n   ],\n   columns=[\"path\", \"age\"],\n)\nroot = dataframe_to_tree(data)\n\nroot.show(attr_list=[\"age\"])\n# a [age=90]\n# \u251c\u2500\u2500 b [age=65]\n# \u2502   \u2514\u2500\u2500 d [age=40]\n# \u2514\u2500\u2500 c [age=60]\n</code></pre> <pre><code>import pandas as pd\n\nfrom bigtree import dataframe_to_tree_by_relation\n\ndata = pd.DataFrame(\n   [\n      [\"a\", None, 90],\n      [\"b\", \"a\", 65],\n      [\"c\", \"a\", 60],\n      [\"d\", \"b\", 40],\n   ],\n   columns=[\"child\", \"parent\", \"age\"],\n)\nroot = dataframe_to_tree_by_relation(data)\n\nroot.show(attr_list=[\"age\"])\n# a [age=90]\n# \u251c\u2500\u2500 b [age=65]\n# \u2502   \u2514\u2500\u2500 d [age=40]\n# \u2514\u2500\u2500 c [age=60]\n</code></pre> <p>Note</p> <p>If tree is already created, nodes can still be added using path string, dictionary, and pandas DataFrame! Attributes can be added to existing nodes using a dictionary or pandas DataFrame.</p>"},{"location":"demo/tree/#print-tree","title":"Print Tree","text":"<p>After tree is constructed, it can be viewed by printing to console using <code>show</code> or <code>hshow</code> method directly, for vertical and horizontal orientation respectively. Alternatively, the <code>print_tree</code> or <code>hprint_tree</code> method can be used.</p> <pre><code>from bigtree import Node, print_tree, hprint_tree\n\nroot = Node(\"a\", age=90, gender=\"F\")\nb = Node(\"b\", age=65, gender=\"M\", parent=root)\nc = Node(\"c\", age=60, gender=\"M\", parent=root)\nd = Node(\"d\", age=40, gender=\"F\", parent=b)\ne = Node(\"e\", age=35, gender=\"M\", parent=b)\nprint_tree(root) # (1)!\n# a\n# \u251c\u2500\u2500 b\n# \u2502   \u251c\u2500\u2500 d\n# \u2502   \u2514\u2500\u2500 e\n# \u2514\u2500\u2500 c\n\nhprint_tree(root) # (2)!\n#            \u250c\u2500 d\n#      \u250c\u2500 b \u2500\u2524\n# \u2500 a \u2500\u2524     \u2514\u2500 e\n#      \u2514\u2500 c\n\n# Print subtree\nprint_tree(root, node_name_or_path=\"b\")\n# b\n# \u251c\u2500\u2500 d\n# \u2514\u2500\u2500 e\n\nprint_tree(root, max_depth=2)\n# a\n# \u251c\u2500\u2500 b\n# \u2514\u2500\u2500 c\n\n# Print attributes\nprint_tree(root, attr_list=[\"age\"])\n# a [age=90]\n# \u251c\u2500\u2500 b [age=65]\n# \u2502   \u251c\u2500\u2500 d [age=40]\n# \u2502   \u2514\u2500\u2500 e [age=35]\n# \u2514\u2500\u2500 c [age=60]\n\nprint_tree(root, attr_list=[\"age\"], attr_bracket=[\"*(\", \")\"])\n# a *(age=90)\n# \u251c\u2500\u2500 b *(age=65)\n# \u2502   \u251c\u2500\u2500 d *(age=40)\n# \u2502   \u2514\u2500\u2500 e *(age=35)\n# \u2514\u2500\u2500 c *(age=60)\n\nprint_tree(root, all_attrs=True)\n# a [age=90, gender=F]\n# \u251c\u2500\u2500 b [age=65, gender=M]\n# \u2502   \u251c\u2500\u2500 d [age=40, gender=F]\n# \u2502   \u2514\u2500\u2500 e [age=35, gender=M]\n# \u2514\u2500\u2500 c [age=60, gender=M]\n\n# Available styles\nprint_tree(root, style=\"ansi\")\n# a\n# |-- b\n# |   |-- d\n# |   `-- e\n# `-- c\n\nprint_tree(root, style=\"ascii\")\n# a\n# |-- b\n# |   |-- d\n# |   +-- e\n# +-- c\n\nprint_tree(root, style=\"const\")\n# a\n# \u251c\u2500\u2500 b\n# \u2502   \u251c\u2500\u2500 d\n# \u2502   \u2514\u2500\u2500 e\n# \u2514\u2500\u2500 c\n\nprint_tree(root, style=\"const_bold\")\n# a\n# \u2523\u2501\u2501 b\n# \u2503   \u2523\u2501\u2501 d\n# \u2503   \u2517\u2501\u2501 e\n# \u2517\u2501\u2501 c\n\nprint_tree(root, style=\"rounded\")\n# a\n# \u251c\u2500\u2500 b\n# \u2502   \u251c\u2500\u2500 d\n# \u2502   \u2570\u2500\u2500 e\n# \u2570\u2500\u2500 c\n\nprint_tree(root, style=\"double\")\n# a\n# \u2560\u2550\u2550 b\n# \u2551   \u2560\u2550\u2550 d\n# \u2551   \u255a\u2550\u2550 e\n# \u255a\u2550\u2550 c\n\nprint_tree(\n    root,\n    style=\"custom\",\n    custom_style=(\"\u2502  \", \"\u251c\u2192 \", \"\u2570\u2192 \"),\n)\n# a\n# \u251c\u2192 b\n# \u2502  \u251c\u2192 d\n# \u2502  \u2570\u2192 e\n# \u2570\u2192 c\n</code></pre> <ol> <li>Alternatively, <code>root.show()</code> can be used</li> <li>Alternatively, <code>root.hshow()</code> can be used</li> </ol>"},{"location":"demo/tree/#tree-attributes-and-operations","title":"Tree Attributes and Operations","text":"<p>Note that using <code>BaseNode</code> or <code>Node</code> as superclass inherits the default class attributes (properties) and operations (methods).</p> <pre><code>from bigtree import str_to_tree\n\n# Initialize tree\ntree_str = \"\"\"\na\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 d\n\u2502   \u251c\u2500\u2500 e\n\u2502   \u2514\u2500\u2500 f\n\u2502       \u251c\u2500\u2500 h\n\u2502       \u2514\u2500\u2500 i\n\u2514\u2500\u2500 c\n    \u2514\u2500\u2500 g\n\"\"\"\nroot = str_to_tree(tree_str)\n\n# Accessing children\nnode_b = root[\"b\"]\nnode_e = root[\"b\"][\"e\"]\n</code></pre> <p>Below are the tables of attributes available to <code>BaseNode</code> and <code>Node</code> classes.</p> Attributes wrt self Code Returns Check if root <code>root.is_root</code> True Check if leaf node <code>root.is_leaf</code> False Check depth of node <code>node_b.depth</code> 2 Check depth of tree <code>node_b.max_depth</code> 4 Get root of tree <code>node_b.root</code> Node(/a, ) Get node path <code>node_b.node_path</code> (Node(/a, ), Node(/a/b, )) Get node name (only for <code>Node</code>) <code>node_b.node_name</code> 'b' Get node path name (only for <code>Node</code>) <code>node_b.path_name</code> '/a/b' Attributes wrt structure Code Returns Get child/children <code>root.children</code> (Node(/a/b, ), Node(/a/c, )) Get parent <code>node_e.parent</code> Node(/a/b, ) Get siblings <code>node_e.siblings</code> (Node(/a/b/d, ), Node(/a/b/f, )) Get left sibling <code>node_e.left_sibling</code> Node(/a/b/d, ) Get right sibling <code>node_e.right_sibling</code> Node(/a/b/f, ) Get ancestors (lazy evaluation) <code>list(node_e.ancestors)</code> [Node(/a/b, ), Node(/a, )] Get descendants (lazy evaluation) <code>list(node_b.descendants)</code> [Node(/a/b/d, ), Node(/a/b/e, ), Node(/a/b/f, ), Node(/a/b/f/h, ), Node(/a/b/f/i, )] Get leaves (lazy evaluation) <code>list(node_b.leaves)</code> [Node(/a/b/d, ), Node(/a/b/e, ), Node(/a/b/f/h, ), Node(/a/b/f/i, )] <p>Below is the table of operations available to <code>BaseNode</code> and <code>Node</code> classes.</p> Operations Code Returns Visualize tree (only for <code>Node</code>) <code>root.show()</code> None Visualize tree (horizontally) (only for <code>Node</code>) <code>root.hshow()</code> None Get node information <code>root.describe(exclude_prefix=\"_\")</code> [('name', 'a')] Find path from one node to another <code>root.go_to(node_e)</code> [Node(/a, ), Node(/a/b, ), Node(/a/b/e, )] Add child to node <code>root.append(Node(\"j\"))</code> None Add multiple children to node <code>root.extend([Node(\"k\"), Node(\"l\")])</code> None Set attribute(s) <code>root.set_attrs({\"description\": \"root-tag\"})</code> None Get attribute <code>root.get_attr(\"description\")</code> 'root-tag' Copy tree <code>root.copy()</code> None Sort children <code>root.sort(key=lambda node: node.node_name, reverse=True)</code> None"},{"location":"demo/tree/#traverse-tree","title":"Traverse Tree","text":"<p>Tree can be traversed using the following traversal methods.</p> <pre><code>from bigtree import (\n    Node,\n    levelorder_iter,\n    levelordergroup_iter,\n    postorder_iter,\n    preorder_iter,\n    zigzag_iter,\n    zigzaggroup_iter,\n)\n\nroot = Node(\"a\")\nb = Node(\"b\", parent=root)\nc = Node(\"c\", parent=root)\nd = Node(\"d\", parent=b)\ne = Node(\"e\", parent=b)\nroot.show()\n# a\n# \u251c\u2500\u2500 b\n# \u2502   \u251c\u2500\u2500 d\n# \u2502   \u2514\u2500\u2500 e\n# \u2514\u2500\u2500 c\n\n[node.name for node in preorder_iter(root)]\n# ['a', 'b', 'd', 'e', 'c']\n\n[node.name for node in postorder_iter(root)]\n# ['d', 'e', 'b', 'c', 'a']\n\n[node.name for node in levelorder_iter(root)]\n# ['a', 'b', 'c', 'd', 'e']\n\n[[node.name for node in node_group] for node_group in levelordergroup_iter(root)]\n# [['a'], ['b', 'c'], ['d', 'e']]\n\n[node.name for node in zigzag_iter(root)]\n# ['a', 'c', 'b', 'd', 'e']\n\n[[node.name for node in node_group] for node_group in zigzaggroup_iter(root)]\n# [['a'], ['c', 'b'], ['d', 'e']]\n</code></pre>"},{"location":"demo/tree/#modify-tree","title":"Modify Tree","text":"<p>Nodes can be shifted (with or without replacement) or copied (without replacement) from one path to another, this changes the tree in-place. Nodes can also be copied (with or without replacement) between two different trees.</p> Shift nodes <pre><code>from bigtree import list_to_tree, shift_nodes, shift_and_replace_nodes\n\nroot = list_to_tree(\n    [\"Downloads/Pictures\", \"Downloads/photo1.jpg\", \"Downloads/file1.doc\"]\n)\nroot.show()\n# Downloads\n# \u251c\u2500\u2500 Pictures\n# \u251c\u2500\u2500 photo1.jpg\n# \u2514\u2500\u2500 file1.doc\n\nshift_nodes(\n   tree=root,\n   from_paths=[\"photo1.jpg\", \"Downloads/file1.doc\"],\n   to_paths=[\"Downloads/Pictures/photo1.jpg\", \"Downloads/Files/file1.doc\"],\n)\nroot.show()\n# Downloads\n# \u251c\u2500\u2500 Pictures\n# \u2502   \u2514\u2500\u2500 photo1.jpg (1)\n# \u2514\u2500\u2500 Files\n#     \u2514\u2500\u2500 file1.doc (2)\n\nshift_and_replace_nodes(\n   tree=root,\n   from_paths=[\"Downloads/Files\"],\n   to_paths=[\"Downloads/Pictures/photo1.jpg\"],\n)\nroot.show()\n# Downloads\n# \u2514\u2500\u2500 Pictures\n#     \u2514\u2500\u2500 Files (3)\n#         \u2514\u2500\u2500 file1.doc\n</code></pre> <ol> <li>The first shift to destination <code>Downloads/Pictures/photo1.jpg</code></li> <li>The second shift to destination <code>Downloads/Files/file1.doc</code>, this creates intermediate Node <code>Files</code> as well</li> <li>Shift and replace <code>photo1.jpg</code> with <code>Files</code> folder</li> </ol> Copy nodes <pre><code>from bigtree import list_to_tree, copy_nodes\n\nroot = list_to_tree(\n    [\"Downloads/Pictures\", \"Downloads/photo1.jpg\", \"Downloads/file1.doc\"]\n)\nroot.show()\n# Downloads\n# \u251c\u2500\u2500 Pictures\n# \u251c\u2500\u2500 photo1.jpg\n# \u2514\u2500\u2500 file1.doc\n\ncopy_nodes(\n   tree=root,\n   from_paths=[\"photo1.jpg\", \"Downloads/file1.doc\"],\n   to_paths=[\"Downloads/Pictures/photo1.jpg\", \"Downloads/Files/file1.doc\"],\n)\nroot.show()\n# Downloads\n# \u251c\u2500\u2500 Pictures\n# \u2502   \u2514\u2500\u2500 photo1.jpg (1)\n# \u251c\u2500\u2500 photo1.jpg (2)\n# \u251c\u2500\u2500 file1.doc (4)\n# \u2514\u2500\u2500 Files\n#     \u2514\u2500\u2500 file1.doc (3)\n</code></pre> <ol> <li>The first copy to destination <code>Downloads/Pictures/photo1.jpg</code></li> <li>Original <code>photo1.jpg</code> still remains</li> <li>The second copy to destination <code>Downloads/Files/file1.doc</code>, this creates intermediate Node <code>Files</code> as well</li> <li>Original <code>file1.doc</code> still remains</li> </ol> Copy nodes between two trees <pre><code>from bigtree import (\n    Node,\n    copy_nodes_from_tree_to_tree,\n    copy_and_replace_nodes_from_tree_to_tree,\n    list_to_tree,\n)\n\nroot = list_to_tree(\n    [\"Downloads/Pictures\", \"Downloads/photo1.jpg\", \"Downloads/file1.doc\"]\n)\nroot.show()\n# Downloads\n# \u251c\u2500\u2500 Pictures\n# \u251c\u2500\u2500 photo1.jpg\n# \u2514\u2500\u2500 file1.doc\n\nroot_other = Node(\"Documents\")\ncopy_nodes_from_tree_to_tree(\n    from_tree=root,\n    to_tree=root_other,\n    from_paths=[\"Downloads/Pictures\", \"photo1.jpg\", \"file1.doc\"],\n    to_paths=[\n        \"Documents/Pictures\",\n        \"Documents/Pictures/photo1.jpg\",\n        \"Documents/Files/file1.doc\",\n    ],\n)\nroot_other.show()\n# Documents\n# \u251c\u2500\u2500 Pictures (1)\n# \u2502   \u2514\u2500\u2500 photo1.jpg (2)\n# \u2514\u2500\u2500 Files\n#     \u2514\u2500\u2500 file1.doc (3)\n\nroot_other = Node(\"Documents\")\npicture_folder = Node(\"Pictures\", parent=root_other)\nphoto2 = Node(\"photo2.jpg\", parent=picture_folder)\nfile2 = Node(\"file2.doc\", parent=root_other)\nroot_other.show()\n# Documents\n# \u251c\u2500\u2500 Pictures\n# \u2502   \u2514\u2500\u2500 photo2.jpg\n# \u2514\u2500\u2500 file2.doc\n\ncopy_and_replace_nodes_from_tree_to_tree(\n    from_tree=root,\n    to_tree=root_other,\n    from_paths=[\"Downloads/photo1.jpg\", \"Downloads/file1.doc\"],\n    to_paths=[\"Documents/Pictures/photo2.jpg\", \"Documents/file2.doc\"],\n)\nroot_other.show()\n# Documents\n# \u251c\u2500\u2500 Pictures\n# \u2502   \u2514\u2500\u2500 photo1.jpg (4)\n# \u2514\u2500\u2500 file1.doc (5)\n</code></pre> <ol> <li>The first copy to destination <code>Documents/Pictures</code></li> <li>The second copy to destination <code>Documents/Pictures/photo1.jpg</code></li> <li>The third copy to destination <code>Documents/Files/file1.doc</code>, this creates intermediate Node <code>Files</code> as well</li> <li>The first copy and replace of <code>Documents/Pictures/photo2.jpg</code> with <code>photo1.jpg</code></li> <li>The second copy and replace of <code>Documents/file2.doc</code> with <code>file1.doc</code></li> </ol>"},{"location":"demo/tree/#tree-search","title":"Tree Search","text":"<p>One or multiple nodes can be searched based on name, path, attribute value, or user-defined condition. It is also possible to search for one or more child node(s) based on attributes, this search will be faster as it does not require traversing the whole tree to find the node(s).</p> Find single nodeFind multiple nodesFind child nodes <pre><code>from bigtree import Node, find, find_name, find_path, find_relative_path, find_full_path, find_attr\nroot = Node(\"a\", age=90)\nb = Node(\"b\", age=65, parent=root)\nc = Node(\"c\", age=60, parent=root)\nd = Node(\"d\", age=40, parent=c)\nroot.show(attr_list=[\"age\"])\n# a [age=90]\n# \u251c\u2500\u2500 b [age=65]\n# \u2514\u2500\u2500 c [age=60]\n#     \u2514\u2500\u2500 d [age=40]\n\nfind(root, lambda node: node.age == 60)\n# Node(/a/c, age=60)\n\nfind_name(root, \"d\")\n# Node(/a/c/d, age=40)\n\nfind_relative_path(c, \"../b\")  # relative path\n# (Node(/a/b, age=65),)\n\nfind_path(root, \"/c/d\")  # partial path\n# Node(/a/c/d, age=40)\n\nfind_full_path(root, \"a/c/d\")  # full path\n# Node(/a/c/d, age=40)\n\nfind_attr(root, \"age\", 40)\n# Node(/a/c/d, age=40)\n</code></pre> <pre><code>from bigtree import Node, findall, find_names, find_relative_path, find_paths, find_attrs\nroot = Node(\"a\", age=90)\nb = Node(\"b\", age=65, parent=root)\nc = Node(\"c\", age=60, parent=root)\nd = Node(\"c\", age=40, parent=c)\nroot.show(attr_list=[\"age\"])\n# a [age=90]\n# \u251c\u2500\u2500 b [age=65]\n# \u2514\u2500\u2500 c [age=60]\n#     \u2514\u2500\u2500 c [age=40]\n\nfindall(root, lambda node: node.age &gt;= 65)\n# (Node(/a, age=90), Node(/a/b, age=65))\n\nfind_names(root, \"c\")\n# (Node(/a/c, age=60), Node(/a/c/c, age=40))\n\nfind_relative_path(c, \"../*\")  # relative path\n# (Node(/a/b, age=65), Node(/a/c, age=60))\n\nfind_paths(root, \"/c\")  # partial path\n# (Node(/a/c, age=60), Node(/a/c/c, age=40))\n\nfind_attrs(root, \"age\", 40)\n# (Node(/a/c/c, age=40),)\n</code></pre> <pre><code>from bigtree import Node, find_children, find_child, find_child_by_name\nroot = Node(\"a\", age=90)\nb = Node(\"b\", age=65, parent=root)\nc = Node(\"c\", age=60, parent=root)\nd = Node(\"c\", age=40, parent=c)\nroot.show(attr_list=[\"age\"])\n# a [age=90]\n# \u251c\u2500\u2500 b [age=65]\n# \u2514\u2500\u2500 c [age=60]\n#     \u2514\u2500\u2500 c [age=40]\n\nfind_children(root, lambda node: node.age &gt;= 60)\n# (Node(/a/b, age=65), Node(/a/c, age=60))\n\nfind_child(root, lambda node: node.name == \"c\")\n# Node(/a/c, age=60)\n\nfind_child_by_name(root, \"c\")\n# Node(/a/c, age=60)\n\nfind_child_by_name(c, \"c\")\n# Node(/a/c/c, age=40)\n</code></pre>"},{"location":"demo/tree/#helper-utility","title":"Helper Utility","text":"<p>There following are helper functions for</p>"},{"location":"demo/tree/#1-cloning-tree-to-another-node-type","title":"1. Cloning tree to another Node type","text":"<pre><code>from bigtree import BaseNode, Node, clone_tree\n\n# Cloning tree from `BaseNode` to `Node` type\nroot = BaseNode(name=\"a\")\nb = BaseNode(name=\"b\", parent=root)\nclone_tree(root, Node)\n# Node(/a, )\n</code></pre>"},{"location":"demo/tree/#2-getting-subtree-smaller-tree-with-different-root","title":"2. Getting subtree (smaller tree with different root)","text":"<pre><code>from bigtree import str_to_tree, get_subtree\n\nroot = str_to_tree(\"\"\"\na\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 d\n\u2502   \u2514\u2500\u2500 e\n\u2514\u2500\u2500 c\n    \u2514\u2500\u2500 f\n\"\"\")\n\n# Getting subtree with root b\nroot_subtree = get_subtree(root, \"b\")\nroot_subtree.show()\n# b\n# \u251c\u2500\u2500 d\n# \u2514\u2500\u2500 e\n</code></pre>"},{"location":"demo/tree/#3-pruning-tree-smaller-tree-with-same-root","title":"3. Pruning tree (smaller tree with same root)","text":"<pre><code>from bigtree import str_to_tree, prune_tree\n\nroot = str_to_tree(\"\"\"\na\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 d\n\u2502   \u2514\u2500\u2500 e\n\u2514\u2500\u2500 c\n    \u2514\u2500\u2500 f\n\"\"\")\n\n# Prune tree to only path a/b\nroot_pruned = prune_tree(root, \"a/b\")\nroot_pruned.show()\n# a\n# \u2514\u2500\u2500 b\n#     \u251c\u2500\u2500 d\n#     \u2514\u2500\u2500 e\n\n# Prune tree to exactly path a/b\nroot_pruned = prune_tree(root, \"a/b\", exact=True)\nroot_pruned.show()\n# a\n# \u2514\u2500\u2500 b\n</code></pre>"},{"location":"demo/tree/#4-getting-difference-between-two-trees","title":"4. Getting difference between two trees","text":"<pre><code>from bigtree import str_to_tree, get_tree_diff\n\nroot = str_to_tree(\"\"\"\na\n\u251c\u2500\u2500 b\n\u2502   \u251c\u2500\u2500 d\n\u2502   \u2514\u2500\u2500 e\n\u2514\u2500\u2500 c\n    \u2514\u2500\u2500 f\n\"\"\")\n\n# Get difference between two trees\nroot_other = str_to_tree(\"\"\"\na\n\u251c\u2500\u2500 b\n\u2502   \u2514\u2500\u2500 d\n\u2514\u2500\u2500 c\n    \u2514\u2500\u2500 g\n\"\"\")\n\ntree_diff = get_tree_diff(root, root_other)\ntree_diff.show()\n# a\n# \u251c\u2500\u2500 b\n# \u2502   \u2514\u2500\u2500 e (-)\n# \u2514\u2500\u2500 c\n#     \u251c\u2500\u2500 f (-)\n#     \u2514\u2500\u2500 g (+)\n\ntree_diff = get_tree_diff(root, root_other, only_diff=False)\ntree_diff.show()\n# a\n# \u251c\u2500\u2500 b\n# \u2502   \u251c\u2500\u2500 d\n# \u2502   \u2514\u2500\u2500 e (-)\n# \u2514\u2500\u2500 c\n#     \u251c\u2500\u2500 f (-)\n#     \u2514\u2500\u2500 g (+)\n</code></pre>"},{"location":"demo/tree/#export-tree","title":"Export Tree","text":"<p>Tree can be exported to other data types:</p> <ol> <li>Newick string notation</li> <li>Nested dictionary (flat structure and recursive structure)</li> <li>pandas DataFrame</li> <li>Dot (can save to .dot, .png, .svg, .jpeg files)</li> <li>Pillow (can save to .png, .jpg)</li> <li>Mermaid Flowchart (can display on .md)</li> </ol> <pre><code>from bigtree import Node\n\nroot = Node(\"a\", age=90)\nb = Node(\"b\", age=65, parent=root)\nc = Node(\"c\", age=60, parent=root)\nd = Node(\"d\", age=40, parent=b)\ne = Node(\"e\", age=35, parent=b)\nroot.show()\n# a\n# \u251c\u2500\u2500 b\n# \u2502   \u251c\u2500\u2500 d\n# \u2502   \u2514\u2500\u2500 e\n# \u2514\u2500\u2500 c\n</code></pre> Newick string notationDictionary (flat structure)Dictionary (recursive structure)pandas DataFrameDotPillowMermaid Flowchart <pre><code>from bigtree import tree_to_newick\n\ntree_to_newick(root)\n# '((d,e)b,c)a'\n\ntree_to_newick(root, attr_list=[\"age\"])\n# '((d[&amp;&amp;NHX:age=40],e[&amp;&amp;NHX:age=35])b[&amp;&amp;NHX:age=65],c[&amp;&amp;NHX:age=60])a[&amp;&amp;NHX:age=90]'\n</code></pre> <pre><code>from bigtree import tree_to_dict\n\ntree_to_dict(\n   root,\n   name_key=\"name\",\n   parent_key=\"parent\",\n   attr_dict={\"age\": \"person age\"}\n)\n# {\n#    '/a': {'name': 'a', 'parent': None, 'person age': 90},\n#    '/a/b': {'name': 'b', 'parent': 'a', 'person age': 65},\n#    '/a/b/d': {'name': 'd', 'parent': 'b', 'person age': 40},\n#    '/a/b/e': {'name': 'e', 'parent': 'b', 'person age': 35},\n#    '/a/c': {'name': 'c', 'parent': 'a', 'person age': 60}\n# }\n</code></pre> <pre><code>from bigtree import tree_to_nested_dict\n\ntree_to_nested_dict(root, all_attrs=True)\n# {\n#    'name': 'a',\n#    'age': 90,\n#    'children': [\n#       {\n#          'name': 'b',\n#          'age': 65,\n#          'children': [\n#             {\n#                'name': 'd',\n#                'age': 40\n#             },\n#             {\n#                'name': 'e',\n#                'age': 35\n#             }\n#          ]\n#       },\n#       {\n#          'name': 'c',\n#          'age': 60\n#       }\n#    ]\n# }\n</code></pre> <pre><code>from bigtree import tree_to_dataframe\n\ntree_to_dataframe(\n   root,\n   name_col=\"name\",\n   parent_col=\"parent\",\n   path_col=\"path\",\n   attr_dict={\"age\": \"person age\"}\n)\n#      path name parent  person age\n# 0      /a    a   None          90\n# 1    /a/b    b      a          65\n# 2  /a/b/d    d      b          40\n# 3  /a/b/e    e      b          35\n# 4    /a/c    c      a          60\n</code></pre> <pre><code>from bigtree import tree_to_dot\n\ngraph = tree_to_dot(root, node_colour=\"gold\")\ngraph.write_png(\"assets/demo/dot.png\")\n</code></pre> <pre><code>from bigtree import tree_to_pillow\n\npillow_image = tree_to_pillow(root)\npillow_image.save(\"assets/demo/pillow.png\")\n</code></pre> <pre><code>from bigtree import tree_to_mermaid\n\nmermaid_md = tree_to_mermaid(root)\nprint(mermaid_md)\n</code></pre> <ul> <li>dot.png</li> </ul> <p></p> <ul> <li>pillow.png</li> </ul> <p></p> <ul> <li>Mermaid flowchart <pre><code>%%{ init: { 'flowchart': { 'curve': 'basis' } } }%%\nflowchart TB\n0(\"a\") --&gt; 0-0(\"b\")\n0-0 --&gt; 0-0-0(\"d\")\n0-0 --&gt; 0-0-1(\"e\")\n0(\"a\") --&gt; 0-1(\"c\")\nclassDef default stroke-width:1</code></pre></li> </ul>"},{"location":"demo/workflow/","title":"\ud83d\udccb Workflow Demonstration","text":"<p>There are existing implementations of workflows to showcase how <code>bigtree</code> can be used!</p>"},{"location":"demo/workflow/#to-do-application","title":"To Do Application","text":"<p>There are functions to:</p> <ul> <li>Add or remove list to To-Do application</li> <li>Add or remove item to list, default list is the 'General' list</li> <li>Prioritize a list/item by reordering them as first list/item</li> <li>Save and import To-Do application to and from an external JSON file</li> <li>Show To-Do application, which prints tree to console</li> </ul> <pre><code>from bigtree import AppToDo\n\napp = AppToDo(\"To Do App\")\napp.add_item(item_name=\"Homework 1\", list_name=\"School\")\napp.add_item(item_name=[\"Milk\", \"Bread\"], list_name=\"Groceries\", description=\"Urgent\")\napp.add_item(item_name=\"Cook\")\napp.show()\n# To Do App\n# \u251c\u2500\u2500 School\n# \u2502   \u2514\u2500\u2500 Homework 1\n# \u251c\u2500\u2500 Groceries\n# \u2502   \u251c\u2500\u2500 Milk [description=Urgent]\n# \u2502   \u2514\u2500\u2500 Bread [description=Urgent]\n# \u2514\u2500\u2500 General\n#     \u2514\u2500\u2500 Cook\n\napp.save(\"list.json\")\napp2 = AppToDo.load(\"list.json\")\n</code></pre>"},{"location":"demo/workflow/#calendar-application","title":"Calendar Application","text":"<p>There are functions to:</p> <ul> <li>Add or remove event from Calendar</li> <li>Find event by name, or name and date</li> <li>Display calendar, which prints events to console</li> <li>Export calendar to pandas DataFrame</li> </ul> <pre><code>import datetime as dt\nfrom bigtree import Calendar\n\ncalendar = Calendar(\"My Calendar\")\ncalendar.add_event(\"Gym\", \"2023-01-01 18:00\")\ncalendar.add_event(\"Dinner\", \"2023-01-01\", date_format=\"%Y-%m-%d\", budget=20)\ncalendar.add_event(\"Gym\", \"2023-01-02 18:00\")\ncalendar.show()\n# My Calendar\n# 2023-01-01 00:00:00 - Dinner (budget: 20)\n# 2023-01-01 18:00:00 - Gym\n# 2023-01-02 18:00:00 - Gym\n\ncalendar.find_event(\"Gym\")\n# 2023-01-01 18:00:00 - Gym\n# 2023-01-02 18:00:00 - Gym\n\ncalendar.delete_event(\"Gym\", dt.date(2023, 1, 1))\ncalendar.show()\n# My Calendar\n# 2023-01-01 00:00:00 - Dinner (budget: 20)\n# 2023-01-02 18:00:00 - Gym\n\ndata_calendar = calendar.to_dataframe()\ndata_calendar\n#                              path    name        date      time  budget\n# 0  /My Calendar/2023/01/01/Dinner  Dinner  2023-01-01  00:00:00    20.0\n# 1     /My Calendar/2023/01/02/Gym     Gym  2023-01-02  18:00:00     NaN\n</code></pre>"},{"location":"others/","title":"\ud83d\udca1 Tips and Tricks","text":""},{"location":"others/list_dir/","title":"List Directory","text":"<p>To list directories recursively using bigtree, we can use the <code>glob</code> built-in Python package to extract a list of paths.</p> <pre><code>import glob\nfrom bigtree import list_to_tree, print_tree\n\n# Get all directories recursively\npath_list = []\nfor f in glob.glob(\"./**/*.py\", recursive=True):\n    path_list.append(f)\n\n# Construct tree\nroot = list_to_tree(path_list)\n\n# View tree\nprint_tree(root, max_depth=3)\n</code></pre>"},{"location":"others/merging_trees/","title":"Merging Trees","text":"<p>To merge two separate trees into one, we can use the tree modify module.</p> <p>In this example, we are merging two trees that have similar node <code>Pictures</code>. Children of node <code>Pictures</code> from both trees are retained as long as <code>merge_children=True</code> is set. If only children of the other tree are desired, set <code>overriding=True</code> instead.</p> <pre><code>from bigtree import Node, copy_nodes_from_tree_to_tree\n\n# Construct trees\ndownloads_folder = Node(\"Downloads\")\npictures_folder = Node(\"Pictures\", parent=downloads_folder)\nphoto1 = Node(\"photo1.jpg\", parent=pictures_folder)\nfile1 = Node(\"file1.doc\", parent=downloads_folder)\n\ndocuments_folder = Node(\"Documents\")\npictures_folder = Node(\"Pictures\", parent=documents_folder)\nphoto2 = Node(\"photo2.jpg\", parent=pictures_folder)\n\n# Validate tree structure\ndownloads_folder.show()\n# Downloads\n# \u251c\u2500\u2500 Pictures\n# \u2502   \u2514\u2500\u2500 photo1.jpg\n# \u2514\u2500\u2500 file1.doc\n\ndocuments_folder.show()\n# Documents\n# \u2514\u2500\u2500 Pictures\n#     \u2514\u2500\u2500 photo2.jpg\n\n# Merge trees\ncopy_nodes_from_tree_to_tree(\n    from_tree=documents_folder,\n    to_tree=downloads_folder,\n    from_paths=[\"Documents/Pictures\"],\n    to_paths=[\"Downloads/Pictures\"],\n    merge_children=True,  # set overriding=True to override existing children\n)\n\n# Validate tree structure\ndownloads_folder.show()\n# Downloads\n# \u251c\u2500\u2500 Pictures\n# \u2502   \u251c\u2500\u2500 photo1.jpg\n# \u2502   \u2514\u2500\u2500 photo2.jpg\n# \u2514\u2500\u2500 file1.doc\n</code></pre>"},{"location":"others/nodes/","title":"Extending Nodes","text":"<p>Nodes can be extended from <code>BaseNode</code> or <code>Node</code> class to have extended functionalities or add pre-/post-assign checks.  - For example, <code>Node</code> class extends <code>BaseNode</code> and added the <code>name</code> functionality with pre-assign checks to ensure no duplicate path names.</p>"},{"location":"others/nodes/#population-node-add-functionalitymethodproperty","title":"Population Node (add functionality/method/property)","text":"<pre><code>from bigtree import Node, print_tree\n\n\nclass PopulationNode(Node):\n\n    def __init__(self, name: str, population: int = 0, **kwargs):\n        super().__init__(name, **kwargs)\n        self._population = population\n\n    @property\n    def population(self):\n        if self.is_leaf:\n            return self._population\n        return sum([child.population for child in self.children])\n\n    @property\n    def percentage(self):\n        if self.is_root:\n            return 1\n        return round(self.population / self.root.population, 2)\n\n\nroot = PopulationNode(\"World\")\nb1 = PopulationNode(\"Country A\", parent=root)\nc1 = PopulationNode(\"State A1\", 100, parent=b1)\nc2 = PopulationNode(\"State A2\", 50, parent=b1)\nb2 = PopulationNode(\"Country B\", 200, parent=root)\nb3 = PopulationNode(\"Country C\", 100, parent=root)\n\nprint_tree(root, attr_list=[\"population\", \"percentage\"])\n# World [population=450, percentage=1]\n# \u251c\u2500\u2500 Country A [population=150, percentage=0.33]\n# \u2502   \u251c\u2500\u2500 State A1 [population=100, percentage=0.22]\n# \u2502   \u2514\u2500\u2500 State A2 [population=50, percentage=0.11]\n# \u251c\u2500\u2500 Country B [population=200, percentage=0.44]\n# \u2514\u2500\u2500 Country C [population=100, percentage=0.22]\n</code></pre>"},{"location":"others/nodes/#read-only-node-add-pre-post-assign-checks","title":"Read-Only Node (add pre-/post-assign checks)","text":"<pre><code>import pytest\n\nfrom bigtree import Node\nfrom typing import List\n\n\nclass ReadOnlyNode(Node):\n\n    def __init__(self, *args, **kwargs):\n        self.__readonly = False\n        super().__init__(*args, **kwargs)\n        self.__readonly = True\n\n    def _Node__pre_assign_parent(self, new_parent: Node):\n        if self.__readonly:\n            raise RuntimeError(\"Nodes cannot be reassigned for ReadOnlyNode\")\n\n    def _Node__pre_assign_children(self, new_children: List[Node]):\n        if self.__readonly:\n            raise RuntimeError(\"Nodes cannot be reassigned for ReadOnlyNode\")\n\n\na = ReadOnlyNode(\"a\")\nb = ReadOnlyNode(\"b\", parent=a)\nc = ReadOnlyNode(\"c\", parent=a)\n\nwith pytest.raises(RuntimeError):\n    c.parent = b\n\nwith pytest.raises(RuntimeError):\n    a.children = [b, c]\n</code></pre>"},{"location":"others/weighted_trees/","title":"Trees with Weighted Edges","text":"<p>Edge weights should be defined in the child node for the parent-child edge since each node can only have one parent.</p> <p>We can simply add <code>weight</code> attribute to the <code>Node</code> class. However, if we want to visualize the weighted tree, we can create a <code>WeightedNode</code> class to generate the edge attribute dictionary.</p> <pre><code>from bigtree import Node, tree_to_dot\n\nclass WeightedNode(Node):\n    def __init__(self, name, weight=0, **kwargs):\n        super().__init__(name, **kwargs)\n        self.weight = weight\n\n    @property\n    def edge_attr(self):\n        \"\"\"Edge attribute for pydot diagram\n        Label for edge label, penwidth for edge width\n        \"\"\"\n        return {\"label\": self.weight, \"penwidth\": self.weight}\n\n# Construct weighted tree\nroot = WeightedNode(\"a\")\nb = WeightedNode(\"b\", parent=root, weight=1)\nc = WeightedNode(\"c\", parent=root, weight=2)\nd = WeightedNode(\"d\", parent=b, weight=3)\n\ngraph = tree_to_dot(root, node_colour=\"gold\", edge_attr=\"edge_attr\")\ngraph.write_png(\"assets/docs/weighted_tree.png\")\n</code></pre> <p></p>"}]}